

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Utils module &mdash; Orb 1.4.0 documentation</title>
  

  
  
    <link rel="shortcut icon" href="_static/logo.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/sphinx_paramlinks.css" type="text/css" />
  

  
    <link rel="top" title="Orb 1.4.0 documentation" href="index.html"/>
        <link rel="next" title="CUtils module" href="cutils_module.html"/>
        <link rel="prev" title="Core module" href="core_module.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="index.html" class="icon icon-home"> Orb
        

        
          
          <img src="_static/logo.png" class="logo" />
        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="installing_orb.html">Installing Orb</a><ul>
<li class="toctree-l2"><a class="reference internal" href="installing_orb.html#unpacking">Unpacking</a><ul>
<li class="toctree-l3"><a class="reference internal" href="installing_orb.html#make-orb-accessible-to-all-users">Make ORB accessible to all users</a></li>
<li class="toctree-l3"><a class="reference internal" href="installing_orb.html#make-orb-accessible-to-you-alone">Make ORB accessible to you alone</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="installing_python.html">Installing Python</a><ul>
<li class="toctree-l2"><a class="reference internal" href="installing_python.html#python">Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="installing_python.html#modules">Modules</a><ul>
<li class="toctree-l3"><a class="reference internal" href="installing_python.html#to-use-the-viewer-orb-viewer">To use the Viewer (orb-viewer)</a></li>
<li class="toctree-l3"><a class="reference internal" href="installing_python.html#scipy-and-numpy">Scipy and Numpy</a></li>
<li class="toctree-l3"><a class="reference internal" href="installing_python.html#pyfits">PyFITS</a></li>
<li class="toctree-l3"><a class="reference internal" href="installing_python.html#parallel-python">Parallel Python</a></li>
<li class="toctree-l3"><a class="reference internal" href="installing_python.html#pywcs">PyWCS</a></li>
<li class="toctree-l3"><a class="reference internal" href="installing_python.html#bottleneck">Bottleneck</a></li>
<li class="toctree-l3"><a class="reference internal" href="installing_python.html#h5py">h5py</a><ul>
<li class="toctree-l4"><a class="reference internal" href="installing_python.html#install-szip">Install SZIP</a></li>
<li class="toctree-l4"><a class="reference internal" href="installing_python.html#install-hdf5">Install HDF5</a></li>
<li class="toctree-l4"><a class="reference internal" href="installing_python.html#install-h5py-pip-cannot-be-used-directly">Install H5PY (pip cannot be used directly)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="installing_python.html#tkinter">Tkinter</a></li>
<li class="toctree-l3"><a class="reference internal" href="installing_python.html#cython">Cython</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="python_for_orb.html">Python for ORB users</a><ul>
<li class="toctree-l2"><a class="reference internal" href="python_for_orb.html#the-basics">The basics</a><ul>
<li class="toctree-l3"><a class="reference internal" href="python_for_orb.html#hello-world">Hello world</a></li>
<li class="toctree-l3"><a class="reference internal" href="python_for_orb.html#handling-arrays">Handling arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="python_for_orb.html#a-simple-loop">A simple loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="python_for_orb.html#plotting-data">Plotting data</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="python_for_orb.html#importing-and-using-orb">Importing and using ORB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="python_for_orb.html#importing-orb">Importing ORB</a></li>
<li class="toctree-l3"><a class="reference internal" href="python_for_orb.html#reading-and-writing-fits">Reading and writing FITS</a></li>
<li class="toctree-l3"><a class="reference internal" href="python_for_orb.html#loading-large-cubes-or-reduction-data">Loading large cubes or reduction data</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="data_analysis_with_orb.html">Data analysis with ORB</a><ul>
<li class="toctree-l2"><a class="reference internal" href="data_analysis_with_orb.html#analyzing-interferometric-data">Analyzing interferometric data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="data_analysis_with_orb.html#creating-an-interferometric-cube">Creating an interferometric cube</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="core_module.html">Core module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="core_module.html#tools-class">Tools class</a></li>
<li class="toctree-l2"><a class="reference internal" href="core_module.html#cube-class">Cube class</a></li>
<li class="toctree-l2"><a class="reference internal" href="core_module.html#textcolor-class">TextColor class</a></li>
<li class="toctree-l2"><a class="reference internal" href="core_module.html#progressbar-class">ProgressBar class</a></li>
<li class="toctree-l2"><a class="reference internal" href="core_module.html#memfile-class">MemFile class</a></li>
<li class="toctree-l2"><a class="reference internal" href="core_module.html#indexer-class">Indexer class</a></li>
<li class="toctree-l2"><a class="reference internal" href="core_module.html#lines-class">Lines class</a></li>
<li class="toctree-l2"><a class="reference internal" href="core_module.html#optionfile-class">OptionFile class</a></li>
<li class="toctree-l2"><a class="reference internal" href="core_module.html#paramsfile-class">ParamsFile class</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Utils module</a></li>
<li class="toctree-l1"><a class="reference internal" href="cutils_module.html">CUtils module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="cutils_module.html#contents">Contents</a></li>
<li class="toctree-l2"><a class="reference internal" href="cutils_module.html#module-cutils">Cutils</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="astrometry_module.html">Astrometry module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="astrometry_module.html#astrometry-class">Astrometry class</a></li>
<li class="toctree-l2"><a class="reference internal" href="astrometry_module.html#aligner-class">Aligner class</a></li>
<li class="toctree-l2"><a class="reference internal" href="astrometry_module.html#starsparams-class">StarsParams class</a></li>
<li class="toctree-l2"><a class="reference internal" href="astrometry_module.html#psf-class">PSF class</a></li>
<li class="toctree-l2"><a class="reference internal" href="astrometry_module.html#gaussian-class">Gaussian class</a></li>
<li class="toctree-l2"><a class="reference internal" href="astrometry_module.html#moffat-class">Moffat class</a></li>
<li class="toctree-l2"><a class="reference internal" href="astrometry_module.html#astrometry-functions">Astrometry functions</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a><ul>
<li class="toctree-l2"><a class="reference internal" href="changelog.html#v1-0-creation-of-orb">v1.0 Creation of ORB</a></li>
<li class="toctree-l2"><a class="reference internal" href="changelog.html#v1-1">v1.1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="changelog.html#multi-fit-of-stars">Multi fit of stars</a></li>
<li class="toctree-l3"><a class="reference internal" href="changelog.html#usno-b1-based-star-detection">USNO-B1 based star detection</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="changelog.html#v1-2">v1.2</a><ul>
<li class="toctree-l3"><a class="reference internal" href="changelog.html#v1-2-1">v1.2.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="changelog.html#v1-2-2">v1.2.2</a><ul>
<li class="toctree-l4"><a class="reference internal" href="changelog.html#orcs-integration">ORCS integration</a></li>
<li class="toctree-l4"><a class="reference internal" href="changelog.html#orb-s-scripts">ORB&#8217;s scripts</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="changelog.html#v1-2-3">v1.2.3</a></li>
<li class="toctree-l3"><a class="reference internal" href="changelog.html#v1-2-4">v1.2.4</a><ul>
<li class="toctree-l4"><a class="reference internal" href="changelog.html#miscellaneous">Miscellaneous</a></li>
<li class="toctree-l4"><a class="reference internal" href="changelog.html#sitelle-data">SITELLE data</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="changelog.html#v1-2-4-1">v1.2.4.1</a></li>
<li class="toctree-l3"><a class="reference internal" href="changelog.html#v1-2-4-2">v1.2.4.2</a><ul>
<li class="toctree-l4"><a class="reference internal" href="changelog.html#astropy">Astropy</a></li>
<li class="toctree-l4"><a class="reference internal" href="changelog.html#better-star-fit">Better Star fit</a></li>
<li class="toctree-l4"><a class="reference internal" href="changelog.html#spiomm-bias-overscan-for-camera-2">SpIOMM bias overscan for camera 2</a></li>
<li class="toctree-l4"><a class="reference internal" href="changelog.html#id1">Miscellaneous</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="changelog.html#v1-3-start-of-cfht-integration">v1.3 Start of CFHT integration</a><ul>
<li class="toctree-l3"><a class="reference internal" href="changelog.html#v1-3-0-orb-viewer">v1.3.0 ORB-Viewer</a></li>
<li class="toctree-l3"><a class="reference internal" href="changelog.html#v1-3-1">v1.3.1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="changelog.html#orb-header">orb-header</a></li>
<li class="toctree-l4"><a class="reference internal" href="changelog.html#id2">Miscellaneous</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="changelog.html#v1-3-2">v1.3.2</a><ul>
<li class="toctree-l4"><a class="reference internal" href="changelog.html#scripts">scripts</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="changelog.html#v1-3-3">v1.3.3</a><ul>
<li class="toctree-l4"><a class="reference internal" href="changelog.html#alignement">Alignement</a></li>
<li class="toctree-l4"><a class="reference internal" href="changelog.html#sip-distorsion">SIP/Distorsion</a></li>
<li class="toctree-l4"><a class="reference internal" href="changelog.html#hdf5">HDF5</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="changelog.html#v1-3-4-0">v1.3.4.0</a><ul>
<li class="toctree-l4"><a class="reference internal" href="changelog.html#binning-detection">Binning detection</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="changelog.html#v1-3-4-1">v1.3.4.1</a><ul>
<li class="toctree-l4"><a class="reference internal" href="changelog.html#doc-update">Doc update</a></li>
<li class="toctree-l4"><a class="reference internal" href="changelog.html#id3">Miscellaneous</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="changelog.html#v1-4-the-hdf5-miracle">v1.4 The HDF5 miracle</a><ul>
<li class="toctree-l3"><a class="reference internal" href="changelog.html#v1-4-0">v1.4.0</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Orb</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Utils module</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/utils_module.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="module-utils">
<span id="utils-module"></span><h1>Utils module<a class="headerlink" href="#module-utils" title="Permalink to this headline">¶</a></h1>
<p>Utils module contains functions that are used by the processing
classes of ORBS</p>
<dl class="function">
<dt id="utils.ABmag2flambda">
<code class="descclassname">utils.</code><code class="descname">ABmag2flambda</code><span class="sig-paren">(</span><em>ABmag</em>, <em>lam</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.ABmag2flambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert AB magnitude to flux in erg/cm2/s/A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.ABmag2flambda.params.ABmag"></span><strong>ABmag</strong><a class="paramlink headerlink reference internal" href="#utils.ABmag2flambda.params.ABmag">¶</a> &#8211; A magnitude in the AB magnitude system</li>
<li><span class="target" id="utils.ABmag2flambda.params.lam"></span><strong>lam</strong><a class="paramlink headerlink reference internal" href="#utils.ABmag2flambda.params.lam">¶</a> &#8211; Wavelength in angstrom</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.ABmag2fnu">
<code class="descclassname">utils.</code><code class="descname">ABmag2fnu</code><span class="sig-paren">(</span><em>ABmag</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.ABmag2fnu" title="Permalink to this definition">¶</a></dt>
<dd><p>Return flux in erg/cm2/s/Hz from AB magnitude (Oke, ApJS, 27,
21, 1974)</p>
<p>ABmag = -2.5 * log10(f_nu) - 48.60
f_nu = 10^(-0.4 * (ABmag + 48.60))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="utils.ABmag2fnu.params.ABmag"></span><strong>ABmag</strong><a class="paramlink headerlink reference internal" href="#utils.ABmag2fnu.params.ABmag">¶</a> &#8211; A magnitude in the AB magnitude system</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Definition of the zero-point can change and be
e.g. 48.59 for Oke standard stars (Hamuy et al., PASP, 104, 533,
1992). This is the case for Spectrophotometric Standards given
on the ESO website (<a class="reference external" href="https://www.eso.org/sci/observing/tools/standards/spectra/okestandards.html">https://www.eso.org/sci/observing/tools/standards/spectra/okestandards.html</a>). Here the HST definition is used.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.amplitude">
<code class="descclassname">utils.</code><code class="descname">amplitude</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.amplitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the amplitude of a complex number</p>
</dd></dl>

<dl class="function">
<dt id="utils.border_cut_window">
<code class="descclassname">utils.</code><code class="descname">border_cut_window</code><span class="sig-paren">(</span><em>n</em>, <em>coeff=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.border_cut_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a window function with only the edges cut by a nice
gaussian shape function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.border_cut_window.params.n"></span><strong>n</strong><a class="paramlink headerlink reference internal" href="#utils.border_cut_window.params.n">¶</a> &#8211; Window length</li>
<li><span class="target" id="utils.border_cut_window.params.coeff"></span><strong>coeff</strong><a class="paramlink headerlink reference internal" href="#utils.border_cut_window.params.coeff">¶</a> &#8211; Border size in percentage of the total length.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.check_frames">
<code class="descclassname">utils.</code><code class="descname">check_frames</code><span class="sig-paren">(</span><em>frames</em>, <em>sigma_reject=2.5</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.check_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Check and reject deviating frames based on their median level.</p>
<p>Frames with a too deviant median level are discarded. This
function is used by <a class="reference internal" href="#utils.create_master_frame" title="utils.create_master_frame"><code class="xref py py-meth docutils literal"><span class="pre">utils.create_master_frame()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.check_frames.params.frames"></span><strong>frames</strong><a class="paramlink headerlink reference internal" href="#utils.check_frames.params.frames">¶</a> &#8211; Set of frames to check</li>
<li><span class="target" id="utils.check_frames.params.sigma_reject"></span><strong>sigma_reject</strong><a class="paramlink headerlink reference internal" href="#utils.check_frames.params.sigma_reject">¶</a> &#8211; (Optional) Rejection coefficient (default 2.5)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.cm12nm">
<code class="descclassname">utils.</code><code class="descname">cm12nm</code><span class="sig-paren">(</span><em>cm1</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.cm12nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavenumber in cm-1 to a wavelength in nm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="utils.cm12nm.params.cm1"></span><strong>cm1</strong><a class="paramlink headerlink reference internal" href="#utils.cm12nm.params.cm1">¶</a> &#8211; wavenumber in cm-1</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.cm12pix">
<code class="descclassname">utils.</code><code class="descname">cm12pix</code><span class="sig-paren">(</span><em>cm1_axis</em>, <em>cm1</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.cm12pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavenumber in cm-1 to a pixel position given an axis
in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.cm12pix.params.cm1_axis"></span><strong>cm1_axis</strong><a class="paramlink headerlink reference internal" href="#utils.cm12pix.params.cm1_axis">¶</a> &#8211; Axis in cm-1</li>
<li><span class="target" id="utils.cm12pix.params.cm1"></span><strong>cm1</strong><a class="paramlink headerlink reference internal" href="#utils.cm12pix.params.cm1">¶</a> &#8211; Wavenumber in cm-1</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.compute_binning">
<code class="descclassname">utils.</code><code class="descname">compute_binning</code><span class="sig-paren">(</span><em>image_shape</em>, <em>detector_shape</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.compute_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Return binning along both axis given the image shape and the
detector shape.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.compute_binning.params.image_size"></span><strong>image_size</strong><a class="paramlink headerlink reference internal" href="#utils.compute_binning.params.image_size">¶</a> &#8211; Tuple [x,y] giving the image shape</li>
<li><span class="target" id="utils.compute_binning.params.detector_shape"></span><strong>detector_shape</strong><a class="paramlink headerlink reference internal" href="#utils.compute_binning.params.detector_shape">¶</a> &#8211; Tuple [x,y] giving the detector shape
(i.e. maximum numbers of pixels along the x and y axis.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.compute_line_fwhm">
<code class="descclassname">utils.</code><code class="descname">compute_line_fwhm</code><span class="sig-paren">(</span><em>step_nb</em>, <em>step</em>, <em>order</em>, <em>apod_coeff=1.0</em>, <em>wavenumber=False</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.compute_line_fwhm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expected FWHM (in nm or in cm-1) of a line given the
observation parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.compute_line_fwhm.params.step_nb"></span><strong>step_nb</strong><a class="paramlink headerlink reference internal" href="#utils.compute_line_fwhm.params.step_nb">¶</a> &#8211; Number of steps</li>
<li><span class="target" id="utils.compute_line_fwhm.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#utils.compute_line_fwhm.params.step">¶</a> &#8211; Step size in nm</li>
<li><span class="target" id="utils.compute_line_fwhm.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#utils.compute_line_fwhm.params.order">¶</a> &#8211; Folding order</li>
<li><span class="target" id="utils.compute_line_fwhm.params.apod_coeff"></span><strong>apod_coeff</strong><a class="paramlink headerlink reference internal" href="#utils.compute_line_fwhm.params.apod_coeff">¶</a> &#8211; (Optional) Apodization coefficient. 1. stand
for no apodization and gives the FWHM of the central lobe of the
sinc (default 1.)</li>
<li><span class="target" id="utils.compute_line_fwhm.params.wavenumber"></span><strong>wavenumber</strong><a class="paramlink headerlink reference internal" href="#utils.compute_line_fwhm.params.wavenumber">¶</a> &#8211; (Optional) If True the result is returned in cm-1,
else it is returned in nm.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.compute_line_shift">
<code class="descclassname">utils.</code><code class="descname">compute_line_shift</code><span class="sig-paren">(</span><em>velocity</em>, <em>step_nb</em>, <em>step</em>, <em>order</em>, <em>wavenumber=False</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.compute_line_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the line shift given its velocity in nm or in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.compute_line_shift.params.velocity"></span><strong>velocity</strong><a class="paramlink headerlink reference internal" href="#utils.compute_line_shift.params.velocity">¶</a> &#8211; Line velocity in km.s-1</li>
<li><span class="target" id="utils.compute_line_shift.params.step_nb"></span><strong>step_nb</strong><a class="paramlink headerlink reference internal" href="#utils.compute_line_shift.params.step_nb">¶</a> &#8211; Number of steps</li>
<li><span class="target" id="utils.compute_line_shift.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#utils.compute_line_shift.params.step">¶</a> &#8211; Step size in nm</li>
<li><span class="target" id="utils.compute_line_shift.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#utils.compute_line_shift.params.order">¶</a> &#8211; Folding order</li>
<li><span class="target" id="utils.compute_line_shift.params.wavenumber"></span><strong>wavenumber</strong><a class="paramlink headerlink reference internal" href="#utils.compute_line_shift.params.wavenumber">¶</a> &#8211; (Optional) If True the result is returned in cm-1,
else it is returned in nm.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.compute_obs_params">
<code class="descclassname">utils.</code><code class="descname">compute_obs_params</code><span class="sig-paren">(</span><em>nm_min_filter</em>, <em>nm_max_filter</em>, <em>theta_min=5.01</em>, <em>theta_max=11.28</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.compute_obs_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute observation parameters (order, step size) given the
filter bandpass.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="utils.compute_obs_params.params.nm_min_filter"></span><strong>nm_min_filter</strong><a class="paramlink headerlink reference internal" href="#utils.compute_obs_params.params.nm_min_filter">¶</a> &#8211; Min wavelength of the filter in nm.</li>
<li><span class="target" id="utils.compute_obs_params.params.nm_max_filter"></span><strong>nm_max_filter</strong><a class="paramlink headerlink reference internal" href="#utils.compute_obs_params.params.nm_max_filter">¶</a> &#8211; Max wavelength of the filter in nm.</li>
<li><span class="target" id="utils.compute_obs_params.params.theta_min"></span><strong>theta_min</strong><a class="paramlink headerlink reference internal" href="#utils.compute_obs_params.params.theta_min">¶</a> &#8211; (Optional) Min angle of the detector (default
5.01).</li>
<li><span class="target" id="utils.compute_obs_params.params.theta_max"></span><strong>theta_max</strong><a class="paramlink headerlink reference internal" href="#utils.compute_obs_params.params.theta_max">¶</a> &#8211; (Optional) Max angle of the detector (default
11.28).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple (order, step size, max wavelength)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.compute_radial_velocity">
<code class="descclassname">utils.</code><code class="descname">compute_radial_velocity</code><span class="sig-paren">(</span><em>line</em>, <em>rest_line</em>, <em>wavenumber=False</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.compute_radial_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return radial velocity in km.s-1</p>
<p>V [km.s-1] = c [km.s-1]* (Lambda - Lambda_0) / Lambda_0</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.compute_radial_velocity.params.line"></span><strong>line</strong><a class="paramlink headerlink reference internal" href="#utils.compute_radial_velocity.params.line">¶</a> &#8211; Emission line wavelength/wavenumber (can be a numpy
array)</li>
<li><span class="target" id="utils.compute_radial_velocity.params.rest_line"></span><strong>rest_line</strong><a class="paramlink headerlink reference internal" href="#utils.compute_radial_velocity.params.rest_line">¶</a> &#8211; Rest-frame wavelength/wavenumber (can be a numpy
array but must have the same size as line)</li>
<li><span class="target" id="utils.compute_radial_velocity.params.wavenumber"></span><strong>wavenumber</strong><a class="paramlink headerlink reference internal" href="#utils.compute_radial_velocity.params.wavenumber">¶</a> &#8211; (Optional) If True the result is returned in cm-1,
else it is returned in nm.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.correct_bad_frames_vector">
<code class="descclassname">utils.</code><code class="descname">correct_bad_frames_vector</code><span class="sig-paren">(</span><em>bad_frames_vector</em>, <em>dimz</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.correct_bad_frames_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove bad indexes of the bad frame vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.correct_bad_frames_vector.params.bad_frames_vector"></span><strong>bad_frames_vector</strong><a class="paramlink headerlink reference internal" href="#utils.correct_bad_frames_vector.params.bad_frames_vector">¶</a> &#8211; The vector of indexes to correct</li>
<li><span class="target" id="utils.correct_bad_frames_vector.params.dimz"></span><strong>dimz</strong><a class="paramlink headerlink reference internal" href="#utils.correct_bad_frames_vector.params.dimz">¶</a> &#8211; Dimension of the cube along the 3rd axis.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.correct_hot_pixels">
<code class="descclassname">utils.</code><code class="descname">correct_hot_pixels</code><span class="sig-paren">(</span><em>im</em>, <em>hp_map</em>, <em>box_size=3</em>, <em>std_filter_coeff=1.5</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.correct_hot_pixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct hot pixels in an image given a map of their position.</p>
<p>The algorithm used replaces a hot pixel value by the median of the
pixels in a box around it. Pixels values which are not too much
different from the values around are not modified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.correct_hot_pixels.params.im"></span><strong>im</strong><a class="paramlink headerlink reference internal" href="#utils.correct_hot_pixels.params.im">¶</a> &#8211; Image to correct</li>
<li><span class="target" id="utils.correct_hot_pixels.params.hp_map"></span><strong>hp_map</strong><a class="paramlink headerlink reference internal" href="#utils.correct_hot_pixels.params.hp_map">¶</a> &#8211; Hot pixels map (1 for hot pixels, 0 for normal
pixel)</li>
<li><span class="target" id="utils.correct_hot_pixels.params.box_size"></span><strong>box_size</strong><a class="paramlink headerlink reference internal" href="#utils.correct_hot_pixels.params.box_size">¶</a> &#8211; (Optional) Size of the correction box (default
3).</li>
<li><span class="target" id="utils.correct_hot_pixels.params.std_filter_coeff"></span><strong>std_filter_coeff</strong><a class="paramlink headerlink reference internal" href="#utils.correct_hot_pixels.params.std_filter_coeff">¶</a> &#8211; (Optional) Coefficient on the std used to
check if the value of a hot pixel must be changed (default 1.5).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.correct_map2d">
<code class="descclassname">utils.</code><code class="descname">correct_map2d</code><span class="sig-paren">(</span><em>map2d</em>, <em>bad_value=nan</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.correct_map2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct a map of values by interpolation along columns.</p>
<p>The bad value must be specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.correct_map2d.params.map2d"></span><strong>map2d</strong><a class="paramlink headerlink reference internal" href="#utils.correct_map2d.params.map2d">¶</a> &#8211; The map to correct</li>
<li><span class="target" id="utils.correct_map2d.params.bad_value"></span><strong>bad_value</strong><a class="paramlink headerlink reference internal" href="#utils.correct_map2d.params.bad_value">¶</a> &#8211; (Optional) Value considered as bad (default
np.nan).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.correct_vector">
<code class="descclassname">utils.</code><code class="descname">correct_vector</code><span class="sig-paren">(</span><em>vector</em>, <em>bad_value=nan</em>, <em>deg=3</em>, <em>polyfit=False</em>, <em>smoothing=True</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.correct_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct a given vector for non valid values by interpolation or
polynomial fit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.correct_vector.params.vector"></span><strong>vector</strong><a class="paramlink headerlink reference internal" href="#utils.correct_vector.params.vector">¶</a> &#8211; The vector to be corrected.</li>
<li><span class="target" id="utils.correct_vector.params.bad_value"></span><strong>bad_value</strong><a class="paramlink headerlink reference internal" href="#utils.correct_vector.params.bad_value">¶</a> &#8211; (Optional) Bad value to correct (default np.nan)</li>
<li><span class="target" id="utils.correct_vector.params.deg"></span><strong>deg</strong><a class="paramlink headerlink reference internal" href="#utils.correct_vector.params.deg">¶</a> &#8211; (Optional) Spline degree or polyfit degree (default 3)</li>
<li><span class="target" id="utils.correct_vector.params.polyfit"></span><strong>polyfit</strong><a class="paramlink headerlink reference internal" href="#utils.correct_vector.params.polyfit">¶</a> &#8211; (Optional) If True non valid values are guessed
using a polynomial fit to the data instead of an spline
interpolation (default False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.count_nonzeros">
<code class="descclassname">utils.</code><code class="descname">count_nonzeros</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.count_nonzeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of nonzeros parts in a vector as a vector of
the same length with the length of each part at each occurence of
a nonzero number.</p>
<p>e.g. : if a = [0,0,0,1,1,0,1] this function returns: [0,0,0,2,2,0,1]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="utils.count_nonzeros.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#utils.count_nonzeros.params.a">¶</a> &#8211; A vector.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.create_cm1_axis">
<code class="descclassname">utils.</code><code class="descname">create_cm1_axis</code><span class="sig-paren">(</span><em>n</em>, <em>step</em>, <em>order</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.create_cm1_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a regular wavenumber axis in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.create_cm1_axis.params.n"></span><strong>n</strong><a class="paramlink headerlink reference internal" href="#utils.create_cm1_axis.params.n">¶</a> &#8211; Number of steps on the axis</li>
<li><span class="target" id="utils.create_cm1_axis.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#utils.create_cm1_axis.params.step">¶</a> &#8211; Step size in nm</li>
<li><span class="target" id="utils.create_cm1_axis.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#utils.create_cm1_axis.params.order">¶</a> &#8211; Folding order</li>
<li><span class="target" id="utils.create_cm1_axis.params.corr"></span><strong>corr</strong><a class="paramlink headerlink reference internal" href="#utils.create_cm1_axis.params.corr">¶</a> &#8211; (Optional) Coefficient of correction (default 1.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.create_master_frame">
<code class="descclassname">utils.</code><code class="descname">create_master_frame</code><span class="sig-paren">(</span><em>frames</em>, <em>combine='average'</em>, <em>reject='avsigclip'</em>, <em>sigma=3.0</em>, <em>silent=False</em>, <em>check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.create_master_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a master frame from a set a frames.</p>
<p>This method has been inspired by the <strong>IRAF</strong> function
combine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.create_master_frame.params.frames"></span><strong>frames</strong><a class="paramlink headerlink reference internal" href="#utils.create_master_frame.params.frames">¶</a> &#8211; Frames to combine.</li>
<li><span class="target" id="utils.create_master_frame.params.reject"></span><strong>reject</strong><a class="paramlink headerlink reference internal" href="#utils.create_master_frame.params.reject">¶</a> &#8211; (Optional) Rejection operation. Can be &#8216;sigclip&#8217;,
&#8216;minmax&#8217;, &#8216;avsigclip&#8217; (default &#8216;avsigclip&#8217;)</li>
<li><span class="target" id="utils.create_master_frame.params.combine"></span><strong>combine</strong><a class="paramlink headerlink reference internal" href="#utils.create_master_frame.params.combine">¶</a> &#8211; (Optional) Combining operation. Can be
&#8216;average&#8217; or &#8216;median&#8217; (default &#8216;average&#8217;)</li>
<li><span class="target" id="utils.create_master_frame.params.sigma"></span><strong>sigma</strong><a class="paramlink headerlink reference internal" href="#utils.create_master_frame.params.sigma">¶</a> &#8211; (Optional) Sigma factor for pixel rejection
(default 3.).</li>
<li><span class="target" id="utils.create_master_frame.params.silent"></span><strong>silent</strong><a class="paramlink headerlink reference internal" href="#utils.create_master_frame.params.silent">¶</a> &#8211; (Optional) If True no information message are
displayed.</li>
<li><span class="target" id="utils.create_master_frame.params.check"></span><strong>check</strong><a class="paramlink headerlink reference internal" href="#utils.create_master_frame.params.check">¶</a> &#8211; (Optional) If True deviating frames are rejected
before combination (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Rejection operations:</p>
<ul class="last simple">
<li><strong>sigclip</strong>: A Sigma Clipping algorithm is applied for
each pixel. Min and max values are rejected to estimate
the mean and the standard deviation at each pixel. Then
all values over (median + sigma * std) or below (median -
sigma * std) are rejected. Those steps are repeated (this
time not excluding the extreme values) while no other
value is rejected or the minimum number of values to keep
is reached. Work best with at least 10 frames.</li>
<li><strong>avsigclip</strong>: Average Sigma Clipping algorithm is the
same as Sigma Clipping algorithm but the standard
deviation at each pixel is estimated using an averaged
value of the std over the lines. This work best than sigma
clipping for a small number of frames. This algorithm is a
little more time consuming than the others. Works best with
at least 5 frames.</li>
<li><strong>minmax</strong>: Minimum and maximum values at each pixel are
rejected.</li>
</ul>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">No rejection operation can be performed with less
than 3 frames.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.create_nm_axis">
<code class="descclassname">utils.</code><code class="descname">create_nm_axis</code><span class="sig-paren">(</span><em>n</em>, <em>step</em>, <em>order</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.create_nm_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a regular wavelength axis in nm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.create_nm_axis.params.n"></span><strong>n</strong><a class="paramlink headerlink reference internal" href="#utils.create_nm_axis.params.n">¶</a> &#8211; Number of steps on the axis</li>
<li><span class="target" id="utils.create_nm_axis.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#utils.create_nm_axis.params.step">¶</a> &#8211; Step size in nm</li>
<li><span class="target" id="utils.create_nm_axis.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#utils.create_nm_axis.params.order">¶</a> &#8211; Folding order (cannot be 0)</li>
<li><span class="target" id="utils.create_nm_axis.params.corr"></span><strong>corr</strong><a class="paramlink headerlink reference internal" href="#utils.create_nm_axis.params.corr">¶</a> &#8211; (Optional) Coefficient of correction (default 1.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.create_nm_axis_ireg">
<code class="descclassname">utils.</code><code class="descname">create_nm_axis_ireg</code><span class="sig-paren">(</span><em>n</em>, <em>step</em>, <em>order</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.create_nm_axis_ireg" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an irregular wavelength axis from the regular wavenumber
axis in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.create_nm_axis_ireg.params.n"></span><strong>n</strong><a class="paramlink headerlink reference internal" href="#utils.create_nm_axis_ireg.params.n">¶</a> &#8211; Number of steps on the axis</li>
<li><span class="target" id="utils.create_nm_axis_ireg.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#utils.create_nm_axis_ireg.params.step">¶</a> &#8211; Step size in nm</li>
<li><span class="target" id="utils.create_nm_axis_ireg.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#utils.create_nm_axis_ireg.params.order">¶</a> &#8211; Folding order (must be &gt; 0)</li>
<li><span class="target" id="utils.create_nm_axis_ireg.params.corr"></span><strong>corr</strong><a class="paramlink headerlink reference internal" href="#utils.create_nm_axis_ireg.params.corr">¶</a> &#8211; (Optional) Coefficient of correction (default 1.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.cube_raw_fft">
<code class="descclassname">utils.</code><code class="descname">cube_raw_fft</code><span class="sig-paren">(</span><em>x</em>, <em>apod=None</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.cube_raw_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the raw FFT of a cube (the last axis
beeing the interferogram axis)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.cube_raw_fft.params.x"></span><strong>x</strong><a class="paramlink headerlink reference internal" href="#utils.cube_raw_fft.params.x">¶</a> &#8211; Interferogram cube</li>
<li><span class="target" id="utils.cube_raw_fft.params.apod"></span><strong>apod</strong><a class="paramlink headerlink reference internal" href="#utils.cube_raw_fft.params.apod">¶</a> &#8211; (Optional) Apodization function used. See
<a class="reference internal" href="#utils.norton_beer_window" title="utils.norton_beer_window"><code class="xref py py-meth docutils literal"><span class="pre">utils.norton_beer_window()</span></code></a> (default None)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.fft_filter">
<code class="descclassname">utils.</code><code class="descname">fft_filter</code><span class="sig-paren">(</span><em>a</em>, <em>cutoff_coeff</em>, <em>width_coeff=0.2</em>, <em>filter_type='high_pass'</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.fft_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple lowpass or highpass FFT filter (high pass or low pass)</p>
<p>Filter shape is a gaussian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.fft_filter.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#utils.fft_filter.params.a">¶</a> &#8211; Vector to filter</li>
<li><span class="target" id="utils.fft_filter.params.cutoff_coeff"></span><strong>cutoff_coeff</strong><a class="paramlink headerlink reference internal" href="#utils.fft_filter.params.cutoff_coeff">¶</a> &#8211; Coefficient defining the position of the cut
frequency (Cut frequency = cut_coeff * vector length)</li>
<li><span class="target" id="utils.fft_filter.params.width_coeff"></span><strong>width_coeff</strong><a class="paramlink headerlink reference internal" href="#utils.fft_filter.params.width_coeff">¶</a> &#8211; (Optional) Coefficient defining the width of
the smoothed part of the filter (width = width_coeff * vector
length) (default 0.2)</li>
<li><span class="target" id="utils.fft_filter.params.filter_type"></span><strong>filter_type</strong><a class="paramlink headerlink reference internal" href="#utils.fft_filter.params.filter_type">¶</a> &#8211; (Optional) Type of filter to use. Can be
&#8216;high_pass&#8217; or &#8216;low_pass&#8217;.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.find_zpd">
<code class="descclassname">utils.</code><code class="descname">find_zpd</code><span class="sig-paren">(</span><em>interf</em>, <em>step_number=None</em>, <em>return_zpd_shift=False</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.find_zpd" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the ZPD along the z axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.find_zpd.params.step_number"></span><strong>step_number</strong><a class="paramlink headerlink reference internal" href="#utils.find_zpd.params.step_number">¶</a> &#8211; (Optional) If the full number of steps is
greater than the number of frames of the cube. Useful when
the interferograms are non symetric (default None).</li>
<li><span class="target" id="utils.find_zpd.params.return_zpd_shift"></span><strong>return_zpd_shift</strong><a class="paramlink headerlink reference internal" href="#utils.find_zpd.params.return_zpd_shift">¶</a> &#8211; (Optional) If True return ZPD shift
instead of ZPD index (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.fit_lines_in_vector">
<code class="descclassname">utils.</code><code class="descname">fit_lines_in_vector</code><span class="sig-paren">(</span><em>vector</em>, <em>lines</em>, <em>fwhm_guess=3.5</em>, <em>cont_guess=None</em>, <em>shift_guess=0.0</em>, <em>fix_cont=False</em>, <em>fix_fwhm=False</em>, <em>cov_fwhm=True</em>, <em>cov_pos=True</em>, <em>reguess_positions=False</em>, <em>return_fitted_vector=False</em>, <em>fit_tol=0.001</em>, <em>no_absorption=False</em>, <em>poly_order=0</em>, <em>fmodel='gaussian'</em>, <em>sig_noise=None</em>, <em>observation_params=None</em>, <em>signal_range=None</em>, <em>wavenumber=False</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.fit_lines_in_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit multiple gaussian shaped emission lines in a spectrum vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="utils.fit_lines_in_vector.params.vector"></span><strong>vector</strong><a class="paramlink headerlink reference internal" href="#utils.fit_lines_in_vector.params.vector">¶</a> &#8211; Vector to fit</li>
<li><span class="target" id="utils.fit_lines_in_vector.params.lines"></span><strong>lines</strong><a class="paramlink headerlink reference internal" href="#utils.fit_lines_in_vector.params.lines">¶</a> &#8211; Positions of the lines in channels</li>
<li><span class="target" id="utils.fit_lines_in_vector.params.fwhm_guess"></span><strong>fwhm_guess</strong><a class="paramlink headerlink reference internal" href="#utils.fit_lines_in_vector.params.fwhm_guess">¶</a> &#8211; (Optional) Initial guess on the lines FWHM
(default 3.5).</li>
<li><span class="target" id="utils.fit_lines_in_vector.params.cont_guess"></span><strong>cont_guess</strong><a class="paramlink headerlink reference internal" href="#utils.fit_lines_in_vector.params.cont_guess">¶</a> &#8211; (Optional) Initial guess on the continuum
(default None). Must be a tuple of poly_order + 1 values ordered
with the highest orders first.</li>
<li><span class="target" id="utils.fit_lines_in_vector.params.shift_guess"></span><strong>shift_guess</strong><a class="paramlink headerlink reference internal" href="#utils.fit_lines_in_vector.params.shift_guess">¶</a> &#8211; (Optional) Initial guess on the global shift
of the lines (default 0.).</li>
<li><span class="target" id="utils.fit_lines_in_vector.params.fix_cont"></span><strong>fix_cont</strong><a class="paramlink headerlink reference internal" href="#utils.fit_lines_in_vector.params.fix_cont">¶</a> &#8211; (Optional) If True, continuum is fixed to the
initial guess (default False).</li>
<li><span class="target" id="utils.fit_lines_in_vector.params.fix_fwhm"></span><strong>fix_fwhm</strong><a class="paramlink headerlink reference internal" href="#utils.fit_lines_in_vector.params.fix_fwhm">¶</a> &#8211; (Optional) If True, FWHM value is fixed to the
initial guess (default False).</li>
<li><span class="target" id="utils.fit_lines_in_vector.params.cov_fwhm"></span><strong>cov_fwhm</strong><a class="paramlink headerlink reference internal" href="#utils.fit_lines_in_vector.params.cov_fwhm">¶</a> &#8211; (Optional) If True FWHM is considered to be the
same for all lines and become a covarying parameter (default
True).</li>
<li><span class="target" id="utils.fit_lines_in_vector.params.cov_pos"></span><strong>cov_pos</strong><a class="paramlink headerlink reference internal" href="#utils.fit_lines_in_vector.params.cov_pos">¶</a> &#8211; (Optional) If True the estimated relative
positions of the lines (the lines parameter) are considered to
be exact and only need to be shifted. Positions are thus
covarying. Very useful but the initial estimation of the line
relative positions must be very precise. This parameter can also
be a tuple of the same length as the number of lines to
distinguish the covarying lines. Covarying lines must share the
same number. e.g. on 4 lines, [NII]6548, Halpha, [NII]6584,
[SII]6717, [SII]6731, if each ion has a different velocity
cov_pos can be : [0,1,0,2,2]. (default False).</li>
<li><span class="target" id="utils.fit_lines_in_vector.params.reguess_positions"></span><strong>reguess_positions</strong><a class="paramlink headerlink reference internal" href="#utils.fit_lines_in_vector.params.reguess_positions">¶</a> &#8211; (Optional) If True, positions are
guessed again. Useful if the given estimations really are rough
ones. Note that this must not be used with cov_pos set to True
(default False).</li>
<li><span class="target" id="utils.fit_lines_in_vector.params.return_fitted_vector"></span><strong>return_fitted_vector</strong><a class="paramlink headerlink reference internal" href="#utils.fit_lines_in_vector.params.return_fitted_vector">¶</a> &#8211; (Optional) If True Fitted vector is
returned.</li>
<li><span class="target" id="utils.fit_lines_in_vector.params.fit_tol"></span><strong>fit_tol</strong><a class="paramlink headerlink reference internal" href="#utils.fit_lines_in_vector.params.fit_tol">¶</a> &#8211; (Optional) Tolerance on the fit value (default
1e-2).</li>
<li><span class="target" id="utils.fit_lines_in_vector.params.no_absorption"></span><strong>no_absorption</strong><a class="paramlink headerlink reference internal" href="#utils.fit_lines_in_vector.params.no_absorption">¶</a> &#8211; (Optional) If True, no negative amplitude
are returned (default False).</li>
<li><span class="target" id="utils.fit_lines_in_vector.params.poly_order"></span><strong>poly_order</strong><a class="paramlink headerlink reference internal" href="#utils.fit_lines_in_vector.params.poly_order">¶</a> &#8211; (Optional) Order of the polynomial used to fit
continuum. Use high orders carefully (default 0).</li>
<li><span class="target" id="utils.fit_lines_in_vector.params.fmodel"></span><strong>fmodel</strong><a class="paramlink headerlink reference internal" href="#utils.fit_lines_in_vector.params.fmodel">¶</a> &#8211; (Optional) Fitting model. Can be &#8216;gaussian&#8217;, 
&#8216;sinc&#8217; or &#8216;sinc2&#8217; (default &#8216;gaussian&#8217;).</li>
<li><span class="target" id="utils.fit_lines_in_vector.params.sig_noise"></span><strong>sig_noise</strong><a class="paramlink headerlink reference internal" href="#utils.fit_lines_in_vector.params.sig_noise">¶</a> &#8211; (Optional) Noise standard deviation guess. If
None noise value is guessed but the gaussian FWHM must not
exceed half of the sampling interval (default None).</li>
<li><span class="target" id="utils.fit_lines_in_vector.params.observation_params"></span><strong>observation_params</strong><a class="paramlink headerlink reference internal" href="#utils.fit_lines_in_vector.params.observation_params">¶</a> &#8211; (Optional) Must be a tuple [step,
order]. Interpolate data before fitting when data has been
previously interpolated from an irregular wavelength axis to a
regular one.</li>
<li><span class="target" id="utils.fit_lines_in_vector.params.signal_range"></span><strong>signal_range</strong><a class="paramlink headerlink reference internal" href="#utils.fit_lines_in_vector.params.signal_range">¶</a> &#8211; (Optional) A tuple (x_min, x_max) giving the
lowest and highest channel numbers containing signal.</li>
<li><span class="target" id="utils.fit_lines_in_vector.params.wavenumber"></span><strong>wavenumber</strong><a class="paramlink headerlink reference internal" href="#utils.fit_lines_in_vector.params.wavenumber">¶</a> &#8211; (Optional) If True the spectrum is considered
to be in wavenumber. It will not be interpolated but the
observation params will be used to compute the real line
shift. If False, and if the observation params are given the
spectrum will be interpolated to a regular wavenumber scale (The
shape of the lines becomes symetric) (default False).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>a dictionary containing:</p>
<ul class="simple">
<li>lines parameters [key: &#8216;lines-params&#8217;] Lines parameters are
given as an array of shape (lines_nb, 4). The order of the 4
parameters for each lines is [height at the center of the
line, ampitude, position, fwhm].</li>
<li>lines parameters errors [key: &#8216;lines-params-err&#8217;]</li>
<li>residual [key: &#8216;residual&#8217;]</li>
<li>chi-square [key: &#8216;chi-square&#8217;]</li>
<li>reduced chi-square [key: &#8216;reduced-chi-square&#8217;]</li>
<li>SNR [key: &#8216;snr&#8217;]</li>
<li>continuum parameters [key: &#8216;cont-params&#8217;]</li>
<li>and optionally the fitted vector [key: &#8216;fitted-vector&#8217;]
depending on the option return_fitted_vector.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.fit_map">
<code class="descclassname">utils.</code><code class="descname">fit_map</code><span class="sig-paren">(</span><em>data_map</em>, <em>err_map</em>, <em>smooth_deg</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.fit_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit map with low order polynomials</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="utils.fit_map.params.data_map"></span><strong>data_map</strong><a class="paramlink headerlink reference internal" href="#utils.fit_map.params.data_map">¶</a> &#8211; data map</li>
<li><span class="target" id="utils.fit_map.params.err_map"></span><strong>err_map</strong><a class="paramlink headerlink reference internal" href="#utils.fit_map.params.err_map">¶</a> &#8211; error map</li>
<li><span class="target" id="utils.fit_map.params.smooth_deg"></span><strong>smooth_deg</strong><a class="paramlink headerlink reference internal" href="#utils.fit_map.params.smooth_deg">¶</a> &#8211; Degree of fit smoothing (beware of high
smoothing degrees)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(fitted data map, error map, fit error)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.flambda2ABmag">
<code class="descclassname">utils.</code><code class="descname">flambda2ABmag</code><span class="sig-paren">(</span><em>flambda</em>, <em>lam</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.flambda2ABmag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return AB magnitude from flux in erg/cm2/s/A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.flambda2ABmag.params.flambda"></span><strong>flambda</strong><a class="paramlink headerlink reference internal" href="#utils.flambda2ABmag.params.flambda">¶</a> &#8211; Flux in erg/cm2/s/A. Can be an array.</li>
<li><span class="target" id="utils.flambda2ABmag.params.lambda"></span><strong>lambda</strong><a class="paramlink headerlink reference internal" href="#utils.flambda2ABmag.params.lambda">¶</a> &#8211; Wavelength in A of the Flux. If flambda is an array
lambda must have the same shape.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.fnu2flambda">
<code class="descclassname">utils.</code><code class="descname">fnu2flambda</code><span class="sig-paren">(</span><em>fnu</em>, <em>nu</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.fnu2flambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a flux in erg/cm2/s/Hz to a flux in erg/cm2/s/A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.fnu2flambda.params.fnu"></span><strong>fnu</strong><a class="paramlink headerlink reference internal" href="#utils.fnu2flambda.params.fnu">¶</a> &#8211; Flux in erg/cm2/s/Hz</li>
<li><span class="target" id="utils.fnu2flambda.params.nu"></span><strong>nu</strong><a class="paramlink headerlink reference internal" href="#utils.fnu2flambda.params.nu">¶</a> &#8211; frequency in Hz</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.fwhm_cm12nm">
<code class="descclassname">utils.</code><code class="descname">fwhm_cm12nm</code><span class="sig-paren">(</span><em>fwhm_cm1</em>, <em>cm1</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.fwhm_cm12nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a FWHM in cm-1 to a FWHM in nm.</p>
<p>The central wavelength in cm-1 of the line must also be given</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.fwhm_cm12nm.params.fwhm_cm1"></span><strong>fwhm_cm1</strong><a class="paramlink headerlink reference internal" href="#utils.fwhm_cm12nm.params.fwhm_cm1">¶</a> &#8211; FWHM in cm-1</li>
<li><span class="target" id="utils.fwhm_cm12nm.params.cm1"></span><strong>cm1</strong><a class="paramlink headerlink reference internal" href="#utils.fwhm_cm12nm.params.cm1">¶</a> &#8211; Wavelength in cm-1 where the FWHM is evaluated</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.fwhm_nm2cm1">
<code class="descclassname">utils.</code><code class="descname">fwhm_nm2cm1</code><span class="sig-paren">(</span><em>fwhm_nm</em>, <em>nm</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.fwhm_nm2cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a FWHM in nm to a FWHM in cm-1.</p>
<p>The central wavelength in nm of the line must also be given</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.fwhm_nm2cm1.params.fwhm_nm"></span><strong>fwhm_nm</strong><a class="paramlink headerlink reference internal" href="#utils.fwhm_nm2cm1.params.fwhm_nm">¶</a> &#8211; FWHM in nm</li>
<li><span class="target" id="utils.fwhm_nm2cm1.params.nm"></span><strong>nm</strong><a class="paramlink headerlink reference internal" href="#utils.fwhm_nm2cm1.params.nm">¶</a> &#8211; Wavelength in nm where the FWHM is evaluated</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.gaussian1d">
<code class="descclassname">utils.</code><code class="descname">gaussian1d</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.gaussian1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D gaussian given a set of parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.gaussian1d.params.x"></span><strong>x</strong><a class="paramlink headerlink reference internal" href="#utils.gaussian1d.params.x">¶</a> &#8211; Array giving the positions where the gaussian is evaluated</li>
<li><span class="target" id="utils.gaussian1d.params.h"></span><strong>h</strong><a class="paramlink headerlink reference internal" href="#utils.gaussian1d.params.h">¶</a> &#8211; Height</li>
<li><span class="target" id="utils.gaussian1d.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#utils.gaussian1d.params.a">¶</a> &#8211; Amplitude</li>
<li><span class="target" id="utils.gaussian1d.params.dx"></span><strong>dx</strong><a class="paramlink headerlink reference internal" href="#utils.gaussian1d.params.dx">¶</a> &#8211; Position of the center</li>
<li><span class="target" id="utils.gaussian1d.params.w"></span><strong>w</strong><a class="paramlink headerlink reference internal" href="#utils.gaussian1d.params.w">¶</a> &#8211; FWHM, <span class="math">\(\text{FWHM} = \text{Width} \times 2 \sqrt{2 \ln 2}\)</span></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.get_axis_from_hdr">
<code class="descclassname">utils.</code><code class="descname">get_axis_from_hdr</code><span class="sig-paren">(</span><em>hdr</em>, <em>axis_index=1</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.get_axis_from_hdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return axis from a classic FITS header</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.get_axis_from_hdr.params.hdr"></span><strong>hdr</strong><a class="paramlink headerlink reference internal" href="#utils.get_axis_from_hdr.params.hdr">¶</a> &#8211; FITS header</li>
<li><span class="target" id="utils.get_axis_from_hdr.params.axis_index"></span><strong>axis_index</strong><a class="paramlink headerlink reference internal" href="#utils.get_axis_from_hdr.params.axis_index">¶</a> &#8211; (Optional) Index of the axis to retrieve
(default 1)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.get_box_coords">
<code class="descclassname">utils.</code><code class="descname">get_box_coords</code><span class="sig-paren">(</span><em>ix</em>, <em>iy</em>, <em>box_size</em>, <em>x_lim_min</em>, <em>x_lim_max</em>, <em>y_lim_min</em>, <em>y_lim_max</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.get_box_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coordinates of a box given the center of the box,
its size and the limits of the range along x and y axes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="utils.get_box_coords.params.ix"></span><strong>ix</strong><a class="paramlink headerlink reference internal" href="#utils.get_box_coords.params.ix">¶</a> &#8211; center of the box along x axis</li>
<li><span class="target" id="utils.get_box_coords.params.iy"></span><strong>iy</strong><a class="paramlink headerlink reference internal" href="#utils.get_box_coords.params.iy">¶</a> &#8211; center of the box along y axis</li>
<li><span class="target" id="utils.get_box_coords.params.box_size"></span><strong>box_size</strong><a class="paramlink headerlink reference internal" href="#utils.get_box_coords.params.box_size">¶</a> &#8211; Size of the box. The final size of the box will
generally be the same if box_size is odd. Note that the final
size of the box cannot be guaranteed.</li>
<li><span class="target" id="utils.get_box_coords.params.x_lim_min"></span><strong>x_lim_min</strong><a class="paramlink headerlink reference internal" href="#utils.get_box_coords.params.x_lim_min">¶</a> &#8211; Minimum limit of the range along x.</li>
<li><span class="target" id="utils.get_box_coords.params.x_lim_max"></span><strong>x_lim_max</strong><a class="paramlink headerlink reference internal" href="#utils.get_box_coords.params.x_lim_max">¶</a> &#8211; Maximum limit of the range along x.</li>
<li><span class="target" id="utils.get_box_coords.params.y_lim_min"></span><strong>y_lim_min</strong><a class="paramlink headerlink reference internal" href="#utils.get_box_coords.params.y_lim_min">¶</a> &#8211; Minimum limit of the range along y.</li>
<li><span class="target" id="utils.get_box_coords.params.y_lim_max"></span><strong>y_lim_max</strong><a class="paramlink headerlink reference internal" href="#utils.get_box_coords.params.y_lim_max">¶</a> &#8211; Maximum limit of the range along y.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">x_min, x_max, y_min, y_max</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.get_filter_edges_pix">
<code class="descclassname">utils.</code><code class="descname">get_filter_edges_pix</code><span class="sig-paren">(</span><em>filter_file_path</em>, <em>correction_factor</em>, <em>step</em>, <em>order</em>, <em>n</em>, <em>filter_min=None</em>, <em>filter_max=None</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.get_filter_edges_pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the position in pixels of the edges of a filter
corrected for the off-axis effect.</p>
<p>Note that the axis is assumed to be in wavenumber. Spectra are
generally given in wavelength but phase vectors are not. So this
function is best used with phase vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.get_filter_edges_pix.params.filter_file_path"></span><strong>filter_file_path</strong><a class="paramlink headerlink reference internal" href="#utils.get_filter_edges_pix.params.filter_file_path">¶</a> &#8211; Path to the filter file. If None,
filter_min and filter_max must be specified.</li>
<li><span class="target" id="utils.get_filter_edges_pix.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#utils.get_filter_edges_pix.params.step">¶</a> &#8211; Step size of the moving mirror in nm.</li>
<li><span class="target" id="utils.get_filter_edges_pix.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#utils.get_filter_edges_pix.params.order">¶</a> &#8211; Folding order.</li>
<li><span class="target" id="utils.get_filter_edges_pix.params.correction_factor"></span><strong>correction_factor</strong><a class="paramlink headerlink reference internal" href="#utils.get_filter_edges_pix.params.correction_factor">¶</a> &#8211; Correction factor
(i.e. calibration_map_value / laser_wavelength)</li>
<li><span class="target" id="utils.get_filter_edges_pix.params.n"></span><strong>n</strong><a class="paramlink headerlink reference internal" href="#utils.get_filter_edges_pix.params.n">¶</a> &#8211; Number of points of the interpolation axis.</li>
<li><span class="target" id="utils.get_filter_edges_pix.params.filter_min"></span><strong>filter_min</strong><a class="paramlink headerlink reference internal" href="#utils.get_filter_edges_pix.params.filter_min">¶</a> &#8211; (Optional) Edge min of the filter in nm
(default None).</li>
<li><span class="target" id="utils.get_filter_edges_pix.params.filter_max"></span><strong>filter_max</strong><a class="paramlink headerlink reference internal" href="#utils.get_filter_edges_pix.params.filter_max">¶</a> &#8211; (Optional) Edge max of the filter in nm
(default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#utils.read_filter_file" title="utils.read_filter_file"><code class="xref py py-meth docutils literal"><span class="pre">utils.read_filter_file()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.get_filter_function">
<code class="descclassname">utils.</code><code class="descname">get_filter_function</code><span class="sig-paren">(</span><em>filter_file_path</em>, <em>step</em>, <em>order</em>, <em>n</em>, <em>wavenumber=False</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.get_filter_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a filter file and return its function interpolated over
the desired number of points. Return also the edges position over
its axis in pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="utils.get_filter_function.params.filter_file_path"></span><strong>filter_file_path</strong><a class="paramlink headerlink reference internal" href="#utils.get_filter_function.params.filter_file_path">¶</a> &#8211; Path to the filter file.</li>
<li><span class="target" id="utils.get_filter_function.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#utils.get_filter_function.params.step">¶</a> &#8211; Step size of the moving mirror in nm.</li>
<li><span class="target" id="utils.get_filter_function.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#utils.get_filter_function.params.order">¶</a> &#8211; Folding order.</li>
<li><span class="target" id="utils.get_filter_function.params.n"></span><strong>n</strong><a class="paramlink headerlink reference internal" href="#utils.get_filter_function.params.n">¶</a> &#8211; Number of points of the interpolation axis.</li>
<li><span class="target" id="utils.get_filter_function.params.wavenumber"></span><strong>wavenumber</strong><a class="paramlink headerlink reference internal" href="#utils.get_filter_function.params.wavenumber">¶</a> &#8211; (Optional) If True the function is interpolated
and returned along a wavenumber axis. If False it is returned
along a wavelength axis (default False).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(interpolated filter function, min edge, max edge). Min
and max edges are given in pixels over the interpolation axis.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#utils.read_filter_file" title="utils.read_filter_file"><code class="xref py py-meth docutils literal"><span class="pre">utils.read_filter_file()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.get_lr_phase">
<code class="descclassname">utils.</code><code class="descname">get_lr_phase</code><span class="sig-paren">(</span><em>interf</em>, <em>n_phase=None</em>, <em>return_lr_spectrum=False</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.get_lr_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a low resolution phase from a given interferogram vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.get_lr_phase.params.interf"></span><strong>interf</strong><a class="paramlink headerlink reference internal" href="#utils.get_lr_phase.params.interf">¶</a> &#8211; Interferogram vector</li>
<li><span class="target" id="utils.get_lr_phase.params.n_phase"></span><strong>n_phase</strong><a class="paramlink headerlink reference internal" href="#utils.get_lr_phase.params.n_phase">¶</a> &#8211; (Optional) Number of points for phase
computation. Of course it can be no greater than the number of
points of the interferogram. If None, this is set to 50% of the
interferogram length (Default None).</li>
<li><span class="target" id="utils.get_lr_phase.params.return_lr_spectrum"></span><strong>return_lr_spectrum</strong><a class="paramlink headerlink reference internal" href="#utils.get_lr_phase.params.return_lr_spectrum">¶</a> &#8211; (Optional) If True return also the low
resolution spectrum from which phase is computed (Default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.get_mask_from_ds9_region_file">
<code class="descclassname">utils.</code><code class="descname">get_mask_from_ds9_region_file</code><span class="sig-paren">(</span><em>reg_path</em>, <em>x_range=None</em>, <em>y_range=None</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.get_mask_from_ds9_region_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the elements inside &#8216;box&#8217;, &#8216;circle&#8217; and
&#8216;polygon&#8217; regions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.get_mask_from_ds9_region_file.params.reg_path"></span><strong>reg_path</strong><a class="paramlink headerlink reference internal" href="#utils.get_mask_from_ds9_region_file.params.reg_path">¶</a> &#8211; Path to a ds9 region file</li>
<li><span class="target" id="utils.get_mask_from_ds9_region_file.params.x_range"></span><strong>x_range</strong><a class="paramlink headerlink reference internal" href="#utils.get_mask_from_ds9_region_file.params.x_range">¶</a> &#8211; (Optional) Range of x image coordinates
considered as valid. Pixels outside this range are
rejected. If None, no validation is done (default None).</li>
<li><span class="target" id="utils.get_mask_from_ds9_region_file.params.y_range"></span><strong>y_range</strong><a class="paramlink headerlink reference internal" href="#utils.get_mask_from_ds9_region_file.params.y_range">¶</a> &#8211; (Optional) Range of y image coordinates
considered as valid. Pixels outside this range are
rejected. If None, no validation is done (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned array can be used like a list of
indices returned by e.g. numpy.nonzero().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Coordinates can be image coordinates (x,y) or sky
coordinates in degrees (ra, dec)</p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.get_mask_from_ds9_region_line">
<code class="descclassname">utils.</code><code class="descname">get_mask_from_ds9_region_line</code><span class="sig-paren">(</span><em>reg_line</em>, <em>x_range=None</em>, <em>y_range=None</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.get_mask_from_ds9_region_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Read one line of a ds9 region file and return the list of
pixels in the region.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.get_mask_from_ds9_region_line.params.reg_line"></span><strong>reg_line</strong><a class="paramlink headerlink reference internal" href="#utils.get_mask_from_ds9_region_line.params.reg_line">¶</a> &#8211; Line of the ds9 region file</li>
<li><span class="target" id="utils.get_mask_from_ds9_region_line.params.x_range"></span><strong>x_range</strong><a class="paramlink headerlink reference internal" href="#utils.get_mask_from_ds9_region_line.params.x_range">¶</a> &#8211; (Optional) Range of x image coordinates
considered as valid. Pixels outside this range are
rejected. If None, no validation is done (default None).</li>
<li><span class="target" id="utils.get_mask_from_ds9_region_line.params.y_range"></span><strong>y_range</strong><a class="paramlink headerlink reference internal" href="#utils.get_mask_from_ds9_region_line.params.y_range">¶</a> &#8211; (Optional) Range of y image coordinates
considered as valid. Pixels outside this range are
rejected. If None, no validation is done (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned array can be used like a list of
indices returned by e.g. numpy.nonzero().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Coordinates can be image coordinates (x,y) or sky
coordinates in degrees (ra, dec)</p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.get_open_fds">
<code class="descclassname">utils.</code><code class="descname">get_open_fds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#utils.get_open_fds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of open file descriptors</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Only works on UNIX-like OS</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is a useful debugging function that has been taken from: <a class="reference external" href="http://stackoverflow.com/questions/2023608/check-what-files-are-open-in-python">http://stackoverflow.com/questions/2023608/check-what-files-are-open-in-python</a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.high_pass_diff_image_filter">
<code class="descclassname">utils.</code><code class="descname">high_pass_diff_image_filter</code><span class="sig-paren">(</span><em>im</em>, <em>deg=1</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.high_pass_diff_image_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a high pass filtered image using the method of low pass
diffrence filtering given by Mighell (1999).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.high_pass_diff_image_filter.params.im"></span><strong>im</strong><a class="paramlink headerlink reference internal" href="#utils.high_pass_diff_image_filter.params.im">¶</a> &#8211; Image to filter</li>
<li><span class="target" id="utils.high_pass_diff_image_filter.params.deg"></span><strong>deg</strong><a class="paramlink headerlink reference internal" href="#utils.high_pass_diff_image_filter.params.deg">¶</a> &#8211; (Optional) Radius of the kernel of the low pass
filter. Must be &gt; 0 (default 2).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.high_pass_image_filter">
<code class="descclassname">utils.</code><code class="descname">high_pass_image_filter</code><span class="sig-paren">(</span><em>im</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.high_pass_image_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a high pass filtered image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="utils.high_pass_image_filter.params.im"></span><strong>im</strong><a class="paramlink headerlink reference internal" href="#utils.high_pass_image_filter.params.im">¶</a> &#8211; Image to filter</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.imag">
<code class="descclassname">utils.</code><code class="descname">imag</code><span class="sig-paren">(</span><em>amp</em>, <em>pha</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the imaginary part from amplitude and phase</p>
</dd></dl>

<dl class="function">
<dt id="utils.indft">
<code class="descclassname">utils.</code><code class="descname">indft</code><span class="sig-paren">(</span><em>a</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.indft" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse Non-uniform Discret Fourier Transform.</p>
<p>Compute the irregularly sampled interferogram from a regularly
sampled spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.indft.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#utils.indft.params.a">¶</a> &#8211; regularly sampled spectrum.</li>
<li><span class="target" id="utils.indft.params.x"></span><strong>x</strong><a class="paramlink headerlink reference internal" href="#utils.indft.params.x">¶</a> &#8211; positions of the interferogram samples. If x =
range(size(a)), this function is equivalent to an idft or a
ifft. Note that the ifft is of course much faster to
compute. This vector may have any length.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.interf_mean_energy">
<code class="descclassname">utils.</code><code class="descname">interf_mean_energy</code><span class="sig-paren">(</span><em>interf</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.interf_mean_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean energy of an interferogram by step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="utils.interf_mean_energy.params.interf"></span><strong>interf</strong><a class="paramlink headerlink reference internal" href="#utils.interf_mean_energy.params.interf">¶</a> &#8211; an interferogram</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The mean of the interferogram is substracted to
compute only the modulation energy. This is the modulation
energy which must be conserved in the resulting spectrum. Note
that the interferogram transformation function (see
<a class="reference internal" href="#utils.transform_interferogram" title="utils.transform_interferogram"><code class="xref py py-meth docutils literal"><span class="pre">utils.transform_interferogram()</span></code></a>) remove the mean of the
interferogram before computing its FFT.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">NaNs are set to 0.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.interpolate_axis">
<code class="descclassname">utils.</code><code class="descname">interpolate_axis</code><span class="sig-paren">(</span><em>a</em>, <em>new_axis</em>, <em>deg</em>, <em>old_axis=None</em>, <em>fill_value=nan</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.interpolate_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate a vector along a new axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.interpolate_axis.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#utils.interpolate_axis.params.a">¶</a> &#8211; vector to interpolate</li>
<li><span class="target" id="utils.interpolate_axis.params.new_axis"></span><strong>new_axis</strong><a class="paramlink headerlink reference internal" href="#utils.interpolate_axis.params.new_axis">¶</a> &#8211; Interpolation axis</li>
<li><span class="target" id="utils.interpolate_axis.params.deg"></span><strong>deg</strong><a class="paramlink headerlink reference internal" href="#utils.interpolate_axis.params.deg">¶</a> &#8211; Interpolation degree</li>
<li><span class="target" id="utils.interpolate_axis.params.old_axis"></span><strong>old_axis</strong><a class="paramlink headerlink reference internal" href="#utils.interpolate_axis.params.old_axis">¶</a> &#8211; (Optional) Original vector axis. If None,
a regular range axis is assumed (default None).</li>
<li><span class="target" id="utils.interpolate_axis.params.fill_value"></span><strong>fill_value</strong><a class="paramlink headerlink reference internal" href="#utils.interpolate_axis.params.fill_value">¶</a> &#8211; (Optional) extrapolated points are filled with
this value (default np.nan)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.interpolate_map">
<code class="descclassname">utils.</code><code class="descname">interpolate_map</code><span class="sig-paren">(</span><em>m</em>, <em>dimx</em>, <em>dimy</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.interpolate_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate 2D data map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.interpolate_map.params.m"></span><strong>m</strong><a class="paramlink headerlink reference internal" href="#utils.interpolate_map.params.m">¶</a> &#8211; Map</li>
<li><span class="target" id="utils.interpolate_map.params.dimx"></span><strong>dimx</strong><a class="paramlink headerlink reference internal" href="#utils.interpolate_map.params.dimx">¶</a> &#8211; X dimension of the result</li>
<li><span class="target" id="utils.interpolate_map.params.dimy"></span><strong>dimy</strong><a class="paramlink headerlink reference internal" href="#utils.interpolate_map.params.dimy">¶</a> &#8211; Y dimension of the result</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.interpolate_size">
<code class="descclassname">utils.</code><code class="descname">interpolate_size</code><span class="sig-paren">(</span><em>a</em>, <em>size</em>, <em>deg</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.interpolate_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Change size of a vector by interpolation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.interpolate_size.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#utils.interpolate_size.params.a">¶</a> &#8211; vector to interpolate</li>
<li><span class="target" id="utils.interpolate_size.params.size"></span><strong>size</strong><a class="paramlink headerlink reference internal" href="#utils.interpolate_size.params.size">¶</a> &#8211; New size of the vector</li>
<li><span class="target" id="utils.interpolate_size.params.deg"></span><strong>deg</strong><a class="paramlink headerlink reference internal" href="#utils.interpolate_size.params.deg">¶</a> &#8211; Interpolation degree</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.lambda2nu">
<code class="descclassname">utils.</code><code class="descname">lambda2nu</code><span class="sig-paren">(</span><em>lam</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.lambda2nu" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert lambda in Ang to nu in Hz</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="utils.lambda2nu.params.lam"></span><strong>lam</strong><a class="paramlink headerlink reference internal" href="#utils.lambda2nu.params.lam">¶</a> &#8211; Wavelength in angstrom</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.learner95_window">
<code class="descclassname">utils.</code><code class="descname">learner95_window</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.learner95_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the apodization function described in Learner et al.,
J. Opt. Soc. Am. A, 12, (1995).</p>
<p>This function is closely related to the minimum four-term
Blackman-Harris window.</p>
<p>Returned window is symmetrical.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="utils.learner95_window.params.n"></span><strong>n</strong><a class="paramlink headerlink reference internal" href="#utils.learner95_window.params.n">¶</a> &#8211; Number of points.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.line_shift">
<code class="descclassname">utils.</code><code class="descname">line_shift</code><span class="sig-paren">(</span><em>velocity</em>, <em>line</em>, <em>wavenumber=False</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.line_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the line shift given its velocity in nm or in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.line_shift.params.velocity"></span><strong>velocity</strong><a class="paramlink headerlink reference internal" href="#utils.line_shift.params.velocity">¶</a> &#8211; Line velocity in km.s-1</li>
<li><span class="target" id="utils.line_shift.params.line"></span><strong>line</strong><a class="paramlink headerlink reference internal" href="#utils.line_shift.params.line">¶</a> &#8211; Wavelength/wavenumber of the line. Must be in cm-1 if
wavenumber is True, must be in nm otherwise.</li>
<li><span class="target" id="utils.line_shift.params.wavenumber"></span><strong>wavenumber</strong><a class="paramlink headerlink reference internal" href="#utils.line_shift.params.wavenumber">¶</a> &#8211; (Optional) If True the result is returned in cm-1,
else it is returned in nm.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.low_pass_image_filter">
<code class="descclassname">utils.</code><code class="descname">low_pass_image_filter</code><span class="sig-paren">(</span><em>im</em>, <em>deg</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.low_pass_image_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a low pass filtered image using a gaussian kernel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.low_pass_image_filter.params.im"></span><strong>im</strong><a class="paramlink headerlink reference internal" href="#utils.low_pass_image_filter.params.im">¶</a> &#8211; Image to filter</li>
<li><span class="target" id="utils.low_pass_image_filter.params.deg"></span><strong>deg</strong><a class="paramlink headerlink reference internal" href="#utils.low_pass_image_filter.params.deg">¶</a> &#8211; Radius of the kernel. Must be &gt; 0.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.next_power_of_two">
<code class="descclassname">utils.</code><code class="descname">next_power_of_two</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.next_power_of_two" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the next power of two greater than n.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="utils.next_power_of_two.params.n"></span><strong>n</strong><a class="paramlink headerlink reference internal" href="#utils.next_power_of_two.params.n">¶</a> &#8211; The number from which the next power of two has to be
computed. Can be an array of numbers.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.nm2cm1">
<code class="descclassname">utils.</code><code class="descname">nm2cm1</code><span class="sig-paren">(</span><em>nm</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.nm2cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavelength in nm to a wavenumber in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="utils.nm2cm1.params.nm"></span><strong>nm</strong><a class="paramlink headerlink reference internal" href="#utils.nm2cm1.params.nm">¶</a> &#8211; wavelength i nm</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.nm2pix">
<code class="descclassname">utils.</code><code class="descname">nm2pix</code><span class="sig-paren">(</span><em>nm_axis</em>, <em>nm</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.nm2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavelength in nm to a pixel position given an axis
in nm</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.nm2pix.params.nm_axis"></span><strong>nm_axis</strong><a class="paramlink headerlink reference internal" href="#utils.nm2pix.params.nm_axis">¶</a> &#8211; Axis in nm</li>
<li><span class="target" id="utils.nm2pix.params.nm"></span><strong>nm</strong><a class="paramlink headerlink reference internal" href="#utils.nm2pix.params.nm">¶</a> &#8211; Wavelength in nm</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.norton_beer_window">
<code class="descclassname">utils.</code><code class="descname">norton_beer_window</code><span class="sig-paren">(</span><em>fwhm='1.6'</em>, <em>n=1000</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.norton_beer_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an extended Norton-Beer window function (see <a class="reference internal" href="#nay2007" id="id1">[NAY2007]</a>).</p>
<p>Returned window is symmetrical.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.norton_beer_window.params.fwhm"></span><strong>fwhm</strong><a class="paramlink headerlink reference internal" href="#utils.norton_beer_window.params.fwhm">¶</a> &#8211; FWHM relative to the sinc function. Must be: 1.1,
1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9 or 2.0. (default &#8216;1.6&#8217;)</li>
<li><span class="target" id="utils.norton_beer_window.params.n"></span><strong>n</strong><a class="paramlink headerlink reference internal" href="#utils.norton_beer_window.params.n">¶</a> &#8211; Number of points (default 1000)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Coefficients of the extended Norton-Beer functions
apodizing functions <a class="reference internal" href="#nay2007" id="id2">[NAY2007]</a> :</p>
<table border="1" class="last docutils">
<colgroup>
<col width="8%" />
<col width="15%" />
<col width="17%" />
<col width="15%" />
<col width="15%" />
<col width="15%" />
<col width="15%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>FWHM</td>
<td>C0</td>
<td>C1</td>
<td>C2</td>
<td>C4</td>
<td>C6</td>
<td>C8</td>
</tr>
<tr class="row-even"><td>1.1</td>
<td>0.701551</td>
<td>-0.639244</td>
<td>0.937693</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>1.2</td>
<td>0.396430</td>
<td>-0.150902</td>
<td>0.754472</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-even"><td>1.3</td>
<td>0.237413</td>
<td>-0.065285</td>
<td>0.827872</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>1.4</td>
<td>0.153945</td>
<td>-0.141765</td>
<td>0.987820</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-even"><td>1.5</td>
<td>0.077112</td>
<td>0.000000</td>
<td>0.703371</td>
<td>0.219517</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>1.6</td>
<td>0.039234</td>
<td>0.000000</td>
<td>0.630268</td>
<td>0.234934</td>
<td>0.095563</td>
<td>0.000000</td>
</tr>
<tr class="row-even"><td>1.7</td>
<td>0.020078</td>
<td>0.000000</td>
<td>0.480667</td>
<td>0.386409</td>
<td>0.112845</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>1.8</td>
<td>0.010172</td>
<td>0.000000</td>
<td>0.344429</td>
<td>0.451817</td>
<td>0.193580</td>
<td>0.000000</td>
</tr>
<tr class="row-even"><td>1.9</td>
<td>0.004773</td>
<td>0.000000</td>
<td>0.232473</td>
<td>0.464562</td>
<td>0.298191</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>2.0</td>
<td>0.002267</td>
<td>0.000000</td>
<td>0.140412</td>
<td>0.487172</td>
<td>0.256200</td>
<td>0.113948</td>
</tr>
</tbody>
</table>
</div>
<table class="docutils citation" frame="void" id="nay2007" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[NAY2007]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> Naylor, D. A., &amp; Tahic, M. K. (2007). Apodizing
functions for Fourier transform spectroscopy. Journal of the
Optical Society of America A.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.optimize_phase">
<code class="descclassname">utils.</code><code class="descname">optimize_phase</code><span class="sig-paren">(</span><em>interf</em>, <em>step</em>, <em>order</em>, <em>zpd_shift</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.optimize_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an optimized linear phase vector basez on the
minimization of the imaginary part.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.optimize_phase.params.interf"></span><strong>interf</strong><a class="paramlink headerlink reference internal" href="#utils.optimize_phase.params.interf">¶</a> &#8211; Interferogram</li>
<li><span class="target" id="utils.optimize_phase.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#utils.optimize_phase.params.step">¶</a> &#8211; Step size (in nm)</li>
<li><span class="target" id="utils.optimize_phase.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#utils.optimize_phase.params.order">¶</a> &#8211; Alisasing order</li>
<li><span class="target" id="utils.optimize_phase.params.zpd_shift"></span><strong>zpd_shift</strong><a class="paramlink headerlink reference internal" href="#utils.optimize_phase.params.zpd_shift">¶</a> &#8211; ZPD shift</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.phase">
<code class="descclassname">utils.</code><code class="descname">phase</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the phase of a complex number</p>
</dd></dl>

<dl class="function">
<dt id="utils.pix2cm1">
<code class="descclassname">utils.</code><code class="descname">pix2cm1</code><span class="sig-paren">(</span><em>cm1_axis</em>, <em>pix</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.pix2cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavenumber in cm-1 to a pixel position given an axis
in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.pix2cm1.params.cm1_axis"></span><strong>cm1_axis</strong><a class="paramlink headerlink reference internal" href="#utils.pix2cm1.params.cm1_axis">¶</a> &#8211; Axis in cm-1</li>
<li><span class="target" id="utils.pix2cm1.params.pix"></span><strong>pix</strong><a class="paramlink headerlink reference internal" href="#utils.pix2cm1.params.pix">¶</a> &#8211; Pixel position</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.pix2nm">
<code class="descclassname">utils.</code><code class="descname">pix2nm</code><span class="sig-paren">(</span><em>nm_axis</em>, <em>pix</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.pix2nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a pixel position to a wavelength in nm given an axis
in nm</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.pix2nm.params.nm_axis"></span><strong>nm_axis</strong><a class="paramlink headerlink reference internal" href="#utils.pix2nm.params.nm_axis">¶</a> &#8211; Axis in nm</li>
<li><span class="target" id="utils.pix2nm.params.pix"></span><strong>pix</strong><a class="paramlink headerlink reference internal" href="#utils.pix2nm.params.pix">¶</a> &#8211; Pixel position</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.polar_map2d">
<code class="descclassname">utils.</code><code class="descname">polar_map2d</code><span class="sig-paren">(</span><em>f</em>, <em>n</em>, <em>corner=False</em>, <em>circle=True</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.polar_map2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Map a function over a square matrix in polar coordinates. The
origin is placed at the center of the map by default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.polar_map2d.params.f"></span><strong>f</strong><a class="paramlink headerlink reference internal" href="#utils.polar_map2d.params.f">¶</a> &#8211; The function to map.</li>
<li><span class="target" id="utils.polar_map2d.params.n"></span><strong>n</strong><a class="paramlink headerlink reference internal" href="#utils.polar_map2d.params.n">¶</a> &#8211; Matrix size. Can be a couple of integers (nx, ny).</li>
<li><span class="target" id="utils.polar_map2d.params.corner"></span><strong>corner</strong><a class="paramlink headerlink reference internal" href="#utils.polar_map2d.params.corner">¶</a> &#8211; (Optional) If True, the origin of the coordinates
becomes the corner (0,0) of the map (default False)</li>
<li><span class="target" id="utils.polar_map2d.params.circle"></span><strong>circle</strong><a class="paramlink headerlink reference internal" href="#utils.polar_map2d.params.circle">¶</a> &#8211; (Optional) If False and if the matrix is not
squared, the coordinates are those of an ellipsis of the same
shape as the matrix (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.polyfit1d">
<code class="descclassname">utils.</code><code class="descname">polyfit1d</code><span class="sig-paren">(</span><em>a</em>, <em>deg</em>, <em>w=None</em>, <em>return_coeffs=False</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.polyfit1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a polynomial to a 1D vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.polyfit1d.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#utils.polyfit1d.params.a">¶</a> &#8211; Vector to fit</li>
<li><span class="target" id="utils.polyfit1d.params.deg"></span><strong>deg</strong><a class="paramlink headerlink reference internal" href="#utils.polyfit1d.params.deg">¶</a> &#8211; Fit degree</li>
<li><span class="target" id="utils.polyfit1d.params.return_coeffs"></span><strong>return_coeffs</strong><a class="paramlink headerlink reference internal" href="#utils.polyfit1d.params.return_coeffs">¶</a> &#8211; (Optional) If True return fit coefficients
as returned by numpy.polynomial.polynomial.polyfit() (default
False).</li>
<li><span class="target" id="utils.polyfit1d.params.w"></span><strong>w</strong><a class="paramlink headerlink reference internal" href="#utils.polyfit1d.params.w">¶</a> &#8211; (Optional) If not None, weights to apply to the
fit. Must have the same shape as the vector to fit (default
None)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.pp_create_master_frame">
<code class="descclassname">utils.</code><code class="descname">pp_create_master_frame</code><span class="sig-paren">(</span><em>frames</em>, <em>combine='average'</em>, <em>reject='avsigclip'</em>, <em>sigma=3.0</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.pp_create_master_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a parallelized version of <a class="reference internal" href="#utils.create_master_frame" title="utils.create_master_frame"><code class="xref py py-meth docutils literal"><span class="pre">utils.create_master_frame()</span></code></a>.</p>
<p>Use it only for big data set because it can be much slower for a
small data set (&lt; 500 x 500 x 10).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.pp_create_master_frame.params.frames"></span><strong>frames</strong><a class="paramlink headerlink reference internal" href="#utils.pp_create_master_frame.params.frames">¶</a> &#8211; Frames to combine.</li>
<li><span class="target" id="utils.pp_create_master_frame.params.reject"></span><strong>reject</strong><a class="paramlink headerlink reference internal" href="#utils.pp_create_master_frame.params.reject">¶</a> &#8211; (Optional) Rejection operation. Can be &#8216;sigclip&#8217;,
&#8216;minmax&#8217;, &#8216;avsigclip&#8217; (default &#8216;avsigclip&#8217;)</li>
<li><span class="target" id="utils.pp_create_master_frame.params.combine"></span><strong>combine</strong><a class="paramlink headerlink reference internal" href="#utils.pp_create_master_frame.params.combine">¶</a> &#8211; (Optional) Combining operation. Can be
&#8216;average&#8217; or &#8216;median&#8217; (default &#8216;average&#8217;)</li>
<li><span class="target" id="utils.pp_create_master_frame.params.sigma"></span><strong>sigma</strong><a class="paramlink headerlink reference internal" href="#utils.pp_create_master_frame.params.sigma">¶</a> &#8211; (Optional) Sigma factor for pixel rejection
(default 3.).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#utils.create_master_frame" title="utils.create_master_frame"><code class="xref py py-meth docutils literal"><span class="pre">utils.create_master_frame()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.query_sesame">
<code class="descclassname">utils.</code><code class="descname">query_sesame</code><span class="sig-paren">(</span><em>object_name</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.query_sesame" title="Permalink to this definition">¶</a></dt>
<dd><p>Query the SESAME Database to get RA/DEC given the name of an
object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="utils.query_sesame.params.object_name"></span><strong>object_name</strong><a class="paramlink headerlink reference internal" href="#utils.query_sesame.params.object_name">¶</a> &#8211; Name of the object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">[RA, DEC]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.raw_fft">
<code class="descclassname">utils.</code><code class="descname">raw_fft</code><span class="sig-paren">(</span><em>x</em>, <em>apod=None</em>, <em>inverse=False</em>, <em>return_complex=False</em>, <em>return_phase=False</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.raw_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the raw FFT of a vector.</p>
<p>Return the absolute value of the complex vector by default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.raw_fft.params.x"></span><strong>x</strong><a class="paramlink headerlink reference internal" href="#utils.raw_fft.params.x">¶</a> &#8211; Interferogram.</li>
<li><span class="target" id="utils.raw_fft.params.apod"></span><strong>apod</strong><a class="paramlink headerlink reference internal" href="#utils.raw_fft.params.apod">¶</a> &#8211; (Optional) Apodization function used. See
<a class="reference internal" href="#utils.norton_beer_window" title="utils.norton_beer_window"><code class="xref py py-meth docutils literal"><span class="pre">utils.norton_beer_window()</span></code></a> (default None)</li>
<li><span class="target" id="utils.raw_fft.params.inverse"></span><strong>inverse</strong><a class="paramlink headerlink reference internal" href="#utils.raw_fft.params.inverse">¶</a> &#8211; (Optional) If True compute the inverse FFT
(default False).</li>
<li><span class="target" id="utils.raw_fft.params.return_complex"></span><strong>return_complex</strong><a class="paramlink headerlink reference internal" href="#utils.raw_fft.params.return_complex">¶</a> &#8211; (Optional) If True, the complex vector is
returned (default False).</li>
<li><span class="target" id="utils.raw_fft.params.return_phase"></span><strong>return_phase</strong><a class="paramlink headerlink reference internal" href="#utils.raw_fft.params.return_phase">¶</a> &#8211; (Optional) If True, the phase is
returned.(default False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.read_filter_file">
<code class="descclassname">utils.</code><code class="descname">read_filter_file</code><span class="sig-paren">(</span><em>filter_file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.read_filter_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a file containing a the filter transmission function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="utils.read_filter_file.params.filter_file_path"></span><strong>filter_file_path</strong><a class="paramlink headerlink reference internal" href="#utils.read_filter_file.params.filter_file_path">¶</a> &#8211; Path to the filter file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">(list of filter wavelength, list of corresponding
transmission coefficients, minimum edge of the filter, maximum
edge of the filter) (Both min and max edges can be None if they
were not recorded in the file)</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The filter file used must have two colums separated by a
space character. The first column contains the wavelength axis
in nm. The second column contains the transmission
coefficients. Comments are preceded with a #.  Filter edges can
be specified using the keywords : FILTER_MIN and FILTER_MAX:</p>
<div class="last highlight-python"><div class="highlight"><pre>## ORBS filter file 
# Author: Thomas Martin &lt;thomas.martin.1@ulaval.ca&gt;
# Filter name : SpIOMM_R
# Wavelength in nm | Transmission percentage
# FILTER_MIN 648
# FILTER_MAX 678
1000 0.001201585284
999.7999878 0.009733387269
999.5999756 -0.0004460749624
999.4000244 0.01378122438
999.2000122 0.002538740868
</pre></div>
</div>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.real">
<code class="descclassname">utils.</code><code class="descname">real</code><span class="sig-paren">(</span><em>amp</em>, <em>pha</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.real" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real part from amplitude and phase</p>
</dd></dl>

<dl class="function">
<dt id="utils.restore_error_settings">
<code class="descclassname">utils.</code><code class="descname">restore_error_settings</code><span class="sig-paren">(</span><em>old_settings</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.restore_error_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore old floating point error settings of numpy.</p>
</dd></dl>

<dl class="function">
<dt id="utils.robust_mean">
<code class="descclassname">utils.</code><code class="descname">robust_mean</code><span class="sig-paren">(</span><em>a</em>, <em>weights=None</em>, <em>warn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.robust_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean of a distribution even with NaN values</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.robust_mean.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#utils.robust_mean.params.a">¶</a> &#8211; A distribution of values</li>
<li><span class="target" id="utils.robust_mean.params.weights"></span><strong>weights</strong><a class="paramlink headerlink reference internal" href="#utils.robust_mean.params.weights">¶</a> &#8211; Weights of each value of a (Must have the same
length as a). If None, weights are all considered equal to 1
(default None).</li>
<li><span class="target" id="utils.robust_mean.params.warn"></span><strong>warn</strong><a class="paramlink headerlink reference internal" href="#utils.robust_mean.params.warn">¶</a> &#8211; If True, warnings are raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.robust_median">
<code class="descclassname">utils.</code><code class="descname">robust_median</code><span class="sig-paren">(</span><em>a</em>, <em>warn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.robust_median" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median of a distribution (skip NaN values).</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.robust_median.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#utils.robust_median.params.a">¶</a> &#8211; A distribution of values</li>
<li><span class="target" id="utils.robust_median.params.warn"></span><strong>warn</strong><a class="paramlink headerlink reference internal" href="#utils.robust_median.params.warn">¶</a> &#8211; If True, warnings are raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.robust_std">
<code class="descclassname">utils.</code><code class="descname">robust_std</code><span class="sig-paren">(</span><em>a</em>, <em>warn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.robust_std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the std of a distribution even with NaN values</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.robust_std.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#utils.robust_std.params.a">¶</a> &#8211; A distribution of values</li>
<li><span class="target" id="utils.robust_std.params.warn"></span><strong>warn</strong><a class="paramlink headerlink reference internal" href="#utils.robust_std.params.warn">¶</a> &#8211; If True, warnings are raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.robust_sum">
<code class="descclassname">utils.</code><code class="descname">robust_sum</code><span class="sig-paren">(</span><em>a</em>, <em>warn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.robust_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sum of a distribution (skip NaN values)</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.robust_sum.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#utils.robust_sum.params.a">¶</a> &#8211; A distribution of values</li>
<li><span class="target" id="utils.robust_sum.params.warn"></span><strong>warn</strong><a class="paramlink headerlink reference internal" href="#utils.robust_sum.params.warn">¶</a> &#8211; If True, warnings are raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.shift_frame">
<code class="descclassname">utils.</code><code class="descname">shift_frame</code><span class="sig-paren">(</span><em>frame</em>, <em>dx</em>, <em>dy</em>, <em>x_min</em>, <em>x_max</em>, <em>y_min</em>, <em>y_max</em>, <em>order</em>, <em>fill_value=nan</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.shift_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shifted frame wit the same dimensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.shift_frame.params.frame"></span><strong>frame</strong><a class="paramlink headerlink reference internal" href="#utils.shift_frame.params.frame">¶</a> &#8211; Two dimensions array to be shifted</li>
<li><span class="target" id="utils.shift_frame.params.dx"></span><strong>dx</strong><a class="paramlink headerlink reference internal" href="#utils.shift_frame.params.dx">¶</a> &#8211; Shift value along the axis 0</li>
<li><span class="target" id="utils.shift_frame.params.dy"></span><strong>dy</strong><a class="paramlink headerlink reference internal" href="#utils.shift_frame.params.dy">¶</a> &#8211; Shift value along the axis 1</li>
<li><span class="target" id="utils.shift_frame.params.x_max, y_min, y_max"></span><strong>x_max, y_min, y_max</strong><a class="paramlink headerlink reference internal" href="#utils.shift_frame.params.x_max, y_min, y_max">¶</a> (<em>x_min,</em>) &#8211; Boundaries of the region to be
shifted.</li>
<li><span class="target" id="utils.shift_frame.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#utils.shift_frame.params.order">¶</a> &#8211; interpolation order.</li>
<li><span class="target" id="utils.shift_frame.params.(Optional)"></span><strong>(Optional)</strong><a class="paramlink headerlink reference internal" href="#utils.shift_frame.params.(Optional)">¶</a> (<em>fill_value</em>) &#8211; Value of the extrapolated points
(default np.nan).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To avoid spline interpolation defects around
stars use order 1 (linear interpolation).</p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.sigmacut">
<code class="descclassname">utils.</code><code class="descname">sigmacut</code><span class="sig-paren">(</span><em>x</em>, <em>sigma=3.0</em>, <em>min_values=3</em>, <em>central_value=None</em>, <em>warn=False</em>, <em>return_index_list=False</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.sigmacut" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a distribution after a sigma cut rejection
of the too deviant values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.sigmacut.params.x"></span><strong>x</strong><a class="paramlink headerlink reference internal" href="#utils.sigmacut.params.x">¶</a> &#8211; The distribution to cut</li>
<li><span class="target" id="utils.sigmacut.params.sigma"></span><strong>sigma</strong><a class="paramlink headerlink reference internal" href="#utils.sigmacut.params.sigma">¶</a> &#8211; (Optional) Number of sigma above which values are
considered as deviant (default 3.)</li>
<li><span class="target" id="utils.sigmacut.params.min_values"></span><strong>min_values</strong><a class="paramlink headerlink reference internal" href="#utils.sigmacut.params.min_values">¶</a> &#8211; (Optional) Minimum number of values to return
(default 3)</li>
<li><span class="target" id="utils.sigmacut.params.central_value"></span><strong>central_value</strong><a class="paramlink headerlink reference internal" href="#utils.sigmacut.params.central_value">¶</a> &#8211; (Optional) If not none, this value is used as
the central value of the cut. Else the median of the
distribution is used as the central value (default None)</li>
<li><span class="target" id="utils.sigmacut.params.warn"></span><strong>warn</strong><a class="paramlink headerlink reference internal" href="#utils.sigmacut.params.warn">¶</a> &#8211; (Optional) If False no warning message is printed
(default False).</li>
<li><span class="target" id="utils.sigmacut.params.return_index_list"></span><strong>return_index_list</strong><a class="paramlink headerlink reference internal" href="#utils.sigmacut.params.return_index_list">¶</a> &#8211; (Optional) If True the list of the non
rejected values is returned also (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.sinc1d">
<code class="descclassname">utils.</code><code class="descname">sinc1d</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.sinc1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D sinc 
:param _sphinx_paramlinks_utils.sinc1d.x: Array giving the positions where the function is evaluated
:param _sphinx_paramlinks_utils.sinc1d.h: Height
:param _sphinx_paramlinks_utils.sinc1d.a: Amplitude
:param _sphinx_paramlinks_utils.sinc1d.dx: Position of the center
:param _sphinx_paramlinks_utils.sinc1d.w: FWHM</p>
</dd></dl>

<dl class="function">
<dt id="utils.sip_im2pix">
<code class="descclassname">utils.</code><code class="descname">sip_im2pix</code><span class="sig-paren">(</span><em>im_coords</em>, <em>sip</em>, <em>tolerance=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.sip_im2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform perfect pixel positions to distorded pixels positions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.sip_im2pix.params.im_coords"></span><strong>im_coords</strong><a class="paramlink headerlink reference internal" href="#utils.sip_im2pix.params.im_coords">¶</a> &#8211; perfect pixel positions as an Nx2 array of floats.</li>
<li><span class="target" id="utils.sip_im2pix.params.sip"></span><strong>sip</strong><a class="paramlink headerlink reference internal" href="#utils.sip_im2pix.params.sip">¶</a> &#8211; pywcs.WCS() instance containing SIP parameters.</li>
<li><span class="target" id="utils.sip_im2pix.params.tolerance"></span><strong>tolerance</strong><a class="paramlink headerlink reference internal" href="#utils.sip_im2pix.params.tolerance">¶</a> &#8211; tolerance on the iterative method.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.sip_pix2im">
<code class="descclassname">utils.</code><code class="descname">sip_pix2im</code><span class="sig-paren">(</span><em>pix_coords</em>, <em>sip</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.sip_pix2im" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform distorded pixel positions to perfect pixels positions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.sip_pix2im.params.pix_coords"></span><strong>pix_coords</strong><a class="paramlink headerlink reference internal" href="#utils.sip_pix2im.params.pix_coords">¶</a> &#8211; distorded pixel positions as an Nx2 array of floats.</li>
<li><span class="target" id="utils.sip_pix2im.params.sip"></span><strong>sip</strong><a class="paramlink headerlink reference internal" href="#utils.sip_pix2im.params.sip">¶</a> &#8211; pywcs.WCS() instance containing SIP parameters.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.smooth">
<code class="descclassname">utils.</code><code class="descname">smooth</code><span class="sig-paren">(</span><em>a</em>, <em>deg=2</em>, <em>kind='gaussian'</em>, <em>keep_sides=True</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth a given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="utils.smooth.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#utils.smooth.params.a">¶</a> &#8211; Vector to smooth</li>
<li><span class="target" id="utils.smooth.params.deg"></span><strong>deg</strong><a class="paramlink headerlink reference internal" href="#utils.smooth.params.deg">¶</a> &#8211; (Optional) Smoothing degree (or kernel
radius) Must be an integer (default 2).</li>
<li><span class="target" id="utils.smooth.params.kind"></span><strong>kind</strong><a class="paramlink headerlink reference internal" href="#utils.smooth.params.kind">¶</a> &#8211; Kind of smoothing function. &#8216;median&#8217; or &#8216;mean&#8217; are
self-explanatory. &#8216;gaussian&#8217; uses a gaussian function for a
weighted average. &#8216;gaussian_conv&#8217; and &#8216;cos_conv&#8217; make use of
convolution with a gaussian kernel or a cosine
kernel. Convolution is much faster but less rigorous on the
edges of the vector (default &#8216;gaussian&#8217;).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Params keep_sides:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">If True, the vector is seen as keeping its
side values above its real boudaries (If False, the values
outside the vector are 0. and this creates an undesirable border
effect when convolving).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.spectrum_mean_energy">
<code class="descclassname">utils.</code><code class="descname">spectrum_mean_energy</code><span class="sig-paren">(</span><em>spectrum</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.spectrum_mean_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean energy of a spectrum by channel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="utils.spectrum_mean_energy.params.spectrum"></span><strong>spectrum</strong><a class="paramlink headerlink reference internal" href="#utils.spectrum_mean_energy.params.spectrum">¶</a> &#8211; a 1D spectrum</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.transform_frame">
<code class="descclassname">utils.</code><code class="descname">transform_frame</code><span class="sig-paren">(</span><em>frame</em>, <em>x_min</em>, <em>x_max</em>, <em>y_min</em>, <em>y_max</em>, <em>d</em>, <em>rc</em>, <em>zoom_factor</em>, <em>interp_order</em>, <em>mask=None</em>, <em>fill_value=nan</em>, <em>sip_A=None</em>, <em>sip_B=None</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.transform_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform one frame or a part of it using transformation
coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.transform_frame.params.frame"></span><strong>frame</strong><a class="paramlink headerlink reference internal" href="#utils.transform_frame.params.frame">¶</a> &#8211; Frame to transform</li>
<li><span class="target" id="utils.transform_frame.params.x_min"></span><strong>x_min</strong><a class="paramlink headerlink reference internal" href="#utils.transform_frame.params.x_min">¶</a> &#8211; Lower x boundary of the frame to transform</li>
<li><span class="target" id="utils.transform_frame.params.x_max"></span><strong>x_max</strong><a class="paramlink headerlink reference internal" href="#utils.transform_frame.params.x_max">¶</a> &#8211; Upper x boundary of the frame to transform</li>
<li><span class="target" id="utils.transform_frame.params.y_min"></span><strong>y_min</strong><a class="paramlink headerlink reference internal" href="#utils.transform_frame.params.y_min">¶</a> &#8211; Lower y boundary of the frame to transform</li>
<li><span class="target" id="utils.transform_frame.params.y_max"></span><strong>y_max</strong><a class="paramlink headerlink reference internal" href="#utils.transform_frame.params.y_max">¶</a> &#8211; Upper y boundary of the frame to transform</li>
<li><span class="target" id="utils.transform_frame.params.d"></span><strong>d</strong><a class="paramlink headerlink reference internal" href="#utils.transform_frame.params.d">¶</a> &#8211; Transformation coefficients [dx, dy, dr, da, db]</li>
<li><span class="target" id="utils.transform_frame.params.rc"></span><strong>rc</strong><a class="paramlink headerlink reference internal" href="#utils.transform_frame.params.rc">¶</a> &#8211; Rotation center of the frame [rc_x, rc_y]</li>
<li><span class="target" id="utils.transform_frame.params.zoom_factor"></span><strong>zoom_factor</strong><a class="paramlink headerlink reference internal" href="#utils.transform_frame.params.zoom_factor">¶</a> &#8211; Zoom on the image. Can be a couple (zx, zy).</li>
<li><span class="target" id="utils.transform_frame.params.interp_order"></span><strong>interp_order</strong><a class="paramlink headerlink reference internal" href="#utils.transform_frame.params.interp_order">¶</a> &#8211; Interpolation order</li>
<li><span class="target" id="utils.transform_frame.params.mask"></span><strong>mask</strong><a class="paramlink headerlink reference internal" href="#utils.transform_frame.params.mask">¶</a> &#8211; (Optional) If a mask frame is passed it is
transformed also (default None).</li>
<li><span class="target" id="utils.transform_frame.params.fill_value"></span><strong>fill_value</strong><a class="paramlink headerlink reference internal" href="#utils.transform_frame.params.fill_value">¶</a> &#8211; (Optional) Fill value for extrapolated points
(default np.nan).</li>
<li><span class="target" id="utils.transform_frame.params.sip_A"></span><strong>sip_A</strong><a class="paramlink headerlink reference internal" href="#utils.transform_frame.params.sip_A">¶</a> &#8211; (Optional) pywcs.WCS() instance containing SIP parameters of
the output image (default None).</li>
<li><span class="target" id="utils.transform_frame.params.sip_B"></span><strong>sip_B</strong><a class="paramlink headerlink reference internal" href="#utils.transform_frame.params.sip_B">¶</a> &#8211; (Optional) pywcs.WCS() instance containing SIP parameters of
the input image (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.transform_interferogram">
<code class="descclassname">utils.</code><code class="descname">transform_interferogram</code><span class="sig-paren">(</span><em>interf</em>, <em>nm_laser</em>, <em>calibration_coeff</em>, <em>step</em>, <em>order</em>, <em>window_type</em>, <em>zpd_shift</em>, <em>n_phase=None</em>, <em>return_phase=False</em>, <em>ext_phase=None</em>, <em>weights=None</em>, <em>polyfit_deg=1</em>, <em>balanced=True</em>, <em>bad_frames_vector=None</em>, <em>smoothing_deg=2</em>, <em>return_complex=False</em>, <em>final_step_nb=None</em>, <em>wavenumber=False</em>, <em>low_order_correction=False</em>, <em>conserve_energy=False</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.transform_interferogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform an interferogram into a spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.transform_interferogram.params.interf"></span><strong>interf</strong><a class="paramlink headerlink reference internal" href="#utils.transform_interferogram.params.interf">¶</a> &#8211; Interferogram to transform.</li>
<li><span class="target" id="utils.transform_interferogram.params.nm_laser"></span><strong>nm_laser</strong><a class="paramlink headerlink reference internal" href="#utils.transform_interferogram.params.nm_laser">¶</a> &#8211; Wavelength of the laser used for calibration.</li>
<li><span class="target" id="utils.transform_interferogram.params.calibration_coeff"></span><strong>calibration_coeff</strong><a class="paramlink headerlink reference internal" href="#utils.transform_interferogram.params.calibration_coeff">¶</a> &#8211; Wavelength of the laser emission line
corresponding to the computed interferogram.</li>
<li><span class="target" id="utils.transform_interferogram.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#utils.transform_interferogram.params.step">¶</a> &#8211; Step size of the moving mirror in nm.</li>
<li><span class="target" id="utils.transform_interferogram.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#utils.transform_interferogram.params.order">¶</a> &#8211; Folding order (if 0 the result cannot be projected
on an axis in nm, i.e. wavenumber option is automatically set to
True).</li>
<li><span class="target" id="utils.transform_interferogram.params.window_type"></span><strong>window_type</strong><a class="paramlink headerlink reference internal" href="#utils.transform_interferogram.params.window_type">¶</a> &#8211; Name of the apodization function.</li>
<li><span class="target" id="utils.transform_interferogram.params.zpd_shift"></span><strong>zpd_shift</strong><a class="paramlink headerlink reference internal" href="#utils.transform_interferogram.params.zpd_shift">¶</a> &#8211; Shift of the interferogram to center the ZPD.</li>
<li><span class="target" id="utils.transform_interferogram.params.bad_frames_vector"></span><strong>bad_frames_vector</strong><a class="paramlink headerlink reference internal" href="#utils.transform_interferogram.params.bad_frames_vector">¶</a> &#8211; (Optional) Mask-like vector containing
ones for bad frames. Bad frames are replaced by zeros using a
special function that smoothes transition between good parts and
zeros (default None). This vector must be uncorrected for ZPD
shift</li>
<li><span class="target" id="utils.transform_interferogram.params.n_phase"></span><strong>n_phase</strong><a class="paramlink headerlink reference internal" href="#utils.transform_interferogram.params.n_phase">¶</a> &#8211; (Optional) Number of points to use for phase
correction. It can be no greater than interferogram length. If
0, no phase correction will be done and the resulting spectrum
will be the absolute value of the complex spectrum. If None, the
number of points is set to 20 percent of the interferogram
length (default None).</li>
<li><span class="target" id="utils.transform_interferogram.params.ext_phase"></span><strong>ext_phase</strong><a class="paramlink headerlink reference internal" href="#utils.transform_interferogram.params.ext_phase">¶</a> &#8211; (Optional) External phase vector. If given this
phase vector is used instead of a low-resolution one. It must be
as long as the interferogram.</li>
<li><span class="target" id="utils.transform_interferogram.params.return_phase"></span><strong>return_phase</strong><a class="paramlink headerlink reference internal" href="#utils.transform_interferogram.params.return_phase">¶</a> &#8211; (Optional) If True, compute only the phase of
the interferogram and return it. If polyfit_deg is &gt;= 0, return
the coefficients of the fitted phase (default False). Note that
this option is not compatible with ext_phase. You must set
ext_phase to None to set return_phase to True.</li>
<li><span class="target" id="utils.transform_interferogram.params.weights"></span><strong>weights</strong><a class="paramlink headerlink reference internal" href="#utils.transform_interferogram.params.weights">¶</a> &#8211; (Optional) A vector of the same length as the
number of points used to compute the phase (n_phase) giving the
weight of each point for interpolation (Must be a float between
0. and 1.). If none is given, the weights are defined by the
amplitude of the vector.</li>
<li><span class="target" id="utils.transform_interferogram.params.polyfit_deg"></span><strong>polyfit_deg</strong><a class="paramlink headerlink reference internal" href="#utils.transform_interferogram.params.polyfit_deg">¶</a> &#8211; (Optional) Degree of the polynomial fit to the
computed phase. If &lt; 0, no fit will be performed (Default 1).</li>
<li><span class="target" id="utils.transform_interferogram.params.smoothing_deg"></span><strong>smoothing_deg</strong><a class="paramlink headerlink reference internal" href="#utils.transform_interferogram.params.smoothing_deg">¶</a> &#8211; (Optional) Degree of zeros smoothing. A
higher degree means a smoother transition from zeros parts (bad
frames) to non-zero parts (good frames) of the
interferogram. Good parts on the other side of the ZPD in
symmetry with zeros parts are multiplied by 2. The same
transition is used to multiply interferogram points by zero and
2 (default 2). This operation is not done if smoothing_deg is
set to 0.</li>
<li><span class="target" id="utils.transform_interferogram.params.balanced"></span><strong>balanced</strong><a class="paramlink headerlink reference internal" href="#utils.transform_interferogram.params.balanced">¶</a> &#8211; (Optional) If False, the interferogram is
considered as unbalanced. It is flipped before its
transformation to get a positive spectrum. Note
that a merged interferogram is balanced (default True).</li>
<li><span class="target" id="utils.transform_interferogram.params.return_complex"></span><strong>return_complex</strong><a class="paramlink headerlink reference internal" href="#utils.transform_interferogram.params.return_complex">¶</a> &#8211; (Optional) If True and if phase is
corrected the returned spectrum will be complex. In False only
the real part is returned (default False)</li>
<li><span class="target" id="utils.transform_interferogram.params.final_step_nb"></span><strong>final_step_nb</strong><a class="paramlink headerlink reference internal" href="#utils.transform_interferogram.params.final_step_nb">¶</a> &#8211; (Optional) Number of samples of the
resulting spectrum. If None, the number of samples of the
spectrum will be the same as the interferogram (default None).</li>
<li><span class="target" id="utils.transform_interferogram.params.wavenumber"></span><strong>wavenumber</strong><a class="paramlink headerlink reference internal" href="#utils.transform_interferogram.params.wavenumber">¶</a> &#8211; (Optional) If True, the returned spectrum is
projected onto its original wavenumber axis (emission lines and
especially unapodized sinc emission lines are thus symetric
which is not the case if the spectrum is projected onto a, more
convenient, regular wavelength axis) (default False).</li>
<li><span class="target" id="utils.transform_interferogram.params.low_order_correction"></span><strong>low_order_correction</strong><a class="paramlink headerlink reference internal" href="#utils.transform_interferogram.params.low_order_correction">¶</a> &#8211; (Optional) If True substract a low
order polynomial to remove low frequency noise. Useful for
unperfectly corrected interferograms (default False).</li>
<li><span class="target" id="utils.transform_interferogram.params.conserve_energy"></span><strong>conserve_energy</strong><a class="paramlink headerlink reference internal" href="#utils.transform_interferogram.params.conserve_energy">¶</a> &#8211; (Optional) If True the energy is conserved
in the transformation (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Interferogram can be complex</p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.transform_spectrum">
<code class="descclassname">utils.</code><code class="descname">transform_spectrum</code><span class="sig-paren">(</span><em>spectrum</em>, <em>nm_laser</em>, <em>calibration_coeff</em>, <em>step</em>, <em>order</em>, <em>window_type</em>, <em>zpd_shift</em>, <em>ext_phase=None</em>, <em>return_complex=False</em>, <em>wavenumber=False</em>, <em>final_step_nb=None</em>, <em>sampling_vector=None</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.transform_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform a spectrum into an interferogram.</p>
<p>This function is the inverse of <a class="reference internal" href="#utils.transform_interferogram" title="utils.transform_interferogram"><code class="xref py py-meth docutils literal"><span class="pre">utils.transform_interferogram()</span></code></a>.</p>
<p>So that to get the initial interferogram, the same options used in
transform interferogram must be passed to this function. The
spectrum must also be the complex form (use return_complex option
in <a class="reference internal" href="#utils.transform_interferogram" title="utils.transform_interferogram"><code class="xref py py-meth docutils literal"><span class="pre">utils.transform_interferogram()</span></code></a>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="utils.transform_spectrum.params.spectrum"></span><strong>spectrum</strong><a class="paramlink headerlink reference internal" href="#utils.transform_spectrum.params.spectrum">¶</a> &#8211; Spectrum to transform</li>
<li><span class="target" id="utils.transform_spectrum.params.nm_laser"></span><strong>nm_laser</strong><a class="paramlink headerlink reference internal" href="#utils.transform_spectrum.params.nm_laser">¶</a> &#8211; Wavelength of the laser used for calibration.</li>
<li><span class="target" id="utils.transform_spectrum.params.calibration_coeff"></span><strong>calibration_coeff</strong><a class="paramlink headerlink reference internal" href="#utils.transform_spectrum.params.calibration_coeff">¶</a> &#8211; Wavelength of the laser emission line
corresponding to the computed interferogram.</li>
<li><span class="target" id="utils.transform_spectrum.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#utils.transform_spectrum.params.step">¶</a> &#8211; Step size of the moving mirror in nm.</li>
<li><span class="target" id="utils.transform_spectrum.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#utils.transform_spectrum.params.order">¶</a> &#8211; Folding order (can be 0 but the input must be in
wavenumber).</li>
<li><span class="target" id="utils.transform_spectrum.params.window_type"></span><strong>window_type</strong><a class="paramlink headerlink reference internal" href="#utils.transform_spectrum.params.window_type">¶</a> &#8211; Name of the apodization function.</li>
<li><span class="target" id="utils.transform_spectrum.params.zpd_shift"></span><strong>zpd_shift</strong><a class="paramlink headerlink reference internal" href="#utils.transform_spectrum.params.zpd_shift">¶</a> &#8211; Shift of the interferogram to decenter the ZPD.</li>
<li><span class="target" id="utils.transform_spectrum.params.ext_phase"></span><strong>ext_phase</strong><a class="paramlink headerlink reference internal" href="#utils.transform_spectrum.params.ext_phase">¶</a> &#8211; (Optional) External phase vector. If given this
phase vector is used in place of the original phase of the
spectrum. Useful to add a phase to an interferogram. Note that
this phase is intended to be used to inverse transform an
already transformed interferogram. The computed phase correction
can thus be used directly. As the phase vector given by
<a class="reference internal" href="#utils.transform_interferogram" title="utils.transform_interferogram"><code class="xref py py-meth docutils literal"><span class="pre">utils.transform_interferogram()</span></code></a> is not reversed for
even orders, it is reversed here in this function.</li>
<li><span class="target" id="utils.transform_spectrum.params.return_complex"></span><strong>return_complex</strong><a class="paramlink headerlink reference internal" href="#utils.transform_spectrum.params.return_complex">¶</a> &#8211; (Optional) If True return a complex
interferogram. Else return the real part of it (default False).</li>
<li><span class="target" id="utils.transform_spectrum.params.wavenumber"></span><strong>wavenumber</strong><a class="paramlink headerlink reference internal" href="#utils.transform_spectrum.params.wavenumber">¶</a> &#8211; (Optional) If True the spectrum axis is in
cm-1. In this case, and if no wavelength correction has to be
applied (calibration_coeff == nm_laser) there will be no
interpolation of the original spectrum (better precision)
(default False).</li>
<li><span class="target" id="utils.transform_spectrum.params.final_step_nb"></span><strong>final_step_nb</strong><a class="paramlink headerlink reference internal" href="#utils.transform_spectrum.params.final_step_nb">¶</a> &#8211; (Optional) Final size of the
interferogram. Must be less than the size of the original
spectrum. If None the final size of the interferogram is the
same as the size of the original spectrum (default None).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Sampling_vector:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">(Optional) If the samples of the interferogram
are not uniformly distributed, a vector giving the positions of
the samples can be passed. In this case an inverse NDFT is
computed which may be really slow for long vectors. A uniformly
sampled vector would be range(final_step_nb). The size of the
vector must be equal to final_step_nb (default None).</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Interferogram can be complex</p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.transform_star_position_A_to_B">
<code class="descclassname">utils.</code><code class="descname">transform_star_position_A_to_B</code><span class="sig-paren">(</span><em>star_list_A</em>, <em>params</em>, <em>rc</em>, <em>zoom_factor</em>, <em>sip_A=None</em>, <em>sip_B=None</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.transform_star_position_A_to_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform star positions in camera A to the positions in camera
B given the transformation parameters.</p>
<p>Optionally SIP distorsion parameters can be given.</p>
<p>The transformation steps are:</p>
<div class="highlight-python"><div class="highlight"><pre>dist_pix_camA -&gt; perf_pix_camA -&gt; geometric transformation_A2B
-&gt; perf_pix_camB -&gt; dist_pix_camB
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="utils.transform_star_position_A_to_B.params.star_list_A"></span><strong>star_list_A</strong><a class="paramlink headerlink reference internal" href="#utils.transform_star_position_A_to_B.params.star_list_A">¶</a> &#8211; List of star coordinates in the cube A.</li>
<li><span class="target" id="utils.transform_star_position_A_to_B.params.params"></span><strong>params</strong><a class="paramlink headerlink reference internal" href="#utils.transform_star_position_A_to_B.params.params">¶</a> &#8211; Transformation parameters [dx, dy, dr, da, db].</li>
<li><span class="target" id="utils.transform_star_position_A_to_B.params.rc"></span><strong>rc</strong><a class="paramlink headerlink reference internal" href="#utils.transform_star_position_A_to_B.params.rc">¶</a> &#8211; Rotation center coordinates.</li>
<li><span class="target" id="utils.transform_star_position_A_to_B.params.zoom_factor"></span><strong>zoom_factor</strong><a class="paramlink headerlink reference internal" href="#utils.transform_star_position_A_to_B.params.zoom_factor">¶</a> &#8211; Zooming factor between the two cameras. Can be
a couple (zx, zy).</li>
<li><span class="target" id="utils.transform_star_position_A_to_B.params.sip_A"></span><strong>sip_A</strong><a class="paramlink headerlink reference internal" href="#utils.transform_star_position_A_to_B.params.sip_A">¶</a> &#8211; (Optional) pywcs.WCS instance containing SIP
parameters of the frame A (default None).</li>
<li><span class="target" id="utils.transform_star_position_A_to_B.params.sip_B"></span><strong>sip_B</strong><a class="paramlink headerlink reference internal" href="#utils.transform_star_position_A_to_B.params.sip_B">¶</a> &#8211; (Optional) pywcs.WCS instance containing SIP
parameters of the frame B (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.variable_me">
<code class="descclassname">utils.</code><code class="descname">variable_me</code><span class="sig-paren">(</span><em>n</em>, <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#utils.variable_me" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sinusoidal function representing a variable
modulation efficiency.</p>
<p>This function is used to correct for fringes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="utils.variable_me.params.params"></span><strong>params</strong><a class="paramlink headerlink reference internal" href="#utils.variable_me.params.params">¶</a> &#8211; A tuple of floats [frequency, amplitude,
phase]. The frequency gives the number of repetition of a sinus
over the vector. The amplitude must be between 0. (returns a
vector of 1) and 1. (returns a sinus going from 0 to 1). Phase
can be a single float or a vector of size n</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="cutils_module.html" class="btn btn-neutral float-right" title="CUtils module" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="core_module.html" class="btn btn-neutral" title="Core module" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Thomas Martin (thomas.martin.1@ulaval.ca).
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.4.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>