<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>orb.utils.image &#8212; orb 3.0.1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '3.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for orb.utils.image</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python</span>
<span class="c1"># *-* coding: utf-8 *-*</span>
<span class="c1"># Author: Thomas Martin &lt;thomas.martin.1@ulaval.ca&gt;</span>
<span class="c1"># File: image.py</span>

<span class="c1">## Copyright (c) 2010-2016 Thomas Martin &lt;thomas.martin.1@ulaval.ca&gt;</span>
<span class="c1">## </span>
<span class="c1">## This file is part of ORB</span>
<span class="c1">##</span>
<span class="c1">## ORB is free software: you can redistribute it and/or modify it</span>
<span class="c1">## under the terms of the GNU General Public License as published by</span>
<span class="c1">## the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1">## (at your option) any later version.</span>
<span class="c1">##</span>
<span class="c1">## ORB is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="c1">## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="c1">## or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public</span>
<span class="c1">## License for more details.</span>
<span class="c1">##</span>
<span class="c1">## You should have received a copy of the GNU General Public License</span>
<span class="c1">## along with ORB.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">interpolate</span><span class="p">,</span> <span class="n">optimize</span><span class="p">,</span> <span class="n">ndimage</span><span class="p">,</span> <span class="n">signal</span>
<span class="kn">import</span> <span class="nn">bottleneck</span> <span class="k">as</span> <span class="nn">bn</span>

<span class="kn">import</span> <span class="nn">orb.utils.stats</span>
<span class="kn">import</span> <span class="nn">orb.utils.vector</span>
<span class="kn">import</span> <span class="nn">orb.utils.parallel</span>
<span class="kn">import</span> <span class="nn">orb.utils.io</span>
<span class="kn">import</span> <span class="nn">orb.utils.fft</span>
<span class="kn">import</span> <span class="nn">orb.cutils</span>

<span class="kn">import</span> <span class="nn">orb.ext.zern</span>

<div class="viewcode-block" id="compute_binning"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.compute_binning">[docs]</a><span class="k">def</span> <span class="nf">compute_binning</span><span class="p">(</span><span class="n">image_shape</span><span class="p">,</span> <span class="n">detector_shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return binning along both axis given the image shape and the</span>
<span class="sd">    detector shape.</span>

<span class="sd">    :param image_size: Tuple [x,y] giving the image shape</span>
<span class="sd">    </span>
<span class="sd">    :param detector_shape: Tuple [x,y] giving the detector shape</span>
<span class="sd">      (i.e. maximum numbers of pixels along the x and y axis.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">binning</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">detector_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">image_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">binning</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span> <span class="k">return</span> <span class="n">binning</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Bad binning value (must be &gt; 0)&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="pp_create_master_frame"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.pp_create_master_frame">[docs]</a><span class="k">def</span> <span class="nf">pp_create_master_frame</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s1">&#39;average&#39;</span><span class="p">,</span> <span class="n">reject</span><span class="o">=</span><span class="s1">&#39;avsigclip&#39;</span><span class="p">,</span>
                           <span class="n">sigma</span><span class="o">=</span><span class="mf">3.</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run a parallelized version of :py:meth:`utils.create_master_frame`.</span>

<span class="sd">    Use it only for big data set because it can be much slower for a</span>
<span class="sd">    small data set (&lt; 500 x 500 x 10).</span>

<span class="sd">    :param frames: Frames to combine.</span>

<span class="sd">    :param reject: (Optional) Rejection operation. Can be &#39;sigclip&#39;,</span>
<span class="sd">      &#39;minmax&#39;, &#39;avsigclip&#39; (default &#39;avsigclip&#39;)</span>

<span class="sd">    :param combine: (Optional) Combining operation. Can be</span>
<span class="sd">      &#39;average&#39; or &#39;median&#39; (default &#39;average&#39;)</span>

<span class="sd">    :param sigma: (Optional) Sigma factor for pixel rejection</span>
<span class="sd">      (default 3.).</span>

<span class="sd">    .. seealso:: :py:meth:`utils.create_master_frame`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">job_server</span><span class="p">,</span> <span class="n">ncpus</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">parallel</span><span class="o">.</span><span class="n">init_pp_server</span><span class="p">()</span>
    <span class="n">divs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ncpus</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    
    <span class="n">frames</span> <span class="o">=</span> <span class="n">check_frames</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
    
    <span class="n">jobs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ijob</span><span class="p">,</span> <span class="n">job_server</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
        <span class="n">create_master_frame</span><span class="p">,</span> 
        <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">frames</span><span class="p">[</span><span class="n">divs</span><span class="p">[</span><span class="n">ijob</span><span class="p">]:</span><span class="n">divs</span><span class="p">[</span><span class="n">ijob</span><span class="o">+</span><span class="mi">1</span><span class="p">],:,:],</span>
              <span class="n">combine</span><span class="p">,</span> <span class="n">reject</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
        <span class="n">modules</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;import numpy as np&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;import orb.cutils as cutils&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;import orb.utils.stats&quot;</span><span class="p">,</span>
                 <span class="s2">&quot;import warnings&quot;</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">ijob</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncpus</span><span class="p">)]</span>
    
    <span class="k">for</span> <span class="n">ijob</span><span class="p">,</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
        <span class="n">result</span><span class="p">[</span><span class="n">divs</span><span class="p">[</span><span class="n">ijob</span><span class="p">]:</span><span class="n">divs</span><span class="p">[</span><span class="n">ijob</span><span class="o">+</span><span class="mi">1</span><span class="p">],:]</span> <span class="o">=</span> <span class="n">job</span><span class="p">()</span>
        
    <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">parallel</span><span class="o">.</span><span class="n">close_pp_server</span><span class="p">(</span><span class="n">job_server</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="check_frames"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.check_frames">[docs]</a><span class="k">def</span> <span class="nf">check_frames</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">sigma_reject</span><span class="o">=</span><span class="mf">2.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Check and reject deviating frames based on their median level.</span>

<span class="sd">    Frames with a too deviant median level are discarded. This</span>
<span class="sd">    function is used by :py:meth:`utils.create_master_frame`.</span>

<span class="sd">    :param frames: Set of frames to check</span>
<span class="sd">    </span>
<span class="sd">    :param sigma_reject: (Optional) Rejection coefficient (default 2.5)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">z_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">bn</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">frames</span><span class="p">[:,:,</span><span class="n">iframe</span><span class="p">])</span>
                         <span class="k">for</span> <span class="n">iframe</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])])</span>
    <span class="n">z_median_cut</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sigmacut</span><span class="p">(</span>
        <span class="n">z_median</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">sigma_reject</span><span class="p">)</span>
    <span class="n">bad_frames</span> <span class="o">=</span> <span class="p">(</span><span class="n">z_median</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">robust_median</span><span class="p">(</span><span class="n">z_median_cut</span><span class="p">)</span>
                         <span class="o">+</span> <span class="n">sigma_reject</span> <span class="o">*</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">robust_std</span><span class="p">(</span>
                                  <span class="n">z_median_cut</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">bad_frames</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Some frames (</span><span class="si">%d</span><span class="s1">) appear to be much different from the others. They have been removed before being combined. Please check the frames.&#39;</span><span class="o">%</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bad_frames</span><span class="p">))</span>
        <span class="nb">print</span> <span class="s1">&#39;Median levels: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">z_median</span><span class="p">)</span>
        <span class="nb">print</span> <span class="s1">&#39;Rejected: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="nb">str</span><span class="p">(</span><span class="n">bad_frames</span><span class="p">)</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">([</span><span class="n">frames</span><span class="p">[:,:,</span><span class="n">iframe</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">iframe</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">bad_frames</span><span class="p">[</span><span class="n">iframe</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">frames</span></div>
        

<div class="viewcode-block" id="create_master_frame"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.create_master_frame">[docs]</a><span class="k">def</span> <span class="nf">create_master_frame</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="s1">&#39;average&#39;</span><span class="p">,</span> <span class="n">reject</span><span class="o">=</span><span class="s1">&#39;avsigclip&#39;</span><span class="p">,</span>
                        <span class="n">sigma</span><span class="o">=</span><span class="mf">3.</span><span class="p">,</span> <span class="n">silent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a master frame from a set a frames.</span>

<span class="sd">    This method has been inspired by the **IRAF** function</span>
<span class="sd">    combine.</span>

<span class="sd">    :param frames: Frames to combine.</span>

<span class="sd">    :param reject: (Optional) Rejection operation. Can be &#39;sigclip&#39;,</span>
<span class="sd">      &#39;minmax&#39;, &#39;avsigclip&#39; (default &#39;avsigclip&#39;)</span>

<span class="sd">    :param combine: (Optional) Combining operation. Can be</span>
<span class="sd">      &#39;average&#39; or &#39;median&#39; (default &#39;average&#39;)</span>

<span class="sd">    :param sigma: (Optional) Sigma factor for pixel rejection</span>
<span class="sd">      (default 3.).</span>

<span class="sd">    :param silent: (Optional) If True no information message are</span>
<span class="sd">      displayed.</span>

<span class="sd">    :param check: (Optional) If True deviating frames are rejected</span>
<span class="sd">      before combination (default True).</span>

<span class="sd">    .. note:: Rejection operations:</span>

<span class="sd">      * **sigclip**: A Sigma Clipping algorithm is applied for</span>
<span class="sd">        each pixel. Min and max values are rejected to estimate</span>
<span class="sd">        the mean and the standard deviation at each pixel. Then</span>
<span class="sd">        all values over (median + sigma * std) or below (median -</span>
<span class="sd">        sigma * std) are rejected. Those steps are repeated (this</span>
<span class="sd">        time not excluding the extreme values) while no other</span>
<span class="sd">        value is rejected or the minimum number of values to keep</span>
<span class="sd">        is reached. Work best with at least 10 frames.</span>

<span class="sd">      * **avsigclip**: Average Sigma Clipping algorithm is the</span>
<span class="sd">        same as Sigma Clipping algorithm but the standard</span>
<span class="sd">        deviation at each pixel is estimated using an averaged</span>
<span class="sd">        value of the std over the lines. This work best than sigma</span>
<span class="sd">        clipping for a small number of frames. This algorithm is a</span>
<span class="sd">        little more time consuming than the others. Works best with</span>
<span class="sd">        at least 5 frames.</span>

<span class="sd">      * **minmax**: Minimum and maximum values at each pixel are</span>
<span class="sd">        rejected.</span>

<span class="sd">    .. warning:: No rejection operation can be performed with less</span>
<span class="sd">      than 3 frames.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
    
    <span class="n">NKEEP</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># Minimum number of values to keep for each pixel</span>

    <span class="n">frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># only one image</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span> <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Only one image to create a master frame. No combining method can be used.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">frames</span>

    <span class="k">if</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Only one image to create a master frame. No combining method can be used.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span> <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Not enough frames to use a rejection method (</span><span class="si">%d</span><span class="s2"> &lt; 3)&quot;</span><span class="o">%</span><span class="n">frames</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">combine</span> <span class="o">==</span> <span class="s1">&#39;average&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">frames</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">reject</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;sigclip&#39;</span><span class="p">,</span> <span class="s1">&#39;minmax&#39;</span><span class="p">,</span> <span class="s1">&#39;avsigclip&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Rejection operation must be &#39;sigclip&#39;, &#39;minmax&#39; or &#39;avsigclip&#39;&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">combine</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="s1">&#39;average&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Combining operation must be &#39;average&#39; or &#39;median&#39;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span> <span class="nb">print</span> <span class="s2">&quot;Rejection operation: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">reject</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span> <span class="nb">print</span> <span class="s2">&quot;Combining operation: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">combine</span>

    <span class="k">if</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;avsigclip&#39;</span><span class="p">:</span>
        <span class="n">reject_mode</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;sigclip&#39;</span><span class="p">:</span>
        <span class="n">reject_mode</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">reject</span> <span class="o">==</span> <span class="s1">&#39;minmax&#39;</span><span class="p">:</span>
        <span class="n">reject_mode</span> <span class="o">=</span> <span class="mi">2</span>
        
    <span class="k">if</span> <span class="n">combine</span> <span class="o">==</span> <span class="s1">&#39;average&#39;</span><span class="p">:</span>
        <span class="n">combine_mode</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">combine</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
        <span class="n">combine_mode</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">check</span><span class="p">:</span>
        <span class="n">frames</span> <span class="o">=</span> <span class="n">check_frames</span><span class="p">(</span><span class="n">frames</span><span class="p">)</span>
    
    <span class="n">master</span><span class="p">,</span> <span class="n">reject_count_frame</span><span class="p">,</span> <span class="n">std_frame</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">cutils</span><span class="o">.</span><span class="n">master_combine</span><span class="p">(</span>
        <span class="n">frames</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">NKEEP</span><span class="p">,</span> <span class="n">combine_mode</span><span class="p">,</span> <span class="n">reject_mode</span><span class="p">,</span> <span class="n">return_std_frame</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">reject</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;sigclip&#39;</span><span class="p">,</span> <span class="s1">&#39;avsigclip&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span> <span class="nb">print</span> <span class="s2">&quot;Maximum number of rejected pixels: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">reject_count_frame</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">silent</span><span class="p">:</span> <span class="nb">print</span> <span class="s2">&quot;Mean number of rejected pixels: </span><span class="si">%f</span><span class="s2">&quot;</span><span class="o">%</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">reject_count_frame</span><span class="p">)</span>

    <span class="nb">print</span> <span class="s2">&quot;median std of combined frames: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">robust_median</span><span class="p">(</span><span class="n">std_frame</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">master</span></div>


<div class="viewcode-block" id="get_box_coords"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.get_box_coords">[docs]</a><span class="k">def</span> <span class="nf">get_box_coords</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">box_size</span><span class="p">,</span>
                   <span class="n">x_lim_min</span><span class="p">,</span> <span class="n">x_lim_max</span><span class="p">,</span>
                   <span class="n">y_lim_min</span><span class="p">,</span> <span class="n">y_lim_max</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the coordinates of a box given the center of the box,</span>
<span class="sd">    its size and the limits of the range along x and y axes.</span>

<span class="sd">    :param ix: center of the box along x axis</span>
<span class="sd">    :param iy: center of the box along y axis</span>
<span class="sd">    </span>
<span class="sd">    :param box_size: Size of the box. The final size of the box will</span>
<span class="sd">      generally be the same if box_size is odd. Note that the final</span>
<span class="sd">      size of the box cannot be guaranteed.</span>

<span class="sd">    :param x_lim_min: Minimum limit of the range along x.</span>
<span class="sd">    :param x_lim_max: Maximum limit of the range along x.</span>
<span class="sd">    :param y_lim_min: Minimum limit of the range along y.</span>
<span class="sd">    :param y_lim_max: Maximum limit of the range along y.</span>

<span class="sd">    :return: x_min, x_max, y_min, y_max</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">orb</span><span class="o">.</span><span class="n">cutils</span><span class="o">.</span><span class="n">get_box_coords</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ix</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">iy</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">box_size</span><span class="p">),</span>
                                     <span class="nb">int</span><span class="p">(</span><span class="n">x_lim_min</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_lim_max</span><span class="p">),</span>
                                     <span class="nb">int</span><span class="p">(</span><span class="n">y_lim_min</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">y_lim_max</span><span class="p">))</span></div>


<div class="viewcode-block" id="correct_map2d"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.correct_map2d">[docs]</a><span class="k">def</span> <span class="nf">correct_map2d</span><span class="p">(</span><span class="n">map2d</span><span class="p">,</span> <span class="n">bad_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Correct a map of values by interpolation along columns.</span>

<span class="sd">    The bad value must be specified.</span>

<span class="sd">    :param map2d: The map to correct</span>
<span class="sd">    </span>
<span class="sd">    :param bad_value: (Optional) Value considered as bad (default</span>
<span class="sd">      np.nan).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">map2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">map2d</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">bad_value</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">:</span>
        <span class="n">map2d</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">map2d</span> <span class="o">==</span> <span class="n">bad_value</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">for</span> <span class="n">icol</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">map2d</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">column</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">map2d</span><span class="p">[:,</span><span class="n">icol</span><span class="p">])</span>
        <span class="n">good_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">column</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">bad_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">column</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">good_vals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">column</span><span class="p">):</span>
            <span class="n">interp</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">UnivariateSpline</span><span class="p">(</span>
                <span class="n">good_vals</span><span class="p">,</span> <span class="n">column</span><span class="p">[</span><span class="n">good_vals</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
            <span class="n">column</span><span class="p">[</span><span class="n">bad_vals</span><span class="p">]</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">bad_vals</span><span class="p">)</span>
            <span class="n">map2d</span><span class="p">[:,</span><span class="n">icol</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">map2d</span><span class="p">[:,</span><span class="n">icol</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
    <span class="k">return</span> <span class="n">map2d</span></div>

<div class="viewcode-block" id="polar_map2d"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.polar_map2d">[docs]</a><span class="k">def</span> <span class="nf">polar_map2d</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">corner</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">circle</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Map a function over a square matrix in polar coordinates. The</span>
<span class="sd">    origin is placed at the center of the map by default.</span>

<span class="sd">    :param f: The function to map.</span>

<span class="sd">    :param n: Matrix size. Can be a couple of integers (nx, ny).</span>

<span class="sd">    :param corner: (Optional) If True, the origin of the coordinates</span>
<span class="sd">      becomes the corner (0,0) of the map (default False)</span>

<span class="sd">    :param circle: (Optional) If False and if the matrix is not</span>
<span class="sd">      squared, the coordinates are those of an ellipsis of the same</span>
<span class="sd">      shape as the matrix (default True).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">n</span>
        <span class="n">ny</span> <span class="o">=</span> <span class="n">n</span>
    <span class="n">hdimx</span> <span class="o">=</span> <span class="n">nx</span><span class="o">/</span><span class="mf">2.</span> <span class="o">-</span> <span class="mf">0.5</span>
    <span class="n">hdimy</span> <span class="o">=</span> <span class="n">ny</span><span class="o">/</span><span class="mf">2.</span> <span class="o">-</span> <span class="mf">0.5</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">corner</span><span class="p">:</span>
        <span class="n">X</span><span class="p">,</span><span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="o">-</span><span class="n">hdimx</span><span class="p">:</span><span class="n">hdimx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">hdimy</span><span class="p">:</span><span class="n">hdimy</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">X</span><span class="p">,</span><span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">nx</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ny</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">circle</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">Y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">X</span><span class="o">/</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span><span class="o">/</span><span class="n">n</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">Y</span><span class="o">/</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span><span class="o">/</span><span class="n">n</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">R</span><span class="p">))</span></div>


<div class="viewcode-block" id="correct_hot_pixels"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.correct_hot_pixels">[docs]</a><span class="k">def</span> <span class="nf">correct_hot_pixels</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">hp_map</span><span class="p">,</span> <span class="n">box_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">std_filter_coeff</span><span class="o">=</span><span class="mf">1.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Correct hot pixels in an image given a map of their position.</span>

<span class="sd">    The algorithm used replaces a hot pixel value by the median of the</span>
<span class="sd">    pixels in a box around it. Pixels values which are not too much</span>
<span class="sd">    different from the values around are not modified.</span>

<span class="sd">    :param im: Image to correct</span>
<span class="sd">    </span>
<span class="sd">    :param hp_map: Hot pixels map (1 for hot pixels, 0 for normal</span>
<span class="sd">      pixel)</span>

<span class="sd">    :param box_size: (Optional) Size of the correction box (default</span>
<span class="sd">      3).</span>

<span class="sd">    :param std_filter_coeff: (Optional) Coefficient on the std used to</span>
<span class="sd">      check if the value of a hot pixel must be changed (default 1.5).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">im_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
    <span class="n">hp_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">hp_map</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hp_list</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span> <span class="o">=</span> <span class="n">hp_list</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">hp_list</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span> <span class="o">=</span> <span class="n">get_box_coords</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">box_size</span><span class="p">,</span>
                                    <span class="mi">0</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">im_temp</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span><span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">box</span> <span class="o">=</span> <span class="n">im_temp</span><span class="p">[</span><span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="p">,</span><span class="n">y_min</span><span class="p">:</span><span class="n">y_max</span><span class="p">]</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">robust_std</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>
        <span class="n">med</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">robust_median</span><span class="p">(</span><span class="n">box</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">im</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span><span class="n">iy</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">med</span> <span class="o">+</span> <span class="n">std_filter_coeff</span> <span class="o">*</span> <span class="n">std</span>
            <span class="ow">or</span> <span class="n">im</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span><span class="n">iy</span><span class="p">]</span> <span class="o">&lt;</span>  <span class="n">med</span> <span class="o">-</span> <span class="n">std_filter_coeff</span> <span class="o">*</span> <span class="n">std</span><span class="p">):</span>
            <span class="n">im</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span><span class="n">iy</span><span class="p">]</span> <span class="o">=</span> <span class="n">med</span>
    <span class="k">return</span> <span class="n">im</span></div>

<div class="viewcode-block" id="transform_frame"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.transform_frame">[docs]</a><span class="k">def</span> <span class="nf">transform_frame</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> 
                    <span class="n">d</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">zoom_factor</span><span class="p">,</span> <span class="n">interp_order</span><span class="p">,</span> 
                    <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
                    <span class="n">sip_A</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sip_B</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transform one frame or a part of it using transformation</span>
<span class="sd">    coefficients.</span>

<span class="sd">    :param frame: Frame to transform</span>
<span class="sd">    </span>
<span class="sd">    :param x_min: Lower x boundary of the transformed section (can be</span>
<span class="sd">      a tuple in order to get multiple sections)</span>
<span class="sd">    </span>
<span class="sd">    :param x_max: Upper x boundary of the transformed section (can be</span>
<span class="sd">      a tuple in order to get multiple sections)</span>
<span class="sd">    </span>
<span class="sd">    :param y_min: Lower y boundary of the transformed section (can be</span>
<span class="sd">      a tuple in order to get multiple sections)</span>
<span class="sd">    </span>
<span class="sd">    :param y_max: Upper y boundary of the transformed section (can be</span>
<span class="sd">      a tuple in order to get multiple sections)</span>
<span class="sd">    </span>
<span class="sd">    :param d: Transformation coefficients [dx, dy, dr, da, db]</span>
<span class="sd">    </span>
<span class="sd">    :param rc: Rotation center of the frame [rc_x, rc_y]</span>
<span class="sd">    </span>
<span class="sd">    :param zoom_factor: Zoom on the image. Can be a couple (zx, zy).</span>
<span class="sd">    </span>
<span class="sd">    :param interp_order: Interpolation order</span>
<span class="sd">    </span>
<span class="sd">    :param mask: (Optional) If a mask frame is passed it is</span>
<span class="sd">      transformed also (default None).</span>

<span class="sd">    :param fill_value: (Optional) Fill value for extrapolated points</span>
<span class="sd">      (default np.nan).</span>

<span class="sd">    :param sip_A: (Optional) pywcs.WCS() instance containing SIP parameters of</span>
<span class="sd">      the output image (default None).</span>
<span class="sd">      </span>
<span class="sd">    :param sip_B: (Optional) pywcs.WCS() instance containing SIP parameters of</span>
<span class="sd">      the input image (default None).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">mapping</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">transx</span><span class="p">,</span> <span class="n">transy</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">y_min</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x_min</span> <span class="o">+</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">transx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="ow">and</span> <span class="n">y_min</span> <span class="o">+</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">transx</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">transx</span><span class="p">[</span><span class="n">x_min</span> <span class="o">+</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                           <span class="n">y_min</span> <span class="o">+</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
                    <span class="n">transy</span><span class="p">[</span><span class="n">x_min</span> <span class="o">+</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                           <span class="n">y_min</span> <span class="o">+</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">zoom_factor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">zx</span> <span class="o">=</span> <span class="n">zoom_factor</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">zy</span> <span class="o">=</span> <span class="n">zoom_factor</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">zx</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">zoom_factor</span><span class="p">)</span>
        <span class="n">zy</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">zoom_factor</span><span class="p">)</span>
        
    <span class="c1">## create transform maps for mapping function</span>
    <span class="n">transx</span><span class="p">,</span> <span class="n">transy</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">cutils</span><span class="o">.</span><span class="n">create_transform_maps</span><span class="p">(</span>
        <span class="n">frame</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">frame</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">rc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">rc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">zx</span><span class="p">,</span> <span class="n">zy</span><span class="p">,</span> <span class="n">sip_A</span><span class="p">,</span> <span class="n">sip_B</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">frame</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">float</span><span class="p">):</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="n">x_min</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_min</span><span class="p">]</span>
        <span class="n">y_min</span> <span class="o">=</span> <span class="p">[</span><span class="n">y_min</span><span class="p">]</span>
        <span class="n">x_max</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_max</span><span class="p">]</span>
        <span class="n">y_max</span> <span class="o">=</span> <span class="p">[</span><span class="n">y_max</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x_min</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_max</span><span class="p">))</span>
            <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y_min</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_max</span><span class="p">))</span>
            <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_min</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_min</span><span class="p">))):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;x_min, y_min, x_max, y_max must have the same length&#39;</span><span class="p">)</span>
    <span class="n">sections</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">sections_mask</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_min</span><span class="p">)):</span>
        <span class="n">x_size</span> <span class="o">=</span> <span class="n">x_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">y_size</span> <span class="o">=</span> <span class="n">y_max</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">output_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_size</span><span class="p">,</span> <span class="n">y_size</span><span class="p">)</span> <span class="c1"># accelerate the process (unused</span>
                                        <span class="c1"># data points are not computed)</span>

        <span class="n">sections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">interpolation</span><span class="o">.</span><span class="n">geometric_transform</span><span class="p">(</span>
            <span class="n">frame</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">extra_arguments</span><span class="o">=</span><span class="p">(</span><span class="n">transx</span><span class="p">,</span> <span class="n">transy</span><span class="p">,</span>
                                             <span class="n">x_min</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y_min</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
            <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">,</span>
            <span class="n">order</span><span class="o">=</span><span class="n">interp_order</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">fill_value</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sections_mask</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">interpolation</span><span class="o">.</span><span class="n">geometric_transform</span><span class="p">(</span>
                <span class="n">mask</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">extra_arguments</span><span class="o">=</span><span class="p">(</span><span class="n">transx</span><span class="p">,</span> <span class="n">transy</span><span class="p">,</span>
                                                <span class="n">x_min</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y_min</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                <span class="n">output_shape</span><span class="o">=</span><span class="n">output_shape</span><span class="p">,</span>
                <span class="n">order</span><span class="o">=</span><span class="n">interp_order</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">fill_value</span><span class="p">))</span>
            

    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_min</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">sections</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sections_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sections</span><span class="p">,</span> <span class="n">sections_mask</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_min</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">sections</span></div>

<div class="viewcode-block" id="shift_frame"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.shift_frame">[docs]</a><span class="k">def</span> <span class="nf">shift_frame</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> 
                <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a shifted frame wit the same dimensions.</span>

<span class="sd">    :param frame: Two dimensions array to be shifted</span>
<span class="sd">    </span>
<span class="sd">    :param dx: Shift value along the axis 0</span>
<span class="sd">    </span>
<span class="sd">    :param dy: Shift value along the axis 1</span>

<span class="sd">    :param x_min, x_max, y_min, y_max: Boundaries of the region to be</span>
<span class="sd">      shifted.</span>

<span class="sd">    :param order: interpolation order.</span>

<span class="sd">    :param fill_value (Optional): Value of the extrapolated points</span>
<span class="sd">      (default np.nan).</span>

<span class="sd">    .. note:: To avoid spline interpolation defects around</span>
<span class="sd">       stars use order 1 (linear interpolation).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">frame</span><span class="p">[</span><span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">:</span><span class="n">y_max</span><span class="p">]</span>
    <span class="n">interp</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">interpolation</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="n">dx</span><span class="p">,</span> <span class="o">-</span><span class="n">dy</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> 
                                         <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">cval</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> 
                                         <span class="n">prefilter</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">interp</span></div>
        
<div class="viewcode-block" id="high_pass_image_filter"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.high_pass_image_filter">[docs]</a><span class="k">def</span> <span class="nf">high_pass_image_filter</span><span class="p">(</span><span class="n">im</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a high pass filtered image.</span>

<span class="sd">    :param im: Image to filter</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span>
              <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="mf">9.</span>
    <span class="k">return</span> <span class="n">signal</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="high_pass_diff_image_filter"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.high_pass_diff_image_filter">[docs]</a><span class="k">def</span> <span class="nf">high_pass_diff_image_filter</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a high pass filtered image using the method of low pass</span>
<span class="sd">    diffrence filtering given by Mighell (1999).</span>

<span class="sd">    :param im: Image to filter</span>

<span class="sd">    :param deg: (Optional) Radius of the kernel of the low pass</span>
<span class="sd">      filter. Must be &gt; 0 (default 1).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lp_im</span> <span class="o">=</span> <span class="n">low_pass_image_filter</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="n">deg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lp_im</span> <span class="o">-</span> <span class="n">scipy</span><span class="o">.</span><span class="n">ndimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">median_filter</span><span class="p">(</span><span class="n">lp_im</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">))</span></div>

<div class="viewcode-block" id="low_pass_image_filter"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.low_pass_image_filter">[docs]</a><span class="k">def</span> <span class="nf">low_pass_image_filter</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">deg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a low pass filtered image using a gaussian kernel.</span>
<span class="sd">    </span>
<span class="sd">    :param im: Image to filter</span>
<span class="sd">    </span>
<span class="sd">    :param deg: Radius of the kernel. Must be &gt; 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">deg</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Kernel degree must be &gt; 0&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">deg</span> <span class="o">&gt;=</span> <span class="nb">max</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Kernel degree is too high given the image size&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">orb</span><span class="o">.</span><span class="n">cutils</span><span class="o">.</span><span class="n">low_pass_image_filter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">im</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">deg</span><span class="p">))</span></div>

<div class="viewcode-block" id="fit_map_cos"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.fit_map_cos">[docs]</a><span class="k">def</span> <span class="nf">fit_map_cos</span><span class="p">(</span><span class="n">data_map</span><span class="p">,</span> <span class="n">err_map</span><span class="p">,</span> <span class="n">calib_map</span><span class="p">,</span> <span class="n">nm_laser</span><span class="p">,</span> <span class="n">knb</span><span class="o">=</span><span class="mi">15</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fit a map with a theta dependant value. The function f(theta)</span>
<span class="sd">    is a spline with a given number of knots.</span>

<span class="sd">    :param data_map: Data map</span>

<span class="sd">    :param err_map: Error map</span>

<span class="sd">    :param calib_map: Calibration laser map</span>

<span class="sd">    :param nm_laser: Calibration laser wavelength in nm</span>

<span class="sd">    :param knb: (Optional) Number of knots for the spline (default</span>
<span class="sd">      10).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">costheta</span> <span class="o">=</span> <span class="n">nm_laser</span> <span class="o">/</span> <span class="n">calib_map</span>
    <span class="n">err_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">err_map</span><span class="p">)</span>
    <span class="n">min_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">err_map</span><span class="p">,</span> <span class="mf">30.</span><span class="p">)</span> <span class="c1"># avoid &quot;too good&quot;</span>
                                                   <span class="c1"># points</span>
    <span class="n">err_map</span><span class="p">[</span><span class="n">err_map</span> <span class="o">&lt;=</span>  <span class="n">min_threshold</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_threshold</span>
    <span class="n">err_map</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">err_map</span><span class="p">,</span> <span class="mf">99.9</span><span class="p">)</span>
    <span class="n">err_map</span><span class="p">[</span><span class="n">err_map</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>
    
    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">costheta</span><span class="p">,</span> <span class="n">thetas</span><span class="p">):</span>
        <span class="n">spl</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">UnivariateSpline</span><span class="p">(</span><span class="n">thetas</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p</span><span class="p">),</span>
                                           <span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">spl</span><span class="p">(</span><span class="n">costheta</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">costheta</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">thetas</span><span class="p">):</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">model</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">costheta</span><span class="p">,</span> <span class="n">thetas</span><span class="p">)</span> <span class="o">-</span> <span class="n">data</span><span class="p">)</span> <span class="o">/</span> <span class="n">err</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">res</span><span class="p">)]</span>

    <span class="n">thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">costheta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">costheta</span><span class="p">),</span> <span class="n">knb</span><span class="p">)</span>
    <span class="n">guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">knb</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">guess</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">data_map</span><span class="p">))</span>
    <span class="n">fit</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span>
        <span class="n">diff</span><span class="p">,</span> <span class="n">guess</span><span class="p">,</span>
        <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">data_map</span><span class="p">,</span> <span class="n">costheta</span><span class="p">,</span> <span class="n">err_map</span><span class="p">,</span> <span class="n">thetas</span><span class="p">),</span>
        <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">data_map_fit</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">fit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">costheta</span><span class="p">,</span> <span class="n">thetas</span><span class="p">)</span>
    <span class="n">res_map</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_map</span> <span class="o">-</span> <span class="n">data_map_fit</span><span class="p">)</span>
    <span class="n">fit_error_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">res_map</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data_map</span><span class="p">)</span>
    <span class="n">fit_error_map</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">fit_error_map</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">fit_res_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">res_map</span><span class="p">)</span>
    <span class="n">fit_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">fit_error_map</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s1">&#39;Standard deviation of the residual: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fit_res_std</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s1">&#39;Median relative error (err/val)): </span><span class="si">{:.2f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">fit_error</span> <span class="o">*</span> <span class="mf">100.</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data_map_fit</span><span class="p">,</span> <span class="n">res_map</span><span class="p">,</span> <span class="n">fit_error</span></div>


<div class="viewcode-block" id="fit_map_zernike"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.fit_map_zernike">[docs]</a><span class="k">def</span> <span class="nf">fit_map_zernike</span><span class="p">(</span><span class="n">data_map</span><span class="p">,</span> <span class="n">weights_map</span><span class="p">,</span> <span class="n">nmodes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit a map with Zernike polynomials.</span>

<span class="sd">    Bad values must be set to NaN (not 0.)</span>

<span class="sd">    :param data_map: Data map to fit</span>

<span class="sd">    :param weights_map: weights map (high weight value stands for high</span>
<span class="sd">      precision data)</span>

<span class="sd">    :param nmodes: Number of zernike modes to use for fitting.</span>
<span class="sd">    </span>
<span class="sd">    :return: (fitted data map, error map, fit error)</span>
<span class="sd">    </span>
<span class="sd">    .. note:: Zernike polynomial fit routine has been written by Tim</span>
<span class="sd">      van Werkhoven (werkhoven@strw.leidenuniv.nl) as a part of</span>
<span class="sd">      libtim. It can be found in ORB module in ./ext/zern.py.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># bigger version used to fit corners</span>
    <span class="n">data_map_big</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">list</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_map</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)),</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">borders</span> <span class="o">=</span> <span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_map_big</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data_map</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">data_map_big</span><span class="p">[</span><span class="n">borders</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">borders</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">data_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                 <span class="n">borders</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">borders</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">data_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">data_map</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">data_map_big</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">weights_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">weights_map</span><span class="p">)</span>
    <span class="n">weights_map</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">weights_map</span><span class="p">)</span> <span class="c1"># error map is normalized</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">borders</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">borders</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">data_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
         <span class="n">borders</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">borders</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">data_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">weights_map</span>

    <span class="c1"># nans and 0s are masked</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data_map_big</span><span class="p">))]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">data_map_big</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.</span>
    
    <span class="c1"># nans are replaced by zeros in the fitted map</span>
    <span class="n">data_map_big</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">data_map_big</span><span class="p">))]</span> <span class="o">=</span> <span class="mf">0.</span> 
    <span class="p">(</span><span class="n">wf_zern_vec</span><span class="p">,</span> <span class="n">wf_zern_rec</span><span class="p">,</span> <span class="n">fitdiff</span><span class="p">)</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">ext</span><span class="o">.</span><span class="n">zern</span><span class="o">.</span><span class="n">fit_zernike</span><span class="p">(</span>
        <span class="n">data_map_big</span><span class="p">,</span> <span class="n">fitweight</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">startmode</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">nmodes</span><span class="o">=</span><span class="n">nmodes</span><span class="p">)</span>

    <span class="n">data_map_fit</span> <span class="o">=</span> <span class="n">wf_zern_rec</span><span class="p">[</span><span class="n">borders</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">borders</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">data_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                               <span class="n">borders</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">borders</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">data_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="n">res_map</span> <span class="o">=</span> <span class="n">data_map</span> <span class="o">-</span> <span class="n">data_map_fit</span>
    <span class="n">fit_error_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">res_map</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data_map</span><span class="p">)</span>
    <span class="n">fit_error_map</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">fit_error_map</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">fit_res_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">res_map</span><span class="p">)</span>
    <span class="n">fit_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">fit_error_map</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s1">&#39;Standard deviation of the residual: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fit_res_std</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s1">&#39;Median relative error (err/val)): </span><span class="si">{:.2f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">fit_error</span> <span class="o">*</span> <span class="mf">100.</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">data_map_fit</span><span class="p">,</span> <span class="n">res_map</span><span class="p">,</span> <span class="n">fit_error</span></div>

<div class="viewcode-block" id="fit_map"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.fit_map">[docs]</a><span class="k">def</span> <span class="nf">fit_map</span><span class="p">(</span><span class="n">data_map</span><span class="p">,</span> <span class="n">err_map</span><span class="p">,</span> <span class="n">smooth_deg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fit map with low order polynomials</span>

<span class="sd">    :param data_map: data map</span>

<span class="sd">    :param err_map: error map</span>

<span class="sd">    :param smooth_deg: Degree of fit smoothing (beware of high</span>
<span class="sd">      smoothing degrees)</span>

<span class="sd">    :return: a tuple: (fitted data map, residual map, fit RMS error)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">smooth_fit_parameters</span><span class="p">(</span><span class="n">coeffs_list</span><span class="p">,</span> <span class="n">err_list</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">smooth_deg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smooth the fitting parameters for a particular order of the</span>
<span class="sd">        polynomial fit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coeffs</span> <span class="o">=</span> <span class="n">coeffs_list</span><span class="p">[:,</span><span class="n">order</span><span class="p">]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">((</span><span class="mf">1.</span><span class="o">/</span><span class="n">err_list</span><span class="p">)</span><span class="o">**</span><span class="mf">2.</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">polyfit1d</span><span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="n">smooth_deg</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span>
                                          <span class="n">return_coeffs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="n">fit_coeffs</span><span class="p">,</span> <span class="n">coeffs_smooth_deg</span><span class="p">,</span> <span class="n">dimx</span><span class="p">,</span> <span class="n">dimy</span><span class="p">):</span>
        <span class="n">fit_coeffs</span> <span class="o">=</span> <span class="n">fit_coeffs</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">fit_coeffs</span><span class="p">)</span>
                                         <span class="o">/</span><span class="p">(</span><span class="n">coeffs_smooth_deg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                                         <span class="n">coeffs_smooth_deg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">fitted_data_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">dimx</span><span class="p">,</span> <span class="n">dimy</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">params_fit_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="c1"># compute coeffs </span>
        <span class="k">for</span> <span class="n">ideg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coeffs_smooth_deg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">params_fit_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimy</span><span class="p">),</span> <span class="n">fit_coeffs</span><span class="p">[</span><span class="n">ideg</span><span class="p">,:]))</span>
        <span class="n">params_fit_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">params_fit_list</span><span class="p">)</span>
        <span class="c1"># compute map</span>
        <span class="k">for</span> <span class="n">ij</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimy</span><span class="p">):</span>
            <span class="n">fitted_data_map</span><span class="p">[:,</span><span class="n">ij</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">dimx</span><span class="p">),</span> <span class="n">params_fit_list</span><span class="p">[:,</span> <span class="n">ij</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">fitted_data_map</span>
    
    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">fit_coeffs</span><span class="p">,</span> <span class="n">data_map</span><span class="p">,</span> <span class="n">coeffs_smooth_deg</span><span class="p">,</span> <span class="n">err_map</span><span class="p">):</span>
        <span class="n">fitted_data_map</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">fit_coeffs</span><span class="p">,</span> <span class="n">coeffs_smooth_deg</span><span class="p">,</span>
                                <span class="n">data_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                <span class="n">data_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_map</span> <span class="o">-</span> <span class="n">fitted_data_map</span><span class="p">)</span><span class="o">/</span><span class="n">err_map</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">res</span><span class="p">))]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">res</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
  

    <span class="n">coeffs_smooth_deg</span> <span class="o">=</span> <span class="n">smooth_deg</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">coeffs_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">err_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">dimx</span><span class="p">,</span> <span class="n">dimy</span> <span class="o">=</span> <span class="n">data_map</span><span class="o">.</span><span class="n">shape</span>
    
    <span class="c1">## 1st pass: fit lines independantly with a polynomial</span>
    <span class="k">for</span> <span class="n">ij</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimy</span><span class="p">):</span>
        <span class="n">imap</span> <span class="o">=</span> <span class="n">data_map</span><span class="p">[:,</span><span class="n">ij</span><span class="p">]</span>
        <span class="n">ierr</span> <span class="o">=</span> <span class="n">err_map</span><span class="p">[:,</span><span class="n">ij</span><span class="p">]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="n">ierr</span><span class="p">)</span><span class="o">**</span><span class="mf">2.</span>
        
        <span class="n">w</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">w</span><span class="p">))]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="c1"># reject columns with too much NaNs</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">imap</span><span class="p">)</span><span class="o">*</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">w</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">dimy</span><span class="o">/</span><span class="mf">3.</span><span class="p">:</span>
            <span class="n">vect</span><span class="p">,</span> <span class="n">coeffs</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">polyfit1d</span><span class="p">(</span>
                <span class="n">imap</span><span class="p">,</span> <span class="n">smooth_deg</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">return_coeffs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">coeffs_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">err_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bad_coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">smooth_deg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">bad_coeffs</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">coeffs_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bad_coeffs</span><span class="p">)</span>
            <span class="n">err_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            
    <span class="c1">## first fit returns smooth_deg + 1 coefficient for each line</span>
    <span class="n">coeffs_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coeffs_list</span><span class="p">)</span>
    <span class="n">err_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">err_list</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">coeffs_list</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;All fit coeffs are NaNs !&#39;</span><span class="p">)</span>
        
    <span class="c1">## 2nd pass: fit coeffs are smoothed with a polynomial also (which</span>
    <span class="c1">## gives a list of coefficients to recover the first coefficients)</span>
    <span class="n">coeffs_coeffs_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ideg</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">smooth_deg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">fitted_coeffs</span><span class="p">,</span> <span class="n">coeffs_coeffs</span> <span class="o">=</span> <span class="n">smooth_fit_parameters</span><span class="p">(</span>
            <span class="n">coeffs_list</span><span class="p">,</span> <span class="n">err_list</span><span class="p">,</span> <span class="n">ideg</span><span class="p">,</span> <span class="n">coeffs_smooth_deg</span><span class="p">)</span>
        <span class="n">coeffs_coeffs_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeffs_coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="n">coeffs_coeffs_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coeffs_coeffs_list</span><span class="p">)</span>
    
    <span class="c1">## coeffs optimization over the real data map</span>
    <span class="n">fit</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="n">coeffs_coeffs_list</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                           <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">data_map</span><span class="p">,</span> <span class="n">smooth_deg</span><span class="p">,</span> <span class="n">err_map</span><span class="p">),</span>
                           <span class="n">maxfev</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                           <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">fit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">fitted_data_map</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">fit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">smooth_deg</span><span class="p">,</span> <span class="n">dimx</span><span class="p">,</span> <span class="n">dimy</span><span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Fit could not be optimized&#39;</span><span class="p">)</span>

    <span class="c1">## Error computation</span>
    <span class="c1"># Creation of the error map: The error map gives the </span>
    <span class="c1"># Squared Error for each point used in the fit point. </span>
    <span class="n">res_map</span> <span class="o">=</span> <span class="n">data_map</span> <span class="o">-</span> <span class="n">fitted_data_map</span>

    <span class="c1"># The square root of the mean of this map is then normalized</span>
    <span class="c1"># by the range of the values fitted. This gives the Normalized</span>
    <span class="c1"># root-mean-square deviation</span>
    <span class="n">fit_rms_error</span> <span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">res_map</span><span class="o">**</span><span class="mf">2.</span><span class="p">))</span>
                <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">data_map</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">data_map</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">fitted_data_map</span><span class="p">,</span> <span class="n">res_map</span><span class="p">,</span> <span class="n">fit_rms_error</span></div>


<div class="viewcode-block" id="tilt_calibration_laser_map"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.tilt_calibration_laser_map">[docs]</a><span class="k">def</span> <span class="nf">tilt_calibration_laser_map</span><span class="p">(</span><span class="n">cmap</span><span class="p">,</span> <span class="n">calib_laser_nm</span><span class="p">,</span> <span class="n">phi_x</span><span class="p">,</span> <span class="n">phi_y</span><span class="p">,</span> <span class="n">phi_r</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Tilt and rotate a calibration laser map.</span>

<span class="sd">    :param cmap: calibration laser map.</span>
<span class="sd">    :param calib_laser_nm: Calibration laser wavelength in nm.</span>
<span class="sd">    :param phi_x: tilt angle along X axis (degrees).</span>
<span class="sd">    :param phi_y: tilt angle along Y axis (degrees).</span>
<span class="sd">    :param phi_r: Rotation angle (degrees).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">phi_x</span> <span class="o">=</span> <span class="n">phi_x</span> <span class="o">/</span> <span class="mf">180.</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">phi_y</span> <span class="o">=</span> <span class="n">phi_y</span> <span class="o">/</span> <span class="mf">180.</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">phi_r</span> <span class="o">=</span> <span class="n">phi_r</span> <span class="o">/</span> <span class="mf">180.</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
    
    <span class="n">xc</span><span class="p">,</span> <span class="n">yc</span> <span class="o">=</span> <span class="n">cmap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">cmap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">theta_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">calib_laser_nm</span> <span class="o">/</span> <span class="n">cmap</span><span class="p">)</span>
    <span class="n">theta_c</span> <span class="o">=</span> <span class="n">theta_map</span><span class="p">[</span><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">]</span>
    <span class="n">theta_map</span> <span class="o">-=</span> <span class="n">theta_c</span>
    
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">cmap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">:</span><span class="n">cmap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">-=</span> <span class="n">xc</span>
    <span class="n">Y</span> <span class="o">-=</span> <span class="n">yc</span>
    
    <span class="n">alpha</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span> <span class="o">-</span> <span class="n">theta_map</span>

    <span class="k">if</span> <span class="n">phi_r</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">Xr</span> <span class="o">=</span> <span class="n">X</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi_r</span><span class="p">)</span> <span class="o">-</span> <span class="n">Y</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi_r</span><span class="p">)</span>
        <span class="n">Yr</span> <span class="o">=</span> <span class="n">X</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi_r</span><span class="p">)</span> <span class="o">+</span> <span class="n">Y</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi_r</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">Xr</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">Yr</span>
    
    <span class="k">if</span> <span class="n">phi_x</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
        <span class="n">alpha2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span> <span class="o">-</span> <span class="n">theta_map</span> <span class="o">-</span> <span class="n">phi_x</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha2</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">*=</span> <span class="n">ratio</span>
        
    <span class="k">if</span> <span class="n">phi_y</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
        <span class="n">alpha2</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span> <span class="o">-</span> <span class="n">theta_map</span> <span class="o">-</span> <span class="n">phi_y</span>
        <span class="n">ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha2</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">*=</span> <span class="n">ratio</span>
    
    <span class="n">f_theta</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cmap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">-</span><span class="n">xc</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cmap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span><span class="o">-</span><span class="n">yc</span><span class="p">,</span>
        <span class="n">theta_map</span><span class="p">,</span> <span class="n">kx</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ky</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="n">new_calib_map</span> <span class="o">=</span> <span class="n">calib_laser_nm</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">f_theta</span><span class="o">.</span><span class="n">ev</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span> <span class="o">+</span> <span class="n">theta_c</span><span class="p">)</span>
    <span class="c1"># reject extrapolated values</span>
    <span class="n">new_calib_map</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span>
        <span class="p">(</span><span class="n">X</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">xc</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">X</span> <span class="o">&gt;=</span> <span class="n">cmap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">xc</span><span class="p">)</span>
        <span class="o">+</span> <span class="p">(</span><span class="n">Y</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">yc</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">Y</span> <span class="o">&gt;=</span> <span class="n">cmap</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">yc</span><span class="p">))]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
    <span class="k">return</span> <span class="n">new_calib_map</span></div>

<div class="viewcode-block" id="simulate_theta_map"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.simulate_theta_map">[docs]</a><span class="k">def</span> <span class="nf">simulate_theta_map</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">pixel_size</span><span class="p">,</span>
                       <span class="n">mirror_distance</span><span class="p">,</span>
                       <span class="n">theta_cx</span><span class="p">,</span> <span class="n">theta_cy</span><span class="p">,</span>
                       <span class="n">phi_x</span><span class="p">,</span> <span class="n">phi_y</span><span class="p">,</span> <span class="n">phi_r</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simulate incident angle (theta) map from optical and mechanical</span>
<span class="sd">    parameters</span>

<span class="sd">    :param nx: Number of pixels along X</span>
<span class="sd">    </span>
<span class="sd">    :param ny: Number of pixels along Y</span>
<span class="sd">    </span>
<span class="sd">    :param pixel_size: Size of a pixel in microns</span>
<span class="sd">    </span>
<span class="sd">    :param mirror_distance: Distance to the mirror in microns on the</span>
<span class="sd">      optical axis.</span>
<span class="sd">    </span>
<span class="sd">    :param theta_cx: Angle from the optical axis to the mirror</span>
<span class="sd">      center in degrees along X axis (in degrees)</span>

<span class="sd">    :param theta_cy: Angle from the optical axis to the mirror</span>
<span class="sd">      center in degrees along Y axis (in degrees)</span>

<span class="sd">    :param phi_x: Tilt of the mirror along X in degrees</span>
<span class="sd">    </span>
<span class="sd">    :param phi_y: Tilt of the mirror along Y in degrees</span>
<span class="sd">    </span>
<span class="sd">    :param phi_r: Rotation angle of the camera in degrees</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">x2theta</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span>
            <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">D</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">D</span><span class="p">)</span>
            <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">((</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">))</span>
                <span class="o">-</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mf">2.</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">central_angle</span><span class="p">(</span><span class="n">phiX</span><span class="p">,</span> <span class="n">phiY</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;from Vincenty&#39;s formula&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phiY</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phiX</span><span class="p">))</span><span class="o">**</span><span class="mf">2.</span>
                <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phiY</span><span class="p">)</span><span class="o">**</span><span class="mf">2.</span><span class="p">),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phiY</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phiX</span><span class="p">))</span>
    
    <span class="n">theta_cx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">theta_cx</span><span class="p">)</span>
    <span class="n">theta_cy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">theta_cy</span><span class="p">)</span>
    <span class="n">phi_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">phi_x</span><span class="p">)</span>
    <span class="n">phi_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">phi_y</span><span class="p">)</span>
    <span class="n">phi_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">phi_r</span><span class="p">)</span>

    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[:</span><span class="n">nx</span><span class="p">,:</span><span class="n">ny</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">-=</span> <span class="n">nx</span> <span class="o">/</span> <span class="mf">2.</span> <span class="o">-</span> <span class="mf">0.5</span>
    <span class="n">Y</span> <span class="o">-=</span> <span class="n">ny</span> <span class="o">/</span> <span class="mf">2.</span> <span class="o">-</span> <span class="mf">0.5</span>
    <span class="n">X</span> <span class="o">*=</span> <span class="n">pixel_size</span>
    <span class="n">Y</span> <span class="o">*=</span> <span class="n">pixel_size</span>
    
    <span class="n">Xr</span> <span class="o">=</span> <span class="n">X</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi_r</span><span class="p">)</span> <span class="o">+</span> <span class="n">Y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi_r</span><span class="p">)</span>
    <span class="n">Yr</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi_r</span><span class="p">)</span> <span class="o">-</span> <span class="n">X</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi_r</span><span class="p">)</span>

    <span class="n">thetax</span> <span class="o">=</span> <span class="n">theta_cx</span> <span class="o">+</span> <span class="n">x2theta</span><span class="p">(</span><span class="n">Xr</span><span class="p">,</span> <span class="n">mirror_distance</span><span class="p">,</span> <span class="n">phi_x</span><span class="p">)</span>
    <span class="n">thetay</span> <span class="o">=</span> <span class="n">theta_cy</span> <span class="o">+</span> <span class="n">x2theta</span><span class="p">(</span><span class="n">Yr</span><span class="p">,</span> <span class="n">mirror_distance</span><span class="p">,</span> <span class="n">phi_y</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">central_angle</span><span class="p">(</span><span class="n">thetax</span><span class="p">,</span> <span class="n">thetay</span><span class="p">))</span></div>

    <span class="c1">#return np.rad2deg(np.sqrt(thetax**2 + thetay**2))</span>

<div class="viewcode-block" id="simulate_calibration_laser_map"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.simulate_calibration_laser_map">[docs]</a><span class="k">def</span> <span class="nf">simulate_calibration_laser_map</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">pixel_size</span><span class="p">,</span>
                                   <span class="n">mirror_distance</span><span class="p">,</span>
                                   <span class="n">theta_cx</span><span class="p">,</span> <span class="n">theta_cy</span><span class="p">,</span>
                                   <span class="n">phi_x</span><span class="p">,</span> <span class="n">phi_y</span><span class="p">,</span> <span class="n">phi_r</span><span class="p">,</span>
                                   <span class="n">calib_laser_nm</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Simulate a calibration laser map from optical and mechanical</span>
<span class="sd">    parameters</span>

<span class="sd">    :param nx: Number of pixels along X</span>
<span class="sd">    </span>
<span class="sd">    :param ny: Number of pixels along Y</span>
<span class="sd">    </span>
<span class="sd">    :param pixel_size: Size of a pixel in microns</span>
<span class="sd">    </span>
<span class="sd">    :param mirror_distance: Distance to the mirror in microns on the</span>
<span class="sd">      optical axis.</span>
<span class="sd">    </span>
<span class="sd">    :param theta_cx: Angle from the optical axis to the mirror</span>
<span class="sd">      center in degrees along X axis (in degrees)</span>

<span class="sd">    :param theta_cy: Angle from the optical axis to the mirror</span>
<span class="sd">      center in degrees along Y axis (in degrees)</span>

<span class="sd">    :param phi_x: Tilt of the mirror along X in degrees</span>
<span class="sd">    </span>
<span class="sd">    :param phi_y: Tilt of the mirror along Y in degrees</span>
<span class="sd">    </span>
<span class="sd">    :param phi_r: Rotation angle of the camera in degrees</span>
<span class="sd">    </span>
<span class="sd">    :param calib_laser_nm: Calibration laser wavelength in nm</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">calib_laser_nm</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">simulate_theta_map</span><span class="p">(</span>
        <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">pixel_size</span><span class="p">,</span> <span class="n">mirror_distance</span><span class="p">,</span>
        <span class="n">theta_cx</span><span class="p">,</span> <span class="n">theta_cy</span><span class="p">,</span> <span class="n">phi_x</span><span class="p">,</span> <span class="n">phi_y</span><span class="p">,</span> <span class="n">phi_r</span><span class="p">)))</span></div>

<div class="viewcode-block" id="nanbin_image"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.nanbin_image">[docs]</a><span class="k">def</span> <span class="nf">nanbin_image</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">binning</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mean image binning robust to NaNs.</span>

<span class="sd">    :param im: Image to bin</span>
<span class="sd">    :param binning: Binning factor (must be an integer)</span>
<span class="sd">    &quot;&quot;&quot;</span>     
    <span class="k">return</span> <span class="n">orb</span><span class="o">.</span><span class="n">cutils</span><span class="o">.</span><span class="n">nanbin_image</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">binning</span><span class="p">))</span></div>


<div class="viewcode-block" id="fit_calibration_laser_map"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.fit_calibration_laser_map">[docs]</a><span class="k">def</span> <span class="nf">fit_calibration_laser_map</span><span class="p">(</span><span class="n">calib_laser_map</span><span class="p">,</span> <span class="n">calib_laser_nm</span><span class="p">,</span> <span class="n">pixel_size</span><span class="o">=</span><span class="mf">15.</span><span class="p">,</span>
                              <span class="n">binning</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">mirror_distance_guess</span><span class="o">=</span><span class="mf">2.4e5</span><span class="p">,</span>
                              <span class="n">return_model_fit</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fit a calibration laser map.</span>

<span class="sd">    Fit an opto-mechanical model first and uses Zernike polynomials to</span>
<span class="sd">    fit the residual wavefront error.</span>

<span class="sd">    The model is based on optical parameters.</span>
<span class="sd">    </span>
<span class="sd">    :param calib_laser_map: Reference calibration laser map.</span>
<span class="sd">    </span>
<span class="sd">    :param calib_laser_nm: Wavelength of the calibration laser in nm.</span>
<span class="sd">    </span>
<span class="sd">    :param pixel_size: (Optional) Size of the CCD pixels in um</span>
<span class="sd">      (default 15).</span>
<span class="sd">    </span>
<span class="sd">    :param binning: (Optional) Maps are binned to accelerate the</span>
<span class="sd">      process. Set the binning factor (default 4).</span>

<span class="sd">    :param mirror_distance_guess: (Optional) Guess on the mirror</span>
<span class="sd">      distance in um (default 2.2e5).</span>

<span class="sd">    :param return_model_fit: (Optional) If True the optical model fit</span>
<span class="sd">      is also returned (i.e. without the wavefront modeling with Zernike</span>
<span class="sd">      polynomials) (default False).</span>

<span class="sd">    .. note:: Zernike polynomial fit routine has been written by Tim</span>
<span class="sd">      van Werkhoven (werkhoven@strw.leidenuniv.nl) as a part of</span>
<span class="sd">      libtim. It can be found in ORB module in ./ext/zern.py.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">model_laser_map</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">pixel_size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        0: mirror_distance</span>
<span class="sd">        1: theta_cx</span>
<span class="sd">        2: theta_cy</span>
<span class="sd">        3: phi_x</span>
<span class="sd">        4: phi_y</span>
<span class="sd">        5: phi_r    </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">simulate_calibration_laser_map</span><span class="p">(</span>
            <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">pixel_size</span><span class="p">,</span>
            <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">diff_laser_map</span><span class="p">(</span><span class="n">p_var</span><span class="p">,</span> <span class="n">p_fix</span><span class="p">,</span> <span class="n">p_ind</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">pixel_size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;p_ind = 0: variable parameter, index=1: fixed parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">get_p</span><span class="p">(</span><span class="n">p_var</span><span class="p">,</span> <span class="n">p_fix</span><span class="p">,</span> <span class="n">p_ind</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">model_laser_map</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">calib</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">calib</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pixel_size</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">-=</span> <span class="n">calib</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">res</span><span class="p">))]</span>
        <span class="c1">#res = orb.utils.stats.sigmacut(res)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span> <span class="nf">get_p</span><span class="p">(</span><span class="n">p_var</span><span class="p">,</span> <span class="n">p_fix</span><span class="p">,</span> <span class="n">p_ind</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">p_ind</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">p</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">p_ind</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">p_var</span>
        <span class="n">p</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">p_ind</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">p_fix</span>
        <span class="k">return</span> <span class="n">p</span>
        

    <span class="k">def</span> <span class="nf">print_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">fvec</span><span class="p">,</span> <span class="n">p_ind</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">print_fix</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">p_ind</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">:</span> <span class="k">return</span> <span class="s1">&#39;(Fixed)&#39;</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39;&#39;</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;    &gt; Calibration laser map fit parameters:</span><span class="se">\n</span><span class="s1">&#39;</span>
               <span class="o">+</span> <span class="s1">&#39;    distance to mirror: </span><span class="si">{}</span><span class="s1"> cm </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                   <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1e-4</span><span class="p">,</span> <span class="n">print_fix</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
               <span class="o">+</span> <span class="s1">&#39;    X angle from the optical axis to the center: </span><span class="si">{}</span><span class="s1"> degrees </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                   <span class="n">math</span><span class="o">.</span><span class="n">fmod</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="mi">360</span><span class="p">),</span> <span class="n">print_fix</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
               <span class="o">+</span> <span class="s1">&#39;    Y angle from the optical axis to the center: </span><span class="si">{}</span><span class="s1"> degrees </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                   <span class="n">math</span><span class="o">.</span><span class="n">fmod</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span><span class="mi">360</span><span class="p">),</span> <span class="n">print_fix</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
               <span class="o">+</span> <span class="s1">&#39;    Tip-tilt angle of the detector along X: </span><span class="si">{}</span><span class="s1"> degrees </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                   <span class="n">math</span><span class="o">.</span><span class="n">fmod</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span><span class="mi">360</span><span class="p">),</span> <span class="n">print_fix</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
               <span class="o">+</span> <span class="s1">&#39;    Tip-tilt angle of the detector along Y: </span><span class="si">{}</span><span class="s1"> degrees </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                   <span class="n">math</span><span class="o">.</span><span class="n">fmod</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">4</span><span class="p">]),</span><span class="mi">360</span><span class="p">),</span> <span class="n">print_fix</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
               <span class="o">+</span> <span class="s1">&#39;    Rotation angle of the detector: </span><span class="si">{}</span><span class="s1"> degrees </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                   <span class="n">math</span><span class="o">.</span><span class="n">fmod</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="mi">5</span><span class="p">]),</span><span class="mi">360</span><span class="p">),</span> <span class="n">print_fix</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
               <span class="o">+</span> <span class="s1">&#39;    Calibration laser wavelength: </span><span class="si">{}</span><span class="s1"> nm </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                   <span class="n">params</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">print_fix</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
               <span class="o">+</span> <span class="s1">&#39;    Error on fit: mean </span><span class="si">{}</span><span class="s1">, std </span><span class="si">{}</span><span class="s1"> (in nm)</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                   <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">fvec</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">fvec</span><span class="p">))</span>
               <span class="o">+</span> <span class="s1">&#39;    Error on fit: mean </span><span class="si">{}</span><span class="s1">, std </span><span class="si">{}</span><span class="s1"> (in km/s)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                   <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">fvec</span><span class="p">)</span><span class="o">/</span><span class="n">calib_laser_nm</span><span class="o">*</span><span class="mf">3e5</span><span class="p">,</span>
                   <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">fvec</span><span class="p">)</span><span class="o">/</span><span class="n">calib_laser_nm</span><span class="o">*</span><span class="mf">3e5</span><span class="p">))</span>

    <span class="n">CENTER_COEFF</span> <span class="o">=</span> <span class="mf">0.3</span>
    <span class="n">LARGE_COEFF</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="c1"># 0.95</span>
    <span class="n">ZERN_MODES</span> <span class="o">=</span> <span class="mi">20</span> <span class="c1"># number of Zernike modes to fit </span>
    <span class="n">BORDER_SIZE</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1"># in pixels</span>
    <span class="n">ANGLE_RANGE</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1"># in degrees</span>

    <span class="c1"># compute angle at the exact center of the map</span>
    <span class="n">cx</span> <span class="o">=</span> <span class="n">calib_laser_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span>
    <span class="n">cy</span> <span class="o">=</span> <span class="n">calib_laser_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span>
    <span class="n">center_calib_nm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span>
        <span class="n">calib_laser_map</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">cx</span><span class="o">-</span><span class="mf">0.5</span><span class="p">):</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">cx</span><span class="o">-</span><span class="mf">0.5</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span>
                        <span class="nb">int</span><span class="p">(</span><span class="n">cy</span><span class="o">-</span><span class="mf">0.5</span><span class="p">):</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">cy</span><span class="o">-</span><span class="mf">0.5</span><span class="o">+</span><span class="mi">1</span><span class="p">))])</span>
    
    <span class="n">theta_c</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">calib_laser_nm</span><span class="o">/</span><span class="n">center_calib_nm</span><span class="p">)</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">180.</span>
    <span class="nb">print</span> <span class="s1">&#39;Angle at the center of the frame: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">theta_c</span><span class="p">)</span>

    <span class="c1"># filter calibration laser map</span>
    <span class="n">value_min</span> <span class="o">=</span> <span class="n">calib_laser_nm</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="n">theta_c</span> <span class="o">-</span> <span class="n">ANGLE_RANGE</span><span class="p">)</span><span class="o">/</span><span class="mf">180.</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">value_max</span> <span class="o">=</span> <span class="n">calib_laser_nm</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">((</span><span class="n">theta_c</span> <span class="o">+</span> <span class="n">ANGLE_RANGE</span><span class="p">)</span><span class="o">/</span><span class="mf">180.</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">calib_laser_map</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">calib_laser_map</span> <span class="o">&gt;</span> <span class="n">value_max</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">calib_laser_map</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">calib_laser_map</span> <span class="o">&lt;</span> <span class="n">value_min</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># remove borders</span>
    <span class="n">calib_laser_map</span><span class="p">[:</span><span class="n">BORDER_SIZE</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">calib_laser_map</span><span class="p">[</span><span class="o">-</span><span class="n">BORDER_SIZE</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">calib_laser_map</span><span class="p">[:,:</span><span class="n">BORDER_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">calib_laser_map</span><span class="p">[:,</span><span class="o">-</span><span class="n">BORDER_SIZE</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
    <span class="nb">print</span> <span class="s1">&#39;&gt; Binning calibration map&#39;</span>

    <span class="n">binning</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">binning</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">binning</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">calib_laser_map_bin</span> <span class="o">=</span> <span class="n">nanbin_image</span><span class="p">(</span><span class="n">calib_laser_map</span><span class="p">,</span> <span class="n">binning</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">calib_laser_map_bin</span> <span class="o">=</span> <span class="n">calib_laser_map</span>

    <span class="nb">print</span> <span class="s1">&#39;&gt; Calibration laser map fit&#39;</span>

    <span class="c1">## mirror_dist, Y angle</span>
    <span class="c1">## p_ind = 0: variable parameter, index=1: fixed parameter</span>
    <span class="c1">## 0: mirror_distance</span>
    <span class="c1">## 1: theta_cx</span>
    <span class="c1">## 2: theta_cy</span>
    <span class="c1">## 3: phi_x</span>
    <span class="c1">## 4: phi_y</span>
    <span class="c1">## 5: phi_r    </span>


    <span class="nb">print</span> <span class="s1">&#39;  &gt; First fit on the central portion of the calibration laser map (</span><span class="si">{:.1f}% o</span><span class="s1">f the total size)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">CENTER_COEFF</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">xmin</span><span class="p">,</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymin</span><span class="p">,</span><span class="n">ymax</span> <span class="o">=</span> <span class="n">get_box_coords</span><span class="p">(</span>
        <span class="n">calib_laser_map_bin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">calib_laser_map_bin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
        <span class="nb">int</span><span class="p">(</span><span class="n">CENTER_COEFF</span><span class="o">*</span><span class="n">calib_laser_map_bin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">calib_laser_map_bin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">calib_laser_map_bin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">calib_laser_map_bin_center</span> <span class="o">=</span> <span class="n">calib_laser_map_bin</span><span class="p">[</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">]</span>

    <span class="n">p_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mirror_distance_guess</span><span class="p">,</span> <span class="n">theta_c</span><span class="p">])</span>
    <span class="n">p_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">p_fix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">calib_laser_nm</span><span class="p">])</span>
    <span class="n">fit</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span><span class="n">diff_laser_map</span><span class="p">,</span> <span class="n">p_var</span><span class="p">,</span>
                                 <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">p_fix</span><span class="p">,</span> <span class="n">p_ind</span><span class="p">,</span> <span class="n">calib_laser_map_bin_center</span><span class="p">,</span>
                                       <span class="nb">float</span><span class="p">(</span><span class="n">pixel_size</span><span class="o">*</span><span class="n">binning</span><span class="p">)),</span>
                                 <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">get_p</span><span class="p">(</span><span class="n">fit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_fix</span><span class="p">,</span> <span class="n">p_ind</span><span class="p">)</span>
   
    <span class="n">print_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">fit</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;fvec&#39;</span><span class="p">],</span> <span class="n">p_ind</span><span class="p">)</span>

    <span class="nb">print</span> <span class="s1">&#39;  &gt; Second fit on the central portion of the calibration laser map (</span><span class="si">{:.1f}% o</span><span class="s1">f the total size)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">CENTER_COEFF</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
    <span class="c1">## p_var = np.array([params[0], 0., params[2], 0., 0., 0.])</span>
    <span class="c1">## p_ind = np.array([0, 0, 0, 0, 0, 0, 1])</span>
    <span class="c1">## p_fix = np.array([calib_laser_nm])</span>
    <span class="n">p_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
    <span class="n">p_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">p_fix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="n">calib_laser_nm</span><span class="p">])</span>

    <span class="n">fit</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span><span class="n">diff_laser_map</span><span class="p">,</span> <span class="n">p_var</span><span class="p">,</span>
                                 <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">p_fix</span><span class="p">,</span> <span class="n">p_ind</span><span class="p">,</span> <span class="n">calib_laser_map_bin_center</span><span class="p">,</span>
                                       <span class="nb">float</span><span class="p">(</span><span class="n">pixel_size</span><span class="o">*</span><span class="n">binning</span><span class="p">)),</span>
                                 <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">get_p</span><span class="p">(</span><span class="n">fit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_fix</span><span class="p">,</span> <span class="n">p_ind</span><span class="p">)</span>
   
    <span class="n">print_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">fit</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;fvec&#39;</span><span class="p">],</span> <span class="n">p_ind</span><span class="p">)</span>


    <span class="nb">print</span> <span class="s1">&#39;  &gt; Third fit on a larger portion of the map (</span><span class="si">{:.1f}% o</span><span class="s1">f the total size)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">LARGE_COEFF</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">xmin</span><span class="p">,</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymin</span><span class="p">,</span><span class="n">ymax</span> <span class="o">=</span> <span class="n">get_box_coords</span><span class="p">(</span>
        <span class="n">calib_laser_map_bin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">calib_laser_map_bin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
        <span class="nb">int</span><span class="p">(</span><span class="n">LARGE_COEFF</span><span class="o">*</span><span class="n">calib_laser_map_bin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">calib_laser_map_bin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">calib_laser_map_bin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">calib_laser_map_bin_large</span> <span class="o">=</span> <span class="n">calib_laser_map_bin</span><span class="p">[</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">]</span>
    <span class="c1">## p_var = np.array(params[:-1])</span>
    <span class="c1">## p_ind = np.array([0, 0, 0, 0, 0, 0, 1])</span>
    <span class="c1">## p_fix = np.array([calib_laser_nm])</span>
    <span class="n">p_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
    <span class="n">p_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">p_fix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="n">calib_laser_nm</span><span class="p">])</span>

    
    <span class="n">fit</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span><span class="n">diff_laser_map</span><span class="p">,</span> <span class="n">p_var</span><span class="p">,</span>
                                 <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">p_fix</span><span class="p">,</span> <span class="n">p_ind</span><span class="p">,</span> <span class="n">calib_laser_map_bin_large</span><span class="p">,</span>
                                       <span class="nb">float</span><span class="p">(</span><span class="n">pixel_size</span><span class="o">*</span><span class="n">binning</span><span class="p">)),</span>
                                 <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">get_p</span><span class="p">(</span><span class="n">fit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_fix</span><span class="p">,</span> <span class="n">p_ind</span><span class="p">)</span>
    <span class="n">print_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">fit</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;fvec&#39;</span><span class="p">],</span> <span class="n">p_ind</span><span class="p">)</span>

    <span class="c1">## print &#39;  &gt; Third fit on all the map ({:.1f}% of the total size)&#39;.format(LARGE_COEFF*100)</span>
    <span class="c1">## xmin,xmax,ymin,ymax = get_box_coords(</span>
    <span class="c1">##     calib_laser_map_bin.shape[0]/2,</span>
    <span class="c1">##     calib_laser_map_bin.shape[1]/2,</span>
    <span class="c1">##     int(LARGE_COEFF*calib_laser_map_bin.shape[0]),</span>
    <span class="c1">##     0, calib_laser_map_bin.shape[0],</span>
    <span class="c1">##     0, calib_laser_map_bin.shape[1])</span>
    <span class="c1">## calib_laser_map_bin_large = calib_laser_map_bin[xmin:xmax,ymin:ymax]</span>
    <span class="c1">## p_var = np.array(params[0:3])</span>
    <span class="c1">## p_ind = np.array([0, 0, 0, 1, 1, 1, 1])</span>
    <span class="c1">## p_fix = np.array([0,0,0,calib_laser_nm])</span>
    
    <span class="c1">## fit = scipy.optimize.leastsq(diff_laser_map, p_var,</span>
    <span class="c1">##                              args=(p_fix, p_ind, calib_laser_map_bin_large,</span>
    <span class="c1">##                                    float(pixel_size*binning)),</span>
    <span class="c1">##                              full_output=True)</span>
    <span class="c1">## params = get_p(fit[0], p_fix, p_ind)</span>
    <span class="c1">## print_params(params, fit[2][&#39;fvec&#39;], p_ind)</span>

    
    <span class="n">new_calib_laser_map</span> <span class="o">=</span> <span class="n">model_laser_map</span><span class="p">(</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">calib_laser_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">calib_laser_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pixel_size</span><span class="p">)</span>
    
    <span class="n">model_fit_calib_laser_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">new_calib_laser_map</span><span class="p">)</span>
    
    <span class="c1"># Zernike fit of the diff map</span>
    <span class="nb">print</span> <span class="s1">&#39;  &gt; Zernike polynomials fit of the residual wavefront&#39;</span>
    <span class="n">res_map</span> <span class="o">=</span> <span class="n">calib_laser_map</span> <span class="o">-</span> <span class="n">new_calib_laser_map</span>    
    <span class="n">res_map</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">res_map</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">res_map_fit</span><span class="p">,</span> <span class="n">_err_map</span><span class="p">,</span> <span class="n">_fit_error</span> <span class="o">=</span> <span class="n">fit_map_zernike</span><span class="p">(</span>
        <span class="n">res_map</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">res_map</span><span class="p">),</span> <span class="n">ZERN_MODES</span><span class="p">)</span>

    <span class="n">new_calib_laser_map</span> <span class="o">+=</span> <span class="n">res_map_fit</span>
    
    <span class="c1"># final error</span>
    <span class="n">std_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span>
        <span class="p">(</span><span class="n">calib_laser_map</span> <span class="o">-</span> <span class="n">new_calib_laser_map</span><span class="p">)[</span>
            <span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">])</span>
    
    <span class="nb">print</span> <span class="s1">&#39;&gt; final error (std on </span><span class="si">{:.1f}% o</span><span class="s1">f the total size): </span><span class="si">{:.3e}</span><span class="s1"> nm, </span><span class="si">{:.3e}</span><span class="s1"> km/s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">LARGE_COEFF</span><span class="o">*</span><span class="mf">100.</span><span class="p">,</span> <span class="n">std_err</span><span class="p">,</span> <span class="n">std_err</span><span class="o">/</span><span class="n">calib_laser_nm</span><span class="o">*</span><span class="mf">3e5</span><span class="p">)</span>

    <span class="n">params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">params</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">([</span><span class="n">theta_c</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">return_model_fit</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">new_calib_laser_map</span><span class="p">,</span> <span class="n">model_fit_calib_laser_map</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">params</span><span class="p">,</span> <span class="n">new_calib_laser_map</span></div>


<div class="viewcode-block" id="fit_highorder_phase_map"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.fit_highorder_phase_map">[docs]</a><span class="k">def</span> <span class="nf">fit_highorder_phase_map</span><span class="p">(</span><span class="n">phase_map</span><span class="p">,</span> <span class="n">err_map</span><span class="p">,</span> <span class="n">calib_map</span><span class="p">,</span> <span class="n">nm_laser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Robust fit phase maps of order &gt; 1</span>

<span class="sd">    Uses a theta dependant fit model base on a spline. See</span>
<span class="sd">    py:meth:`utils.fit_map_cos`.</span>
<span class="sd">    </span>
<span class="sd">    :param phase_map: Phase map to fit</span>

<span class="sd">    :param err_map: Error map of phase map values</span>

<span class="sd">    :param calib_map: Calibration laser map.</span>

<span class="sd">    :param nm_laser: Calibration laser wavelength in nm.</span>

<span class="sd">    :return: A tuple: (Fitted map, residual map)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># WARNING: CROP_COEFF must correspond to the CROP_COEFF used in</span>
    <span class="c1"># fit_sitelle_phase_map</span>
    <span class="n">CROP_COEFF</span> <span class="o">=</span> <span class="mf">0.98</span> <span class="c1"># proportion of the phase map to keep when</span>
                      <span class="c1"># cropping</span>

    <span class="c1"># bad values are filtered and phase map is cropped to remove</span>
    <span class="c1"># borders with erroneous phase values.</span>
    <span class="n">phase_map</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">phase_map</span><span class="o">==</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
    <span class="n">xmin</span><span class="p">,</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymin</span><span class="p">,</span><span class="n">ymax</span> <span class="o">=</span> <span class="n">get_box_coords</span><span class="p">(</span>
        <span class="n">phase_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">phase_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
        <span class="nb">int</span><span class="p">(</span><span class="n">CROP_COEFF</span><span class="o">*</span><span class="n">phase_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">phase_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">phase_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">phase_map</span><span class="p">[:</span><span class="n">xmin</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">phase_map</span><span class="p">[</span><span class="n">xmax</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">phase_map</span><span class="p">[:,:</span><span class="n">ymin</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">phase_map</span><span class="p">[:,</span><span class="n">ymax</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
    <span class="n">err_map</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">phase_map</span><span class="p">))]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    
    <span class="n">phase_map_fit</span><span class="p">,</span> <span class="n">res_map</span><span class="p">,</span> <span class="n">rms_error</span> <span class="o">=</span> <span class="n">fit_map_cos</span><span class="p">(</span><span class="n">phase_map</span><span class="p">,</span> <span class="n">err_map</span><span class="p">,</span> <span class="n">calib_map</span><span class="p">,</span> <span class="n">nm_laser</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s1">&#39; &gt; Residual STD after cos theta fit: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">res_map</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">phase_map_fit</span><span class="p">,</span> <span class="n">phase_map</span> <span class="o">-</span> <span class="n">phase_map_fit</span></div>
    
    


<div class="viewcode-block" id="fit_sitelle_phase_map"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.fit_sitelle_phase_map">[docs]</a><span class="k">def</span> <span class="nf">fit_sitelle_phase_map</span><span class="p">(</span><span class="n">phase_map</span><span class="p">,</span> <span class="n">phase_map_err</span><span class="p">,</span> <span class="n">calib_laser_map</span><span class="p">,</span>
                          <span class="n">calib_laser_nm</span><span class="p">,</span> <span class="n">pixel_size</span><span class="o">=</span><span class="mf">15.</span><span class="p">,</span> <span class="n">binning</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
                          <span class="n">return_coeffs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">wavefront_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;Fit a SITELLE phase map (order 0 map of the phase) using a</span>
<span class="sd">    model based on a simulated calibration laser map.</span>

<span class="sd">    A real calibration laser map is needed first to get an initial guess</span>
<span class="sd">    on the parameters of the fit. Then the whole phase map is modeled</span>
<span class="sd">    to fit the real phase map.</span>

<span class="sd">    The modeled calibration laser map obtained from the fit is also</span>
<span class="sd">    returned.</span>

<span class="sd">    :param phase_map: Phase map to fit.</span>
<span class="sd">    </span>
<span class="sd">    :param phase_map_err: Error on the phase map values.</span>
<span class="sd">    </span>
<span class="sd">    :param calib_laser_map: Reference calibration laser map.</span>
<span class="sd">    </span>
<span class="sd">    :param calib_laser_nm: Wavelength of the calibration laser in nm.</span>
<span class="sd">    </span>
<span class="sd">    :param pixel_size: (Optional) Size of the CCD pixels in um</span>
<span class="sd">      (default 15).</span>
<span class="sd">    </span>
<span class="sd">    :param binning: (Optional) Maps are binned to accelerate the</span>
<span class="sd">      process. Set the binning factor (default 4).</span>

<span class="sd">    :param return_coeffs: (Optional) If True, transformation</span>
<span class="sd">      coefficients are returned also (default False).</span>

<span class="sd">    :param wavefront_map: (Optional) Residual between the modeled</span>
<span class="sd">      calibration laser map and the real laser map. This residual can</span>
<span class="sd">      generally be fitted with Zernike polynomials. If given, the</span>
<span class="sd">      wavefront is considered stable and is removed before the model</span>
<span class="sd">      is fitted (default None).</span>

<span class="sd">    :return: a tuple (fitted phase map, error map, fit error, new</span>
<span class="sd">      calibration laser map) + a tuple of transformation coefficients</span>
<span class="sd">      (a0 and a1) if return_coeffs is True.</span>
<span class="sd">      </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">model_laser_map</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">calib_laser_nm</span><span class="p">,</span> <span class="n">pixel_size</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">simulate_calibration_laser_map</span><span class="p">(</span>
            <span class="n">calib</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">calib</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pixel_size</span><span class="p">,</span>
            <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">calib_laser_nm</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">model_phase_map</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">calib_laser_nm</span><span class="p">,</span> <span class="n">pixel_size</span><span class="p">,</span> <span class="n">poly_deg</span><span class="p">,</span> <span class="n">wf_map</span><span class="p">):</span>
        <span class="n">_model_calib_map</span> <span class="o">=</span> <span class="n">model_laser_map</span><span class="p">(</span>
            <span class="n">p</span><span class="p">[</span><span class="n">poly_deg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">calib</span><span class="p">,</span> <span class="n">calib_laser_nm</span><span class="p">,</span> <span class="n">pixel_size</span><span class="p">)</span>
        <span class="n">_model_calib_map</span> <span class="o">+=</span> <span class="n">wf_map</span>
        <span class="k">return</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">calib_map2phase_map0</span><span class="p">(</span>
            <span class="n">p</span><span class="p">[:</span><span class="n">poly_deg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
            <span class="n">_model_calib_map</span><span class="p">,</span>
            <span class="n">calib_laser_nm</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_p</span><span class="p">(</span><span class="n">p_var</span><span class="p">,</span> <span class="n">p_fix</span><span class="p">,</span> <span class="n">p_ind</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;p_ind = 0: variable parameter, index=1: fixed parameter</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">p_ind</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">p_all</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">p_ind</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">)]</span> <span class="o">=</span> <span class="n">p_var</span>
        <span class="n">p_all</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">p_ind</span> <span class="o">&gt;</span> <span class="mf">0.</span><span class="p">)]</span> <span class="o">=</span> <span class="n">p_fix</span>
        <span class="k">return</span> <span class="n">p_all</span>

    <span class="k">def</span> <span class="nf">diff_phase_map</span><span class="p">(</span><span class="n">p_var</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">calib_laser_nm</span><span class="p">,</span> <span class="n">pixel_size</span><span class="p">,</span> <span class="n">pm</span><span class="p">,</span>
                       <span class="n">pm_err</span><span class="p">,</span> <span class="n">p_fix</span><span class="p">,</span> <span class="n">p_ind</span><span class="p">,</span> <span class="n">poly_deg</span><span class="p">,</span> <span class="n">wf_map</span><span class="p">):</span>
        <span class="n">p_all</span> <span class="o">=</span> <span class="n">get_p</span><span class="p">(</span><span class="n">p_var</span><span class="p">,</span> <span class="n">p_fix</span><span class="p">,</span> <span class="n">p_ind</span><span class="p">)</span>
        <span class="n">model_map</span> <span class="o">=</span> <span class="n">model_phase_map</span><span class="p">(</span><span class="n">p_all</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">calib_laser_nm</span><span class="p">,</span> <span class="n">pixel_size</span><span class="p">,</span>
                                    <span class="n">poly_deg</span><span class="p">,</span> <span class="n">wf_map</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">model_map</span> <span class="o">-</span> <span class="n">pm</span><span class="p">)</span> <span class="o">/</span> <span class="n">pm_err</span>
        <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">result</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">result</span><span class="p">))]</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">print_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">p_ind</span><span class="p">,</span> <span class="n">poly_deg</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">str_fix</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">p_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39;(fixed)&#39;</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="s1">&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">ang</span><span class="p">(</span><span class="n">_a</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">fmod</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">_a</span><span class="p">),</span><span class="mf">360.</span><span class="p">)</span>

        <span class="n">poly_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;a</span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1"> radians </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">params</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">str_fix</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">poly_deg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
        <span class="n">_i</span> <span class="o">=</span> <span class="n">poly_deg</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s1">&#39;&gt; Phase map fit parameters:</span><span class="se">\n</span><span class="s1">&#39;</span>
               <span class="o">+</span> <span class="n">poly_str</span>
               <span class="o">+</span> <span class="s1">&#39;distance to mirror: </span><span class="si">{}</span><span class="s1"> cm </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                   <span class="n">params</span><span class="p">[</span><span class="n">_i</span><span class="p">]</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">str_fix</span><span class="p">(</span><span class="n">_i</span><span class="p">))</span>
               <span class="o">+</span> <span class="s1">&#39;X angle from the optical axis: </span><span class="si">{}</span><span class="s1"> degrees </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                   <span class="n">ang</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">_i</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> <span class="n">str_fix</span><span class="p">(</span><span class="n">_i</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
               <span class="o">+</span> <span class="s1">&#39;Y angle from the optical axis: </span><span class="si">{}</span><span class="s1"> degrees </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                   <span class="n">ang</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">_i</span><span class="o">+</span><span class="mi">2</span><span class="p">]),</span> <span class="n">str_fix</span><span class="p">(</span><span class="n">_i</span><span class="o">+</span><span class="mi">2</span><span class="p">))</span>
               <span class="o">+</span> <span class="s1">&#39;Tilt along X: </span><span class="si">{}</span><span class="s1"> degrees </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                   <span class="n">ang</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">_i</span><span class="o">+</span><span class="mi">3</span><span class="p">]),</span> <span class="n">str_fix</span><span class="p">(</span><span class="n">_i</span><span class="o">+</span><span class="mi">3</span><span class="p">))</span>
               <span class="o">+</span> <span class="s1">&#39;Tilt along Y: </span><span class="si">{}</span><span class="s1"> degrees </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                   <span class="n">ang</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">_i</span><span class="o">+</span><span class="mi">4</span><span class="p">]),</span> <span class="n">str_fix</span><span class="p">(</span><span class="n">_i</span><span class="o">+</span><span class="mi">4</span><span class="p">))</span>
               <span class="o">+</span> <span class="s1">&#39;Rotation angle: </span><span class="si">{}</span><span class="s1"> degrees </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                   <span class="n">ang</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">_i</span><span class="o">+</span><span class="mi">5</span><span class="p">]),</span> <span class="n">str_fix</span><span class="p">(</span><span class="n">_i</span><span class="o">+</span><span class="mi">5</span><span class="p">)))</span>

    <span class="c1"># WARNING: CROP_COEFF must correspond to the CROP_COEFF used in</span>
    <span class="c1"># fit_highorder_phase_map</span>
    <span class="n">CROP_COEFF</span> <span class="o">=</span> <span class="mf">0.98</span> <span class="c1"># proportion of the phase map to keep when</span>
                      <span class="c1"># cropping</span>

    <span class="n">POLY_DEG</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># degree of the polyomial used to transform a</span>
                 <span class="c1"># calibration map in a phase map</span>

    <span class="c1"># bad values are filtered and phase map is cropped to remove</span>
    <span class="c1"># borders with erroneous phase values.</span>
    <span class="n">phase_map</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">phase_map</span><span class="o">==</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">uncropped_phase_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">phase_map</span><span class="p">)</span>

    <span class="n">xmin</span><span class="p">,</span><span class="n">xmax</span><span class="p">,</span><span class="n">ymin</span><span class="p">,</span><span class="n">ymax</span> <span class="o">=</span> <span class="n">get_box_coords</span><span class="p">(</span>
        <span class="n">phase_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
        <span class="n">phase_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span>
        <span class="nb">int</span><span class="p">(</span><span class="n">CROP_COEFF</span><span class="o">*</span><span class="n">phase_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">phase_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">phase_map</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">phase_map</span><span class="p">[:</span><span class="n">xmin</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">phase_map</span><span class="p">[</span><span class="n">xmax</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">phase_map</span><span class="p">[:,:</span><span class="n">ymin</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">phase_map</span><span class="p">[:,</span><span class="n">ymax</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">if</span> <span class="n">wavefront_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wavefront_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">phase_map</span><span class="p">)</span>
    
    <span class="c1"># Data is binned to accelerate the fit</span>
    <span class="k">if</span> <span class="n">binning</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span> <span class="s1">&#39;&gt; Binning phase maps&#39;</span>
        <span class="n">phase_map_bin</span> <span class="o">=</span> <span class="n">nanbin_image</span><span class="p">(</span><span class="n">phase_map</span><span class="p">,</span> <span class="n">binning</span><span class="p">)</span>
        <span class="n">phase_map_err_bin</span> <span class="o">=</span> <span class="n">nanbin_image</span><span class="p">(</span><span class="n">phase_map_err</span><span class="p">,</span> <span class="n">binning</span><span class="p">)</span>
        <span class="n">calib_laser_map_bin</span> <span class="o">=</span> <span class="n">nanbin_image</span><span class="p">(</span><span class="n">calib_laser_map</span><span class="p">,</span> <span class="n">binning</span><span class="p">)</span>
        <span class="n">wavefront_map_bin</span> <span class="o">=</span> <span class="n">nanbin_image</span><span class="p">(</span><span class="n">wavefront_map</span><span class="p">,</span> <span class="n">binning</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">phase_map_bin</span> <span class="o">=</span> <span class="n">phase_map</span>
        <span class="n">phase_map_err_bin</span> <span class="o">=</span> <span class="n">phase_map_err</span>
        <span class="n">calib_laser_map_bin</span> <span class="o">=</span> <span class="n">calib_laser_map</span>
        <span class="n">wavefront_map_bin</span> <span class="o">=</span> <span class="n">wavefront_map</span>

    <span class="n">calib_laser_map_bin</span> <span class="o">-=</span> <span class="n">wavefront_map_bin</span>

    <span class="c1"># ref calibration laser map fit</span>
    <span class="n">calib_fit_params</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">fit_calibration_laser_map</span><span class="p">(</span>
        <span class="n">calib_laser_map_bin</span><span class="p">,</span> <span class="n">calib_laser_nm</span><span class="p">,</span>
        <span class="n">pixel_size</span><span class="o">=</span><span class="n">pixel_size</span><span class="o">*</span><span class="n">binning</span><span class="p">,</span>
        <span class="n">binning</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">return_model_fit</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="nb">print</span> <span class="s1">&#39;&gt; Phase map fit&#39;</span>
    <span class="c1">## 0: a0</span>
    <span class="c1">## 1: a1</span>
    <span class="c1">## 2: mirror_distance</span>
    <span class="c1">## 3: theta_cx</span>
    <span class="c1">## 4: theta_cy</span>
    <span class="c1">## 5: phi_x</span>
    <span class="c1">## 6: phi_y</span>
    <span class="c1">## 7: phi_r    </span>

    <span class="c1"># first fit of the linear parameters</span>
    <span class="n">p_ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">POLY_DEG</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">p_fix</span> <span class="o">=</span> <span class="n">calib_fit_params</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">fit</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span><span class="n">diff_phase_map</span><span class="p">,</span>
                                 <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
                                 <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">calib_laser_map_bin</span><span class="p">,</span>
                                       <span class="n">calib_laser_nm</span><span class="p">,</span>
                                       <span class="nb">float</span><span class="p">(</span><span class="n">pixel_size</span><span class="o">*</span><span class="n">binning</span><span class="p">),</span>
                                       <span class="n">phase_map_bin</span><span class="p">,</span>
                                       <span class="n">phase_map_err_bin</span><span class="p">,</span>
                                       <span class="n">p_fix</span><span class="p">,</span> <span class="n">p_ind</span><span class="p">,</span> <span class="n">POLY_DEG</span><span class="p">,</span>
                                       <span class="n">wavefront_map_bin</span><span class="p">),</span>
                                 <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">params</span> <span class="o">=</span> <span class="n">get_p</span><span class="p">(</span><span class="n">fit</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p_fix</span><span class="p">,</span> <span class="n">p_ind</span><span class="p">)</span>
    <span class="n">print_params</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">p_ind</span><span class="p">,</span> <span class="n">POLY_DEG</span><span class="p">)</span>
    <span class="n">res_phase_map</span> <span class="o">=</span> <span class="n">phase_map</span> <span class="o">-</span> <span class="n">model_phase_map</span><span class="p">(</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">calib_laser_map</span><span class="p">,</span> <span class="n">calib_laser_nm</span><span class="p">,</span> <span class="n">pixel_size</span><span class="p">,</span> <span class="n">POLY_DEG</span><span class="p">,</span>
        <span class="n">wavefront_map</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s1">&#39;residual std: </span><span class="si">{}</span><span class="s1"> (flux error: </span><span class="si">{}</span><span class="s1">%)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">res_phase_map</span><span class="p">),</span>
        <span class="mi">100</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">res_phase_map</span><span class="p">))))</span>


    <span class="c1">## # second fit</span>
    <span class="c1">## p_ind = np.array(list([1])*(POLY_DEG+1) + [1,0,1,1,1,0])</span>
    <span class="c1">## p_fix = params[p_ind.astype(bool)]</span>
    <span class="c1">## p_var = params[~p_ind.astype(bool)]</span>
    <span class="c1">## fit = scipy.optimize.leastsq(diff_phase_map,</span>
    <span class="c1">##                              p_var,</span>
    <span class="c1">##                              args=(calib_laser_map_bin,</span>
    <span class="c1">##                                    calib_laser_nm,</span>
    <span class="c1">##                                    float(pixel_size*binning),</span>
    <span class="c1">##                                    phase_map_bin,</span>
    <span class="c1">##                                    phase_map_err_bin,</span>
    <span class="c1">##                                    p_fix, p_ind, POLY_DEG,</span>
    <span class="c1">##                                    wavefront_map_bin),</span>
    <span class="c1">##                              full_output=True)</span>
    <span class="c1">## params = get_p(fit[0], p_fix, p_ind)</span>
    <span class="c1">## print_params(params, p_ind, POLY_DEG)</span>
    <span class="c1">## res_phase_map = phase_map - model_phase_map(</span>
    <span class="c1">##     params, calib_laser_map, calib_laser_nm, pixel_size, POLY_DEG,</span>
    <span class="c1">##     wavefront_map)</span>
    <span class="c1">## print &#39;residual std: {} (flux error: {}%)&#39;.format(</span>
    <span class="c1">##     np.nanstd(res_phase_map),</span>
    <span class="c1">##     100 * (1. - np.cos(np.nanstd(res_phase_map))))</span>

    <span class="c1">## # third fit</span>
    <span class="c1">## p_ind = np.array(list([0])*(POLY_DEG+1) + [1,0,0,1,1,0])   </span>
    <span class="c1">## p_fix = params[p_ind.astype(bool)]</span>
    <span class="c1">## p_var = params[~p_ind.astype(bool)]</span>
    <span class="c1">## fit = scipy.optimize.leastsq(diff_phase_map,</span>
    <span class="c1">##                              p_var,</span>
    <span class="c1">##                              args=(calib_laser_map_bin,</span>
    <span class="c1">##                                    calib_laser_nm,</span>
    <span class="c1">##                                    float(pixel_size*binning),</span>
    <span class="c1">##                                    phase_map_bin,</span>
    <span class="c1">##                                    phase_map_err_bin,</span>
    <span class="c1">##                                    p_fix, p_ind, POLY_DEG,</span>
    <span class="c1">##                                    wavefront_map_bin),</span>
    <span class="c1">##                              full_output=True)</span>
    <span class="c1">## params = get_p(fit[0], p_fix, p_ind)</span>
    <span class="c1">## print_params(params, p_ind, POLY_DEG)</span>
    <span class="c1">## res_phase_map = phase_map - model_phase_map(</span>
    <span class="c1">##     params, calib_laser_map, calib_laser_nm, pixel_size, POLY_DEG,</span>
    <span class="c1">##     wavefront_map)</span>
    <span class="c1">## print &#39;residual std: {} (flux error: {}%)&#39;.format(</span>
    <span class="c1">##     np.nanstd(res_phase_map),</span>
    <span class="c1">##     100 * (1. - np.cos(np.nanstd(res_phase_map))))</span>

    
    <span class="n">fitted_phase_map</span> <span class="o">=</span> <span class="n">model_phase_map</span><span class="p">(</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">calib_laser_map</span><span class="p">,</span> <span class="n">calib_laser_nm</span><span class="p">,</span> <span class="n">pixel_size</span><span class="p">,</span> <span class="n">POLY_DEG</span><span class="p">,</span>
        <span class="n">wavefront_map</span><span class="p">)</span>

    <span class="c1">## computed calibration laser map from instrumental parameters</span>
    <span class="c1">## deduced from the phase map fit. If the wavefront is added, this</span>
    <span class="c1">## calibration laser map might be used for a better wavelength</span>
    <span class="c1">## calibration.</span>
    <span class="n">new_calib_laser_map</span> <span class="o">=</span> <span class="p">(</span><span class="n">model_laser_map</span><span class="p">(</span>
        <span class="n">params</span><span class="p">[</span><span class="n">POLY_DEG</span> <span class="o">+</span><span class="mi">1</span><span class="p">:],</span> <span class="n">calib_laser_map</span><span class="p">,</span> <span class="n">calib_laser_nm</span><span class="p">,</span> <span class="n">pixel_size</span><span class="p">)</span>
                           <span class="o">+</span> <span class="n">wavefront_map</span><span class="p">)</span>
    
    <span class="c1"># Residual fit</span>
    <span class="nb">print</span> <span class="s1">&#39;&gt; Phase map residuals fit with cos theta fit&#39;</span>
   
    <span class="n">res_phase_map</span> <span class="o">=</span> <span class="n">uncropped_phase_map</span> <span class="o">-</span> <span class="n">fitted_phase_map</span>
    
    <span class="n">res_phase_map_fit</span><span class="p">,</span> <span class="n">_err_map</span><span class="p">,</span> <span class="n">_fit_error</span> <span class="o">=</span> <span class="n">fit_map_cos</span><span class="p">(</span>
        <span class="n">res_phase_map</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">res_phase_map</span><span class="p">),</span>
        <span class="n">new_calib_laser_map</span><span class="p">,</span> <span class="n">calib_laser_nm</span><span class="p">,</span> <span class="n">knb</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
    
    <span class="n">fitted_phase_map</span> <span class="o">+=</span> <span class="n">res_phase_map_fit</span>

    <span class="c1">## Error computation</span>
    <span class="c1"># Creation of the error map: The error map gives the </span>
    <span class="c1"># Squared Error for each point used in the fit point. </span>
    <span class="n">error_map</span> <span class="o">=</span> <span class="n">phase_map</span> <span class="o">-</span> <span class="n">fitted_phase_map</span>
    <span class="n">error_map</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">phase_map</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    

    <span class="c1"># The square root of the mean of this map is then normalized</span>
    <span class="c1"># by the range of the values fitted. This gives the Normalized</span>
    <span class="c1"># root-mean-square deviation</span>
    <span class="n">fit_error_rms</span> <span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">error_map</span><span class="o">**</span><span class="mf">2.</span><span class="p">))</span>
                <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">phase_map</span><span class="p">,</span> <span class="mi">84</span><span class="p">)</span>
                   <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">phase_map</span><span class="p">,</span> <span class="mi">16</span><span class="p">)))</span>

    <span class="n">fit_error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">error_map</span><span class="p">)</span>

    <span class="nb">print</span> <span class="s1">&#39;&gt; Final fit std: </span><span class="si">{}</span><span class="s1"> radians&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fit_error</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_coeffs</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fitted_phase_map</span><span class="p">,</span> <span class="n">error_map</span><span class="p">,</span> <span class="n">fit_error_rms</span><span class="p">,</span> <span class="n">new_calib_laser_map</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fitted_phase_map</span><span class="p">,</span> <span class="n">error_map</span><span class="p">,</span> <span class="n">fit_error_rms</span><span class="p">,</span> <span class="n">new_calib_laser_map</span><span class="p">,</span> <span class="p">[</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span></div>


<div class="viewcode-block" id="fit_phase_map02calib_map"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.fit_phase_map02calib_map">[docs]</a><span class="k">def</span> <span class="nf">fit_phase_map02calib_map</span><span class="p">(</span><span class="n">calib</span><span class="p">,</span> <span class="n">pm0</span><span class="p">,</span> <span class="n">nm_laser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the best transformation parameters that permit to</span>
<span class="sd">    compute an order 0 phase map from a calibration laser map</span>

<span class="sd">    :param calib: Calibration laser map</span>

<span class="sd">    :param pm0: Order 0 phase map</span>

<span class="sd">    :param nm_laser: Calibration laser wavelength in nm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">pm0</span><span class="p">,</span> <span class="n">nm_laser</span><span class="p">):</span>
        
        <span class="n">res</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">calib_map2phase_map0</span><span class="p">(</span>
            <span class="n">p</span><span class="p">,</span> <span class="n">calib</span><span class="p">,</span> <span class="n">nm_laser</span><span class="p">)</span> <span class="o">-</span> <span class="n">pm0</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">res</span><span class="p">))]</span>

    <span class="n">p0</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>

    <span class="n">fit</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span>
        <span class="n">diff</span><span class="p">,</span> <span class="n">p0</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">calib</span><span class="p">,</span> <span class="n">pm0</span><span class="p">,</span> <span class="n">nm_laser</span><span class="p">),</span>
        <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Phase map 2 calibration laser map fit failed: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">fit</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="unwrap_phase_map0"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.unwrap_phase_map0">[docs]</a><span class="k">def</span> <span class="nf">unwrap_phase_map0</span><span class="p">(</span><span class="n">phase_map</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Phase is defined modulo pi/2. The Unwrapping is a</span>
<span class="sd">    reconstruction of the phase so that the distance between two</span>
<span class="sd">    neighboor pixels is always less than pi/4. Then the real</span>
<span class="sd">    phase pattern can be recovered and fitted easily.</span>
<span class="sd">    </span>
<span class="sd">    The idea is the same as with np.unwrap() but in 2D, on a</span>
<span class="sd">    possibly very noisy map, where a naive 2d unwrapping cannot</span>
<span class="sd">    be done.</span>

<span class="sd">    :param phase_map: Order 0 phase map.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">BIN_SIZE</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">LINE_SIZE</span> <span class="o">=</span> <span class="mi">30</span>

    <span class="k">def</span> <span class="nf">unwrap</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="n">target</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">val</span>  <span class="o">-</span> <span class="n">target</span> <span class="o">&gt;</span> <span class="mf">0.</span> <span class="p">:</span>
                <span class="n">val</span> <span class="o">-=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">+=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">return</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">unwrap_columns</span><span class="p">(</span><span class="n">pm0</span><span class="p">,</span> <span class="n">bin_size</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pm0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">ij</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pm0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">colbin</span> <span class="o">=</span> <span class="n">pm0</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="n">ij</span><span class="p">:</span><span class="n">ij</span><span class="o">+</span><span class="n">bin_size</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">colbin_med</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">colbin</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">colbin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">colbin</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">unwrap</span><span class="p">(</span><span class="n">colbin</span><span class="p">[</span><span class="n">ik</span><span class="p">],</span> <span class="n">colbin_med</span><span class="p">)</span>
                <span class="n">pm0</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="n">ij</span><span class="p">:</span><span class="n">ij</span><span class="o">+</span><span class="n">bin_size</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">colbin</span>
        <span class="k">return</span> <span class="n">pm0</span>

    <span class="k">def</span> <span class="nf">unwrap_all</span><span class="p">(</span><span class="n">pm0</span><span class="p">,</span> <span class="n">bin_size</span><span class="p">):</span>
        <span class="n">test_line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span>
            <span class="n">pm0</span><span class="p">[:,</span> <span class="n">pm0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="n">LINE_SIZE</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span><span class="n">pm0</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">LINE_SIZE</span><span class="o">/</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">test_line_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">test_line</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">test_line</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">bin_size</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">linebin</span> <span class="o">=</span> <span class="n">test_line</span><span class="p">[</span><span class="n">ii</span><span class="p">:</span><span class="n">ii</span><span class="o">+</span><span class="n">bin_size</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">linebin_med</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sigmacut</span><span class="p">(</span>
                <span class="n">linebin</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">linebin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">linebin</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">=</span> <span class="n">unwrap</span><span class="p">(</span><span class="n">linebin</span><span class="p">[</span><span class="n">ik</span><span class="p">],</span> <span class="n">linebin_med</span><span class="p">)</span>
            <span class="n">test_line</span><span class="p">[</span><span class="n">ii</span><span class="p">:</span><span class="n">ii</span><span class="o">+</span><span class="n">bin_size</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">linebin</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">test_line</span> <span class="o">-</span> <span class="n">test_line_init</span>
        <span class="n">pm0</span> <span class="o">=</span> <span class="p">(</span><span class="n">pm0</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">diff</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">pm0</span>

    <span class="c1"># unwrap pixels along columns</span>
    <span class="n">phase_map</span> <span class="o">=</span> <span class="n">unwrap_columns</span><span class="p">(</span><span class="n">phase_map</span><span class="p">,</span> <span class="n">BIN_SIZE</span><span class="p">)</span>
    <span class="c1"># unwrap columns along a line</span>
    <span class="n">phase_map</span> <span class="o">=</span> <span class="n">unwrap_all</span><span class="p">(</span><span class="n">phase_map</span><span class="p">,</span> <span class="n">BIN_SIZE</span><span class="p">)</span>

    <span class="n">phase_map</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">phase_map</span><span class="p">))]</span> <span class="o">=</span> <span class="mf">0.</span>

    <span class="k">return</span> <span class="n">phase_map</span></div>

        
<div class="viewcode-block" id="interpolate_map"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.interpolate_map">[docs]</a><span class="k">def</span> <span class="nf">interpolate_map</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">dimx</span><span class="p">,</span> <span class="n">dimy</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interpolate 2D data map.</span>

<span class="sd">    This function is robust to Nans.</span>
<span class="sd">    </span>
<span class="sd">    .. warning:: The interpolation process is much longer if Nans are</span>
<span class="sd">       present in the map.</span>
<span class="sd">    </span>
<span class="sd">    :param m: Map</span>
<span class="sd">    </span>
<span class="sd">    :param dimx: X dimension of the result</span>
<span class="sd">    </span>
<span class="sd">    :param dimy: Y dimension of the result</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dimx</span><span class="p">,</span>
                        <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">y_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dimy</span><span class="p">,</span>
                        <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">x_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">y_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">interp</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">RectBivariateSpline</span><span class="p">(</span><span class="n">x_map</span><span class="p">,</span> <span class="n">y_map</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">interp</span><span class="p">(</span><span class="n">x_int</span><span class="p">,</span> <span class="n">y_int</span><span class="p">)</span></div>



<div class="viewcode-block" id="on_ellipse"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.on_ellipse">[docs]</a><span class="k">def</span> <span class="nf">on_ellipse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">rX</span><span class="p">,</span> <span class="n">rY</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Tell whether a pixel is on the ellipse or not.</span>

<span class="sd">    :param x: X position of the point</span>
<span class="sd">    :param y: Y position of the point</span>
<span class="sd">    :param x0: X position of the center</span>
<span class="sd">    :parma y0: Y position of the center</span>
<span class="sd">    :param theta: Angle of the ellipse (in deg)</span>
<span class="sd">    :param rX: Radius of the X axis</span>
<span class="sd">    :param rY: Radius of the Y axis</span>
<span class="sd">    :param e: (Optional) Precision in pixels (default 0.5).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">/</span> <span class="mi">180</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">e</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">rX</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">rY</span><span class="p">)</span> <span class="c1"># ellipticity</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="o">**</span><span class="mf">2.</span> <span class="o">+</span> <span class="p">(</span><span class="n">e</span><span class="o">*</span><span class="n">Y</span><span class="p">)</span><span class="o">**</span><span class="mf">2.</span><span class="p">)</span> <span class="o">-</span> <span class="n">rX</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">e</span></div>


<div class="viewcode-block" id="in_ellipse"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.in_ellipse">[docs]</a><span class="k">def</span> <span class="nf">in_ellipse</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">rX</span><span class="p">,</span> <span class="n">rY</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Tell whether a pixel is in the ellipse or not.</span>

<span class="sd">    :param x: X position of the point</span>
<span class="sd">    :param y: Y position of the point</span>
<span class="sd">    :param x0: X position of the center</span>
<span class="sd">    :parma y0: Y position of the center</span>
<span class="sd">    :param theta: Angle of the ellipse (in deg)</span>
<span class="sd">    :param rX: Radius of the X axis</span>
<span class="sd">    :param rY: Radius of the Y axis</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">/</span> <span class="mf">180.</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">e</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">rX</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">rY</span><span class="p">)</span> <span class="c1"># ellipticity</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">X</span><span class="o">**</span><span class="mf">2.</span> <span class="o">+</span> <span class="p">(</span><span class="n">e</span><span class="o">*</span><span class="n">Y</span><span class="p">)</span><span class="o">**</span><span class="mf">2.</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">rX</span></div>

<div class="viewcode-block" id="extract_elliptical_profile"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.extract_elliptical_profile">[docs]</a><span class="k">def</span> <span class="nf">extract_elliptical_profile</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">rX</span><span class="p">,</span> <span class="n">rY</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">percentile</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Extract the elliptical profile of a source</span>

<span class="sd">    :param im: Image</span>
<span class="sd">    :param x0: X position of the center</span>
<span class="sd">    :parma y0: Y position of the center</span>
<span class="sd">    :param theta: Angle of the ellipse (in deg)</span>
<span class="sd">    :param rX: Radius of the X axis</span>
<span class="sd">    :param rY: Radius of the Y axis</span>
<span class="sd">    :param n: (Optional) Number of divisions (default 20)</span>
<span class="sd">    </span>
<span class="sd">    :param percentile: (Optional) percentile instead of std. Return</span>
<span class="sd">      (r, lmedian, [lmin, lmax]). Remember that the 1-sigma percentile</span>
<span class="sd">      is 15.865 for a gaussian distribution (default None).</span>
<span class="sd">    </span>

<span class="sd">    :return: a tuple (r, l, lerr) where r is the list of radiuses</span>
<span class="sd">      along rX, l the mean luminosity in the ellipse portion</span>
<span class="sd">      corresponding to the radius, lerr the standard deviation of the</span>
<span class="sd">      luminosity in the same portion of the ellipse.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">im</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">:</span><span class="n">im</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">lerr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">r</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">coeffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">in_ellipse</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">rX</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">rY</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">-=</span> <span class="n">in_ellipse</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">rX</span><span class="p">,</span> <span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">rY</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span>
            <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">rX</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coeffs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">rX</span><span class="p">)</span>
        <span class="n">l</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmedian</span><span class="p">(</span><span class="n">im</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">percentile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lerr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">im</span><span class="p">[</span><span class="n">mask</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lerr</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
                <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">im</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">percentile</span><span class="p">),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">im</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="mf">100.</span> <span class="o">-</span> <span class="n">percentile</span><span class="p">)])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lerr</span><span class="p">)</span></div>
      
    
<div class="viewcode-block" id="bf_laser_aligner"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.image.bf_laser_aligner">[docs]</a><span class="k">def</span> <span class="nf">bf_laser_aligner</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span> <span class="n">im2</span><span class="p">,</span> <span class="n">init_dx</span><span class="p">,</span> <span class="n">init_dy</span><span class="p">,</span> <span class="n">init_angle</span><span class="p">,</span> <span class="n">zf</span><span class="p">,</span>  <span class="n">binning</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Align two complementary laser frames (i.e. cam1 and cam2) with</span>
<span class="sd">    a brute force algorithm.</span>

<span class="sd">    :param im1: frame 1</span>
<span class="sd">    </span>
<span class="sd">    :param im2: frame 2</span>
<span class="sd">    </span>
<span class="sd">    :param init_dx: Initial alignement parameter along X axis</span>
<span class="sd">    </span>
<span class="sd">    :param init_dy: Initial alignement parameter along Y axis</span>
<span class="sd">    </span>
<span class="sd">    :param init_angle: Initial angle</span>

<span class="sd">    :param zf: Zoom factor</span>

<span class="sd">    :param binning: Binning of the data for the first pass</span>

<span class="sd">    .. warning:: This function returns parameters much different that</span>
<span class="sd">      the alignement parameters we get from stars... I don&#39;t know why</span>
<span class="sd">      !</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">im2</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">zf</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        
        <span class="n">iarr</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">transform_frame</span><span class="p">(</span>
            <span class="n">im2</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span>
            <span class="n">d</span><span class="p">,</span> <span class="p">(</span><span class="n">im2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span><span class="p">,</span> <span class="n">im2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span><span class="p">),</span> <span class="n">zf</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">im2_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">im2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">im2_t</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">im2_t</span><span class="p">[</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">]</span> <span class="o">=</span> <span class="n">iarr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">iarr</span><span class="p">)):</span>
                <span class="n">im2_t</span><span class="p">[</span><span class="n">xmin</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">xmax</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ymin</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">ymax</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">iarr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    
        <span class="k">return</span> <span class="n">im2_t</span>


    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">im1</span><span class="p">,</span> <span class="n">im2</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">zf</span> <span class="o">=</span> <span class="n">args</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">im1</span> <span class="o">+</span> <span class="n">model</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">im2</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">zf</span><span class="p">))</span>
        <span class="nb">print</span> <span class="n">p</span><span class="p">,</span> <span class="n">res</span>
        <span class="k">return</span> <span class="n">res</span>
    
    <span class="k">def</span> <span class="nf">get_coords</span><span class="p">(</span><span class="n">grid_len</span><span class="p">,</span> <span class="n">box_size</span><span class="p">,</span> <span class="n">im1</span><span class="p">):</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="n">ixs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">im1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">grid_len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">ixs</span> <span class="o">=</span> <span class="n">ixs</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">iys</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">im1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">grid_len</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">iys</span> <span class="o">=</span> <span class="n">iys</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="n">ixs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="n">iys</span><span class="p">:</span>
                <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">get_box_coords</span><span class="p">(</span>
                        <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">box_size</span><span class="p">,</span>
                        <span class="mi">0</span><span class="p">,</span> <span class="n">im1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                        <span class="mi">0</span><span class="p">,</span> <span class="n">im1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span>

    <span class="k">def</span> <span class="nf">bf_by_angle</span><span class="p">(</span><span class="n">im1_mod</span><span class="p">,</span> <span class="n">im2</span><span class="p">,</span> <span class="n">init_dx</span><span class="p">,</span> <span class="n">init_dy</span><span class="p">,</span> <span class="n">iangle</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">bf_range</span><span class="p">,</span> <span class="n">zf</span><span class="p">):</span>

        <span class="n">_xmin</span><span class="p">,</span> <span class="n">_xmax</span><span class="p">,</span> <span class="n">_ymin</span><span class="p">,</span> <span class="n">_ymax</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">get_box_coords</span><span class="p">(</span>
            <span class="n">im2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">im2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">im2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">bf_range</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span> <span class="n">im2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="mi">0</span><span class="p">,</span> <span class="n">im2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">_res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>        
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">bf_range</span><span class="p">,</span> <span class="n">bf_range</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">test</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">idy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">bf_range</span><span class="p">,</span> <span class="n">bf_range</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">imod</span> <span class="o">=</span> <span class="n">model</span><span class="p">([</span><span class="n">init_dx</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,</span> <span class="n">init_dy</span> <span class="o">+</span> <span class="n">idy</span><span class="p">,</span> <span class="n">iangle</span><span class="p">],</span>
                     <span class="n">im2</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">zf</span><span class="p">)</span>
                <span class="n">_imod</span> <span class="o">=</span> <span class="n">imod</span><span class="p">[</span><span class="n">_xmin</span><span class="p">:</span><span class="n">_xmax</span><span class="p">,</span> <span class="n">_ymin</span><span class="p">:</span><span class="n">_ymax</span><span class="p">]</span>
                <span class="n">_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">im1_mod</span> <span class="o">+</span><span class="n">_imod</span><span class="p">)</span>
                <span class="n">_res</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">_std</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">idy</span><span class="p">,</span> <span class="n">iangle</span><span class="p">))</span>
                <span class="n">test</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_std</span><span class="p">)</span>
            <span class="nb">print</span> <span class="n">iangle</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">test</span><span class="p">),</span> <span class="n">test</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">test</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">_res</span>    
        
    <span class="n">BF_RANGE</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">10</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">binning</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">BF_R_RANGE</span> <span class="o">=</span> <span class="mf">1.</span>
    <span class="n">BF_R_STEPS</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">BF_R_RANGE</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">32</span>

    <span class="n">BF2_RANGE</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">binning</span>
    <span class="n">BF2_R_RANGE</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">BF_R_RANGE</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">BF_R_STEPS</span><span class="p">)</span>
    <span class="n">BF2_R_STEPS</span> <span class="o">=</span> <span class="mi">16</span>

    <span class="n">GRID_LEN</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">BOX_SIZE</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">XY_RANGE</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">XY_STEPS</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">XY_RANGE</span>
    <span class="n">R_RANGE</span> <span class="o">=</span> <span class="mf">0.2</span>
    <span class="n">R_STEPS</span> <span class="o">=</span> <span class="mi">5</span>

    <span class="c1"># first pass on binned data</span>
    <span class="n">im1_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">im1</span><span class="p">)</span>
    <span class="n">im1</span> <span class="o">=</span> <span class="n">nanbin_image</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span> <span class="n">binning</span><span class="p">)</span>
    <span class="n">im2_full</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">im2</span><span class="p">)</span>
    <span class="n">im2</span> <span class="o">=</span> <span class="n">nanbin_image</span><span class="p">(</span><span class="n">im2</span><span class="p">,</span> <span class="n">binning</span><span class="p">)</span>
    
    <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">im2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">im2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">init_angle</span> <span class="o">-</span> <span class="n">BF_R_RANGE</span><span class="p">,</span> <span class="n">init_angle</span> <span class="o">+</span> <span class="n">BF_R_RANGE</span><span class="p">,</span> <span class="n">BF_R_STEPS</span><span class="p">)</span>
    
    <span class="n">job_server</span><span class="p">,</span> <span class="n">ncpus</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">parallel</span><span class="o">.</span><span class="n">init_pp_server</span><span class="p">()</span>

    <span class="n">_xmin</span><span class="p">,</span> <span class="n">_xmax</span><span class="p">,</span> <span class="n">_ymin</span><span class="p">,</span> <span class="n">_ymax</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">get_box_coords</span><span class="p">(</span>
        <span class="n">im1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">im1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">im1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">BF_RANGE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">im1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">im1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">im1_mod</span> <span class="o">=</span> <span class="n">im1</span><span class="p">[</span><span class="n">_xmin</span><span class="p">:</span><span class="n">_xmax</span><span class="p">,</span> <span class="n">_ymin</span><span class="p">:</span><span class="n">_ymax</span><span class="p">]</span>

    <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">),</span> <span class="n">ncpus</span><span class="p">):</span>
        
        <span class="c1"># no more jobs than frames to compute</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ik</span> <span class="o">+</span> <span class="n">ncpus</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)):</span>
            <span class="n">ncpus</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">-</span> <span class="n">ik</span>

        <span class="nb">print</span> <span class="s1">&#39;computing angles from </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">angles</span><span class="p">[</span><span class="n">ik</span><span class="p">],</span> <span class="n">angles</span><span class="p">[</span><span class="n">ik</span> <span class="o">+</span> <span class="n">ncpus</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="nb">print</span> <span class="s1">&#39; &gt; computing dx from </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="p">(</span><span class="n">init_dx</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">binning</span><span class="p">)</span> <span class="o">-</span> <span class="n">BF_RANGE</span><span class="p">)</span> <span class="o">*</span> <span class="n">binning</span><span class="p">,</span>
            <span class="p">(</span><span class="n">init_dx</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">binning</span><span class="p">)</span> <span class="o">+</span> <span class="n">BF_RANGE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">binning</span><span class="p">)</span>
        <span class="nb">print</span> <span class="s1">&#39; &gt; computing dy from </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="p">(</span><span class="n">init_dy</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">binning</span><span class="p">)</span> <span class="o">-</span> <span class="n">BF_RANGE</span><span class="p">)</span> <span class="o">*</span> <span class="n">binning</span><span class="p">,</span>
            <span class="p">(</span><span class="n">init_dy</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">binning</span><span class="p">)</span> <span class="o">+</span> <span class="n">BF_RANGE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">binning</span><span class="p">)</span>

        <span class="n">jobs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ijob</span><span class="p">,</span> <span class="n">job_server</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
            <span class="n">bf_by_angle</span><span class="p">,</span> 
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">im1_mod</span><span class="p">,</span> <span class="n">im2</span><span class="p">,</span> <span class="n">init_dx</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">binning</span><span class="p">),</span>
                  <span class="n">init_dy</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">binning</span><span class="p">),</span>
                  <span class="n">angles</span><span class="p">[</span><span class="n">ik</span> <span class="o">+</span> <span class="n">ijob</span><span class="p">],</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">BF_RANGE</span><span class="p">,</span> <span class="n">zf</span><span class="p">),</span>
            <span class="n">modules</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;numpy as np&quot;</span><span class="p">,</span> 
                     <span class="s2">&quot;import orb.utils.image&quot;</span><span class="p">),</span>
            <span class="n">depfuncs</span><span class="o">=</span><span class="p">(</span><span class="n">model</span><span class="p">,)))</span>
                <span class="k">for</span> <span class="n">ijob</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncpus</span><span class="p">)]</span>
        
        <span class="k">for</span> <span class="n">ijob</span><span class="p">,</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">job</span><span class="p">()</span>
   
    <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">parallel</span><span class="o">.</span><span class="n">close_pp_server</span><span class="p">(</span><span class="n">job_server</span><span class="p">)</span>
    
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
    
    <span class="n">_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">res</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">best_init</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">_min</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span>

    <span class="n">init_dx</span> <span class="o">=</span> <span class="n">init_dx</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">binning</span><span class="p">)</span> <span class="o">+</span> <span class="n">best_init</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">init_dy</span> <span class="o">=</span> <span class="n">init_dy</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">binning</span><span class="p">)</span> <span class="o">+</span> <span class="n">best_init</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">init_angle</span> <span class="o">=</span> <span class="n">best_init</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">im1</span> <span class="o">=</span> <span class="n">im1_full</span>
    <span class="n">im2</span> <span class="o">=</span> <span class="n">im2_full</span>
    <span class="n">init_dx</span> <span class="o">*=</span> <span class="n">binning</span>
    <span class="n">init_dy</span> <span class="o">*=</span> <span class="n">binning</span>

    <span class="nb">print</span> <span class="s1">&#39;first pass best init parameters: &#39;</span><span class="p">,</span> <span class="n">init_dx</span><span class="p">,</span> <span class="n">init_dy</span><span class="p">,</span> <span class="n">init_angle</span>

    <span class="c1"># second pass on non-binnned data    </span>
    <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">im2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">im2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">init_angle</span> <span class="o">-</span> <span class="n">BF2_R_RANGE</span><span class="p">,</span> <span class="n">init_angle</span> <span class="o">+</span> <span class="n">BF2_R_RANGE</span><span class="p">,</span> <span class="n">BF2_R_STEPS</span><span class="p">)</span>
    
    <span class="n">job_server</span><span class="p">,</span> <span class="n">ncpus</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">parallel</span><span class="o">.</span><span class="n">init_pp_server</span><span class="p">()</span>

    <span class="n">_xmin</span><span class="p">,</span> <span class="n">_xmax</span><span class="p">,</span> <span class="n">_ymin</span><span class="p">,</span> <span class="n">_ymax</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">get_box_coords</span><span class="p">(</span>
        <span class="n">im1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">im1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">im1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">BF2_RANGE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">im1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">im1</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">im1_mod</span> <span class="o">=</span> <span class="n">im1</span><span class="p">[</span><span class="n">_xmin</span><span class="p">:</span><span class="n">_xmax</span><span class="p">,</span> <span class="n">_ymin</span><span class="p">:</span><span class="n">_ymax</span><span class="p">]</span>

    <span class="n">res</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">),</span> <span class="n">ncpus</span><span class="p">):</span>
        
        <span class="c1"># no more jobs than frames to compute</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ik</span> <span class="o">+</span> <span class="n">ncpus</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)):</span>
            <span class="n">ncpus</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span> <span class="o">-</span> <span class="n">ik</span>

        <span class="nb">print</span> <span class="s1">&#39;computing angles from </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">angles</span><span class="p">[</span><span class="n">ik</span><span class="p">],</span> <span class="n">angles</span><span class="p">[</span><span class="n">ik</span> <span class="o">+</span> <span class="n">ncpus</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="nb">print</span> <span class="s1">&#39; &gt; computing dx from </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">init_dx</span> <span class="o">-</span> <span class="n">BF2_RANGE</span><span class="p">,</span> <span class="n">init_dx</span> <span class="o">+</span> <span class="n">BF2_RANGE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nb">print</span> <span class="s1">&#39; &gt; computing dy from </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">init_dy</span> <span class="o">-</span> <span class="n">BF2_RANGE</span><span class="p">,</span> <span class="n">init_dy</span> <span class="o">+</span> <span class="n">BF2_RANGE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">jobs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ijob</span><span class="p">,</span> <span class="n">job_server</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span>
            <span class="n">bf_by_angle</span><span class="p">,</span> 
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">im1_mod</span><span class="p">,</span> <span class="n">im2</span><span class="p">,</span> <span class="n">init_dx</span><span class="p">,</span>
                  <span class="n">init_dy</span><span class="p">,</span>
                  <span class="n">angles</span><span class="p">[</span><span class="n">ik</span> <span class="o">+</span> <span class="n">ijob</span><span class="p">],</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">BF2_RANGE</span><span class="p">,</span> <span class="n">zf</span><span class="p">),</span>
            <span class="n">modules</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;numpy as np&quot;</span><span class="p">,</span> 
                     <span class="s2">&quot;import orb.utils.image&quot;</span><span class="p">),</span>
            <span class="n">depfuncs</span><span class="o">=</span><span class="p">(</span><span class="n">model</span><span class="p">,)))</span>
                <span class="k">for</span> <span class="n">ijob</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncpus</span><span class="p">)]</span>
        
        <span class="k">for</span> <span class="n">ijob</span><span class="p">,</span> <span class="n">job</span> <span class="ow">in</span> <span class="n">jobs</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">+=</span> <span class="n">job</span><span class="p">()</span>
    <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">parallel</span><span class="o">.</span><span class="n">close_pp_server</span><span class="p">(</span><span class="n">job_server</span><span class="p">)</span>
    
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
    
    <span class="n">_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">(</span><span class="n">res</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">best_init</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">_min</span><span class="p">,</span><span class="mi">1</span><span class="p">:]</span>
    
    <span class="n">init_dx</span> <span class="o">+=</span> <span class="n">best_init</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">init_dy</span> <span class="o">+=</span> <span class="n">best_init</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">init_angle</span> <span class="o">=</span> <span class="n">best_init</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

    <span class="nb">print</span> <span class="s1">&#39;second pass best init parameters: &#39;</span><span class="p">,</span> <span class="n">init_dx</span><span class="p">,</span> <span class="n">init_dy</span><span class="p">,</span> <span class="n">init_angle</span>
    
    <span class="c1"># finer pass</span>
    <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">get_coords</span><span class="p">(</span><span class="n">GRID_LEN</span><span class="p">,</span> <span class="n">BOX_SIZE</span><span class="p">,</span> <span class="n">im1</span><span class="p">)</span>
    <span class="nb">print</span> <span class="s1">&#39;finer brute force optimization&#39;</span>

    <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brute</span><span class="p">(</span>
        <span class="n">diff</span><span class="p">,</span>
        <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">init_dx</span> <span class="o">-</span> <span class="n">XY_RANGE</span><span class="p">,</span> <span class="n">init_dx</span> <span class="o">+</span> <span class="n">XY_RANGE</span><span class="p">,</span> <span class="n">XY_STEPS</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">),</span>
         <span class="nb">slice</span><span class="p">(</span><span class="n">init_dy</span> <span class="o">-</span> <span class="n">XY_RANGE</span><span class="p">,</span> <span class="n">init_dy</span> <span class="o">+</span> <span class="n">XY_RANGE</span><span class="p">,</span> <span class="n">XY_STEPS</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">),</span>
         <span class="nb">slice</span><span class="p">(</span><span class="n">init_angle</span> <span class="o">-</span> <span class="n">R_RANGE</span><span class="p">,</span> <span class="n">init_angle</span> <span class="o">+</span> <span class="n">R_RANGE</span><span class="p">,</span> <span class="n">R_STEPS</span> <span class="o">*</span> <span class="mi">1</span><span class="n">j</span><span class="p">)),</span>
        <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span> <span class="n">im2</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">zf</span><span class="p">))</span></div>

            
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Thomas Martin (thomas.martin.1@ulaval.ca).
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
    </div>

    

    
  </body>
</html>