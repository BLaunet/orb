<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>orb.utils.fft &#8212; orb 3.0.1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '3.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for orb.utils.fft</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/python</span>
<span class="c1"># *-* coding: utf-8 *-*</span>
<span class="c1"># Author: Thomas Martin &lt;thomas.martin.1@ulaval.ca&gt;</span>
<span class="c1"># File: fft.py</span>

<span class="c1">## Copyright (c) 2010-2016 Thomas Martin &lt;thomas.martin.1@ulaval.ca&gt;</span>
<span class="c1">## </span>
<span class="c1">## This file is part of ORB</span>
<span class="c1">##</span>
<span class="c1">## ORB is free software: you can redistribute it and/or modify it</span>
<span class="c1">## under the terms of the GNU General Public License as published by</span>
<span class="c1">## the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1">## (at your option) any later version.</span>
<span class="c1">##</span>
<span class="c1">## ORB is distributed in the hope that it will be useful, but WITHOUT</span>
<span class="c1">## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY</span>
<span class="c1">## or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public</span>
<span class="c1">## License for more details.</span>
<span class="c1">##</span>
<span class="c1">## You should have received a copy of the GNU General Public License</span>
<span class="c1">## along with ORB.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">import</span> <span class="nn">scipy.special</span> <span class="k">as</span> <span class="nn">ss</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">signal</span><span class="p">,</span> <span class="n">interpolate</span><span class="p">,</span> <span class="n">optimize</span>
<span class="kn">import</span> <span class="nn">gvar</span>

<span class="kn">import</span> <span class="nn">orb.utils.vector</span>
<span class="kn">import</span> <span class="nn">orb.utils.spectrum</span>
<span class="kn">import</span> <span class="nn">orb.utils.stats</span>
<span class="kn">import</span> <span class="nn">orb.utils.filters</span>
<span class="kn">import</span> <span class="nn">orb.cutils</span>
<span class="kn">import</span> <span class="nn">orb.constants</span>

<div class="viewcode-block" id="apodize"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.apodize">[docs]</a><span class="k">def</span> <span class="nf">apodize</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">apodization_function</span><span class="o">=</span><span class="mf">2.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apodize a spectrum</span>

<span class="sd">    :param s: Spectrum</span>
<span class="sd">    </span>
<span class="sd">    :param apodization_function: (Optional) A Norton-Beer apodization</span>
<span class="sd">      function (default 2.0)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s_ifft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">gaussian_window</span><span class="p">(</span><span class="n">apodization_function</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">w</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">s_ifft</span> <span class="o">*=</span> <span class="n">w</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">s_ifft</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">s_ifft</span><span class="p">)</span><span class="o">.</span><span class="n">real</span></div>

<div class="viewcode-block" id="find_zpd"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.find_zpd">[docs]</a><span class="k">def</span> <span class="nf">find_zpd</span><span class="p">(</span><span class="n">interf</span><span class="p">,</span> <span class="n">step_number</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">return_zpd_shift</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the index of the ZPD along the z axis.</span>

<span class="sd">    :param step_number: (Optional) If the full number of steps is</span>
<span class="sd">      greater than the number of frames of the cube. Useful when</span>
<span class="sd">      the interferograms are non symetric (default None).</span>

<span class="sd">    :param return_zpd_shift: (Optional) If True return ZPD shift</span>
<span class="sd">      instead of ZPD index (default False).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">step_number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dimz</span> <span class="o">=</span> <span class="n">step_number</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dimz</span> <span class="o">=</span> <span class="n">interf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">interf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">interf</span><span class="p">)</span>
    <span class="c1"># correct vector for zeros</span>
    <span class="n">interf</span><span class="p">[</span>
        <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">interf</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">interf</span><span class="p">)</span>

    <span class="c1"># filtering vector to remove low and high frequency patterns (e.g. sunrise)</span>
    <span class="n">interf</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">fft_filter</span><span class="p">(</span><span class="n">interf</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">filter_type</span><span class="o">=</span><span class="s1">&#39;low_pass&#39;</span><span class="p">)</span>
    <span class="n">interf</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">fft_filter</span><span class="p">(</span><span class="n">interf</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">filter_type</span><span class="o">=</span><span class="s1">&#39;high_pass&#39;</span><span class="p">)</span>
    
    <span class="n">full_interf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dimz</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">full_interf</span><span class="p">[:</span><span class="n">interf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">interf</span>
    
    <span class="c1"># vector is weighted so that the center part is prefered</span>
    <span class="n">full_interf</span> <span class="o">*=</span> <span class="n">gaussian_window</span><span class="p">(</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">dimz</span><span class="p">)</span>
    
    <span class="c1"># absolute value of the vector</span>
    <span class="n">full_interf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">full_interf</span><span class="o">**</span><span class="mf">2.</span><span class="p">)</span>
    
    <span class="c1"># ZPD is defined to be at the maximum of the vector</span>
    <span class="n">zpd_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">full_interf</span><span class="p">)</span>

    <span class="c1">#zpd_shift = int(int(self.dimz/2.) - zpd_index + self.dimz%2)</span>
    <span class="n">zpd_shift</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">dimz</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span> <span class="o">-</span> <span class="n">zpd_index</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_zpd_shift</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">zpd_shift</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">zpd_index</span></div>


<div class="viewcode-block" id="count_nonzeros"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.count_nonzeros">[docs]</a><span class="k">def</span> <span class="nf">count_nonzeros</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the length of nonzeros parts in a vector as a vector of</span>
<span class="sd">    the same length with the length of each part at each occurence of</span>
<span class="sd">    a nonzero number.</span>

<span class="sd">    e.g. : if a = [0,0,0,1,1,0,1] this function returns: [0,0,0,2,2,0,1]</span>

<span class="sd">    :param a: A vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">iz</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">iz</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">counts</span><span class="p">[</span><span class="n">iz</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">end_count</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">il</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">end_count</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">iz</span><span class="o">+</span><span class="n">il</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="ow">or</span> <span class="n">a</span><span class="p">[</span><span class="n">iz</span><span class="o">+</span><span class="n">il</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">end_count</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">il</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">iz</span><span class="p">:</span><span class="n">iz</span><span class="o">+</span><span class="n">il</span><span class="p">]</span> <span class="o">=</span> <span class="n">il</span>
    <span class="k">return</span> <span class="n">counts</span></div>


<div class="viewcode-block" id="amplitude"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.amplitude">[docs]</a><span class="k">def</span> <span class="nf">amplitude</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the amplitude of a complex number&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">real</span><span class="o">**</span><span class="mf">2.</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">imag</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="phase"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.phase">[docs]</a><span class="k">def</span> <span class="nf">phase</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the phase of a complex number&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">real</span><span class="p">)</span></div>

<div class="viewcode-block" id="real"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.real">[docs]</a><span class="k">def</span> <span class="nf">real</span><span class="p">(</span><span class="n">amp</span><span class="p">,</span> <span class="n">pha</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the real part from amplitude and phase&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">amp</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">pha</span><span class="p">)</span> </div>

<div class="viewcode-block" id="imag"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.imag">[docs]</a><span class="k">def</span> <span class="nf">imag</span><span class="p">(</span><span class="n">amp</span><span class="p">,</span> <span class="n">pha</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the imaginary part from amplitude and phase&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">amp</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">pha</span><span class="p">)</span></div>

<div class="viewcode-block" id="next_power_of_two"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.next_power_of_two">[docs]</a><span class="k">def</span> <span class="nf">next_power_of_two</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the next power of two greater than n.</span>
<span class="sd">    </span>
<span class="sd">    :param n: The number from which the next power of two has to be</span>
<span class="sd">      computed. Can be an array of numbers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mf">2.</span><span class="o">**</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></div>

<div class="viewcode-block" id="raw_fft"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.raw_fft">[docs]</a><span class="k">def</span> <span class="nf">raw_fft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">apod</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_complex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">return_phase</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the raw FFT of a vector.</span>

<span class="sd">    Return the absolute value of the complex vector by default.</span>
<span class="sd">    </span>
<span class="sd">    :param x: Interferogram.</span>
<span class="sd">    </span>
<span class="sd">    :param apod: (Optional) Apodization function used. See</span>
<span class="sd">      :py:meth:`utils.norton_beer_window` (default None)</span>

<span class="sd">    :param inverse: (Optional) If True compute the inverse FFT</span>
<span class="sd">      (default False).</span>

<span class="sd">    :param return_complex: (Optional) If True, the complex vector is</span>
<span class="sd">      returned (default False).</span>

<span class="sd">    :param return_phase: (Optional) If True, the phase is</span>
<span class="sd">      returned.(default False)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">windows</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;1.1&#39;</span><span class="p">,</span> <span class="s1">&#39;1.2&#39;</span><span class="p">,</span> <span class="s1">&#39;1.3&#39;</span><span class="p">,</span> <span class="s1">&#39;1.4&#39;</span><span class="p">,</span> <span class="s1">&#39;1.5&#39;</span><span class="p">,</span>
               <span class="s1">&#39;1.6&#39;</span><span class="p">,</span> <span class="s1">&#39;1.7&#39;</span><span class="p">,</span> <span class="s1">&#39;1.8&#39;</span><span class="p">,</span> <span class="s1">&#39;1.9&#39;</span><span class="p">,</span> <span class="s1">&#39;2.0&#39;</span><span class="p">]</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># mean substraction</span>
    <span class="n">x</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    
    <span class="c1"># apodization</span>
    <span class="k">if</span> <span class="n">apod</span> <span class="ow">in</span> <span class="n">windows</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">*=</span> <span class="n">gaussian_window</span><span class="p">(</span><span class="n">apod</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">apod</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unknown apodization function try </span><span class="si">%s</span><span class="s2">&quot;</span><span class="o">%</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">windows</span><span class="p">))</span>
        
    <span class="c1"># zero padding</span>
    <span class="n">zv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">zv</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>

    <span class="c1"># zero the centerburst</span>
    <span class="n">zv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">zv</span><span class="p">,</span> <span class="n">zv</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="c1"># FFT</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">inverse</span><span class="p">:</span>
        <span class="n">x_fft</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">zv</span><span class="p">))[:</span><span class="n">N</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x_fft</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">zv</span><span class="p">))[:</span><span class="n">N</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="n">return_complex</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x_fft</span>
    <span class="k">elif</span> <span class="n">return_phase</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">x_fft</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x_fft</span><span class="p">)</span></div>
     
<div class="viewcode-block" id="cube_raw_fft"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.cube_raw_fft">[docs]</a><span class="k">def</span> <span class="nf">cube_raw_fft</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">apod</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute the raw FFT of a cube (the last axis</span>
<span class="sd">    beeing the interferogram axis)</span>

<span class="sd">    :param x: Interferogram cube</span>
<span class="sd">    </span>
<span class="sd">    :param apod: (Optional) Apodization function used. See</span>
<span class="sd">      :py:meth:`utils.gaussian_window` (default None)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="c1"># mean substraction</span>
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># apodization</span>
    <span class="k">if</span> <span class="n">apod</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">*=</span> <span class="n">gaussian_window</span><span class="p">(</span><span class="n">apod</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>

    <span class="c1"># zero padding</span>
    <span class="n">zv_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">zv_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span><span class="o">*</span><span class="mi">2</span>
    <span class="n">zv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">zv_shape</span><span class="p">)</span>
    <span class="n">zv</span><span class="p">[:,</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">):</span><span class="nb">int</span><span class="p">(</span><span class="n">N</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="c1"># FFT</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">zv</span><span class="p">))[::,:</span><span class="n">N</span><span class="p">])</span></div>

<div class="viewcode-block" id="norton_beer_window"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.norton_beer_window">[docs]</a><span class="k">def</span> <span class="nf">norton_beer_window</span><span class="p">(</span><span class="n">fwhm</span><span class="o">=</span><span class="s1">&#39;1.6&#39;</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an extended Norton-Beer window function (see [NAY2007]_).</span>

<span class="sd">    Returned window is symmetrical.</span>
<span class="sd">    </span>
<span class="sd">    :param fwhm: FWHM relative to the sinc function. Must be: 1.1,</span>
<span class="sd">       1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9 or 2.0. (default &#39;1.6&#39;)</span>
<span class="sd">       </span>
<span class="sd">    :param n: Number of points (default 1000)</span>

<span class="sd">    .. note:: Coefficients of the extended Norton-Beer functions</span>
<span class="sd">       apodizing functions [NAY2007]_ :</span>
<span class="sd">    </span>
<span class="sd">       ==== ======== ========= ======== ======== ======== ======== </span>
<span class="sd">       FWHM    C0       C1        C2       C4       C6       C8</span>
<span class="sd">       ---- -------- --------- -------- -------- -------- -------- </span>
<span class="sd">       1.1  0.701551 -0.639244 0.937693 0.000000 0.000000 0.000000</span>
<span class="sd">       1.2  0.396430 -0.150902 0.754472 0.000000 0.000000 0.000000</span>
<span class="sd">       1.3  0.237413 -0.065285 0.827872 0.000000 0.000000 0.000000</span>
<span class="sd">       1.4  0.153945 -0.141765 0.987820 0.000000 0.000000 0.000000</span>
<span class="sd">       1.5  0.077112 0.000000  0.703371 0.219517 0.000000 0.000000</span>
<span class="sd">       1.6  0.039234 0.000000  0.630268 0.234934 0.095563 0.000000</span>
<span class="sd">       1.7  0.020078 0.000000  0.480667 0.386409 0.112845 0.000000</span>
<span class="sd">       1.8  0.010172 0.000000  0.344429 0.451817 0.193580 0.000000</span>
<span class="sd">       1.9  0.004773 0.000000  0.232473 0.464562 0.298191 0.000000</span>
<span class="sd">       2.0  0.002267 0.000000  0.140412 0.487172 0.256200 0.113948</span>
<span class="sd">       ==== ======== ========= ======== ======== ======== ========</span>

<span class="sd">    .. [NAY2007] Naylor, D. A., &amp; Tahic, M. K. (2007). Apodizing</span>
<span class="sd">       functions for Fourier transform spectroscopy. Journal of the</span>
<span class="sd">       Optical Society of America A.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">norton_beer_coeffs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">[</span><span class="mf">1.1</span><span class="p">,</span> <span class="mf">0.701551</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.639244</span><span class="p">,</span> <span class="mf">0.937693</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">1.2</span><span class="p">,</span> <span class="mf">0.396430</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.150902</span><span class="p">,</span> <span class="mf">0.754472</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">1.3</span><span class="p">,</span> <span class="mf">0.237413</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.065285</span><span class="p">,</span> <span class="mf">0.827872</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">1.4</span><span class="p">,</span> <span class="mf">0.153945</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.141765</span><span class="p">,</span> <span class="mf">0.987820</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.077112</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.703371</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.219517</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">1.6</span><span class="p">,</span> <span class="mf">0.039234</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.630268</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.234934</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.095563</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">1.7</span><span class="p">,</span> <span class="mf">0.020078</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.480667</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.386409</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.112845</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">1.8</span><span class="p">,</span> <span class="mf">0.010172</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.344429</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.451817</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.193580</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">1.9</span><span class="p">,</span> <span class="mf">0.004773</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.232473</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.464562</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.298191</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">2.0</span><span class="p">,</span> <span class="mf">0.002267</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.140412</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.487172</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.256200</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.113948</span><span class="p">]]</span>

    <span class="n">fwhm_list</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;1.1&#39;</span><span class="p">,</span> <span class="s1">&#39;1.2&#39;</span><span class="p">,</span> <span class="s1">&#39;1.3&#39;</span><span class="p">,</span> <span class="s1">&#39;1.4&#39;</span><span class="p">,</span> <span class="s1">&#39;1.5&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;1.6&#39;</span><span class="p">,</span> <span class="s1">&#39;1.7&#39;</span><span class="p">,</span> <span class="s1">&#39;1.8&#39;</span><span class="p">,</span> <span class="s1">&#39;1.9&#39;</span><span class="p">,</span> <span class="s1">&#39;2.0&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">fwhm</span> <span class="ow">in</span> <span class="n">fwhm_list</span><span class="p">:</span>
        <span class="n">fwhm_index</span> <span class="o">=</span> <span class="n">fwhm_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">fwhm</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Bad extended Norton-Beer window FWHM. Must be in : &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">fwhm_list</span><span class="p">))</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="n">nb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
        <span class="n">nb</span> <span class="o">+=</span> <span class="n">norton_beer_coeffs</span><span class="p">[</span><span class="n">fwhm_index</span><span class="p">][</span><span class="n">index</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="n">index</span>
    <span class="k">return</span> <span class="n">nb</span></div>

<div class="viewcode-block" id="apod2width"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.apod2width">[docs]</a><span class="k">def</span> <span class="nf">apod2width</span><span class="p">(</span><span class="n">apod</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the width of the gaussian window for a given apodization level.</span>

<span class="sd">    :param apod: Apodization level (must be &gt;= 1.)</span>

<span class="sd">    The apodization level is the broadening factor of the line (an</span>
<span class="sd">    apodization level of 2 mean that the line fwhm will be 2 times</span>
<span class="sd">    wider).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">apod</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
        <span class="s1">&#39;Apodization level (broadening factor) must be &gt; 1&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">apod</span> <span class="o">-</span> <span class="mf">1.</span> <span class="o">+</span> <span class="p">(</span><span class="n">gvar</span><span class="o">.</span><span class="n">erf</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">gvar</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">apod</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">))</span>
                        <span class="o">*</span> <span class="n">orb</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">FWHM_SINC_COEFF</span><span class="p">)</span></div>

<div class="viewcode-block" id="apod2sigma"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.apod2sigma">[docs]</a><span class="k">def</span> <span class="nf">apod2sigma</span><span class="p">(</span><span class="n">apod</span><span class="p">,</span> <span class="n">fwhm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the broadening of the gaussian-sinc function in the</span>
<span class="sd">    spectrum for a given apodization level. Unit is that of the fwhm.</span>

<span class="sd">    :param apod: Apodization level (must be &gt;= 1.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">broadening</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="p">(</span><span class="n">apod2width</span><span class="p">(</span><span class="n">apod</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">2.</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
                       <span class="o">/</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">compute_line_fwhm_pix</span><span class="p">(</span>
                           <span class="n">oversampling_ratio</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">broadening</span> <span class="o">*</span> <span class="n">fwhm</span></div>

<div class="viewcode-block" id="gaussian_window"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.gaussian_window">[docs]</a><span class="k">def</span> <span class="nf">gaussian_window</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a Gaussian apodization function for a given broadening</span>
<span class="sd">    factor.</span>

<span class="sd">    :param coeff: FWHM relative to the sinc function. Must be a float &gt; 1.</span>
<span class="sd">       </span>
<span class="sd">    :param n: Number of points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coeff</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">apod2width</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="learner95_window"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.learner95_window">[docs]</a><span class="k">def</span> <span class="nf">learner95_window</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the apodization function described in Learner et al.,</span>
<span class="sd">    J. Opt. Soc. Am. A, 12, (1995).</span>

<span class="sd">    This function is closely related to the minimum four-term</span>
<span class="sd">    Blackman-Harris window.</span>

<span class="sd">    Returned window is symmetrical.</span>
<span class="sd">    </span>
<span class="sd">    :param n: Number of points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="mf">0.355766</span>
            <span class="o">+</span> <span class="mf">0.487395</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
            <span class="o">+</span> <span class="mf">0.144234</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>
            <span class="o">+</span> <span class="mf">0.012605</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">3.</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">x</span><span class="p">))</span></div>

<div class="viewcode-block" id="border_cut_window"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.border_cut_window">[docs]</a><span class="k">def</span> <span class="nf">border_cut_window</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">coeff</span><span class="o">=</span><span class="mf">0.2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a window function with only the edges cut by a nice</span>
<span class="sd">    gaussian shape function.</span>
<span class="sd">    </span>
<span class="sd">    :param n: Window length</span>
<span class="sd">    :param coeff: Border size in percentage of the total length.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">border_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">coeff</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">border_length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">window</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">window</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">borders</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">get_window</span><span class="p">((</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span><span class="n">border_length</span><span class="o">/</span><span class="mf">3.</span><span class="p">),</span>
                                    <span class="n">border_length</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">borders</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
        <span class="n">window</span><span class="p">[:</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="n">borders</span><span class="p">[:</span><span class="n">z</span><span class="p">]</span>
        <span class="n">window</span><span class="p">[</span><span class="o">-</span><span class="n">z</span><span class="p">:]</span> <span class="o">=</span> <span class="n">borders</span><span class="p">[</span><span class="o">-</span><span class="n">z</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">window</span></div>

<div class="viewcode-block" id="compute_phase_coeffs_vector"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.compute_phase_coeffs_vector">[docs]</a><span class="k">def</span> <span class="nf">compute_phase_coeffs_vector</span><span class="p">(</span><span class="n">phase_maps</span><span class="p">,</span>
                                <span class="n">res_map</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return a vector containing the mean of the phase</span>
<span class="sd">    coefficients for each given phase map.</span>

<span class="sd">    :param phase_maps: Tuple of phase maps. Coefficients are</span>
<span class="sd">      sorted in the same order as the phase maps.</span>

<span class="sd">    :param res_map: (Optional) If given this map is used to</span>
<span class="sd">      get only the well fitted coefficients in order to compute a</span>
<span class="sd">      more precise mean coefficent.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">BEST_RATIO</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="c1"># Max ratio of coefficients considered as good</span>
    
    <span class="n">res_map</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">res_map</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">res_map</span><span class="p">)</span>
    <span class="n">res_map</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">res_map</span><span class="p">))]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">res_map</span><span class="p">)</span>
    <span class="n">res_distrib</span> <span class="o">=</span> <span class="n">res_map</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">res_map</span><span class="p">))]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="c1"># residuals are sorted and sigma-cut filtered </span>
    <span class="n">best_res_distrib</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">sigmacut</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span>
            <span class="n">res_distrib</span><span class="p">,</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">BEST_RATIO</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">res_distrib</span><span class="p">)))[</span>
            <span class="p">:</span><span class="nb">int</span><span class="p">(</span><span class="n">BEST_RATIO</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">res_distrib</span><span class="p">))],</span> <span class="n">sigma</span><span class="o">=</span><span class="mf">2.5</span><span class="p">)</span>
    <span class="n">res_map_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">res_map</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="n">res_map_mask</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span>
        <span class="n">res_map</span> <span class="o">&gt;</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">robust_median</span><span class="p">(</span><span class="n">best_res_distrib</span><span class="p">))]</span> <span class="o">=</span> <span class="mi">0</span>


    <span class="nb">print</span> <span class="s2">&quot;Number of well fitted phase vectors used to compute phase coefficients: </span><span class="si">%d</span><span class="s2">&quot;</span><span class="o">%</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">res_map_mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">phase_coeffs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">order</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">phase_map</span> <span class="ow">in</span> <span class="n">phase_maps</span><span class="p">:</span>
        <span class="c1"># Only the pixels with a good residual coefficient are used </span>
        <span class="n">clean_phase_map</span> <span class="o">=</span> <span class="n">phase_map</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">res_map_mask</span><span class="p">)]</span>
        <span class="n">median_coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">clean_phase_map</span><span class="p">)</span>
        <span class="n">std_coeff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">clean_phase_map</span><span class="p">)</span>

        <span class="c1"># phase map is sigma filtered to remove bad pixels</span>
        <span class="n">clean_phase_map</span> <span class="o">=</span> <span class="p">[</span><span class="n">coeff</span> <span class="k">for</span> <span class="n">coeff</span> <span class="ow">in</span> <span class="n">clean_phase_map</span>
                           <span class="k">if</span> <span class="p">((</span><span class="n">coeff</span> <span class="o">&lt;</span> <span class="n">median_coeff</span> <span class="o">+</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">std_coeff</span><span class="p">)</span>
                               <span class="ow">and</span> <span class="p">(</span><span class="n">coeff</span> <span class="o">&gt;</span> <span class="n">median_coeff</span> <span class="o">-</span> <span class="mf">2.</span><span class="o">*</span> <span class="n">std_coeff</span><span class="p">))]</span>

        <span class="n">phase_coeffs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">clean_phase_map</span><span class="p">))</span>
        <span class="nb">print</span> <span class="s2">&quot;Computed phase coefficient: </span><span class="si">%f</span><span class="s2"> (std: </span><span class="si">%f</span><span class="s2">)&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">clean_phase_map</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">clean_phase_map</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">clean_phase_map</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">clean_phase_map</span><span class="p">)):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Phase map standard deviation (</span><span class="si">%f</span><span class="s2">) is greater than its mean value (</span><span class="si">%f</span><span class="s2">) : the returned coefficient is not well determined and phase correction might be uncorrect&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">clean_phase_map</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">clean_phase_map</span><span class="p">)))</span>
        <span class="n">order</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">phase_coeffs</span></div>
    
<div class="viewcode-block" id="transform_interferogram"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.transform_interferogram">[docs]</a><span class="k">def</span> <span class="nf">transform_interferogram</span><span class="p">(</span><span class="n">interf</span><span class="p">,</span> <span class="n">nm_laser</span><span class="p">,</span> 
                            <span class="n">calibration_nm_laser</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> 
                            <span class="n">window_type</span><span class="p">,</span> <span class="n">zpd_shift</span><span class="p">,</span> <span class="n">phase_correction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">wave_calibration</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                            <span class="n">return_phase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ext_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">balanced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">bad_frames_vector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">smoothing_coeff</span><span class="o">=</span><span class="mf">0.04</span><span class="p">,</span> <span class="n">return_complex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">final_step_nb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wavenumber</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">low_order_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">high_order_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">return_zp_vector</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">sampling_steps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    
    <span class="sd">&quot;&quot;&quot;Transform an interferogram into a spectrum.</span>
<span class="sd">    </span>
<span class="sd">    :param interf: Interferogram to transform.</span>
<span class="sd">    </span>
<span class="sd">    :param nm_laser: Wavelength of the laser used for calibration.</span>
<span class="sd">    </span>
<span class="sd">    :param calibration_nm_laser: Wavelength of the laser emission line</span>
<span class="sd">      corresponding to the computed interferogram.</span>

<span class="sd">    :param step: Step size of the moving mirror in nm.</span>

<span class="sd">    :param order: Folding order (if 0 the result cannot be projected</span>
<span class="sd">      on an axis in nm, i.e. wavenumber option is automatically set to</span>
<span class="sd">      True).</span>

<span class="sd">    :param window_type: Name of the apodization function (can be</span>
<span class="sd">      learner95 or a float &gt; 1.).</span>

<span class="sd">    :param zpd_shift: Shift of the interferogram to center the ZPD.</span>

<span class="sd">    :param bad_frames_vector: (Optional) Mask-like vector containing</span>
<span class="sd">      ones for bad frames. Bad frames are replaced by zeros using a</span>
<span class="sd">      special function that smoothes transition between good parts and</span>
<span class="sd">      zeros (default None). This vector must be uncorrected for ZPD</span>
<span class="sd">      shift</span>

<span class="sd">    :param phase_correction: (Optional) If False, no phase correction</span>
<span class="sd">      will be done and the resulting spectrum will be the absolute</span>
<span class="sd">      value of the complex spectrum. Else the ext_phase vector will be</span>
<span class="sd">      used for phase correction. If ext_phase is set to None,</span>
<span class="sd">      ext_phase will be replaced by a vector of 0 (default True).</span>

<span class="sd">    :param wave_calibration: (Optional) If True wavenumber/wavelength</span>
<span class="sd">      calibration is done (default True).</span>

<span class="sd">    :param ext_phase: (Optional) External phase vector. If given this</span>
<span class="sd">      phase vector is used instead of a low-resolution one. It must be</span>
<span class="sd">      as long as the interferogram.</span>
<span class="sd">      </span>
<span class="sd">    :param return_phase: (Optional) If True, compute only the phase of</span>
<span class="sd">      the interferogram and return it. If polyfit_deg is &gt;= 0, return</span>
<span class="sd">      the coefficients of the fitted phase (default False). Note that</span>
<span class="sd">      this option is not compatible with ext_phase. You must set</span>
<span class="sd">      ext_phase to None to set return_phase to True.</span>

<span class="sd">    :param smoothing_coeff: (Optional) Coefficient of zeros smoothing</span>
<span class="sd">      in proportion of the total interferogram size. A higher</span>
<span class="sd">      coefficient means a smoother transition from zeros parts (bad</span>
<span class="sd">      frames) to non-zero parts (good frames) of the</span>
<span class="sd">      interferogram. Good parts on the other side of the ZPD in</span>
<span class="sd">      symmetry with zeros parts are multiplied by 2 to keep a constant</span>
<span class="sd">      amount of energy. The same transition is used to multiply</span>
<span class="sd">      interferogram points by zero and 2. This operation is not done</span>
<span class="sd">      if smoothing_coeff is set to 0. must be between 0. and 0.2</span>
<span class="sd">      (default 0.04).</span>

<span class="sd">    :param balanced: (Optional) If False, the interferogram is</span>
<span class="sd">      considered as unbalanced. It is flipped before its</span>
<span class="sd">      transformation to get a positive spectrum. Note</span>
<span class="sd">      that a merged interferogram is balanced (default True).</span>

<span class="sd">    :param return_complex: (Optional) If True and if phase is</span>
<span class="sd">      corrected the returned spectrum will be complex. In False only</span>
<span class="sd">      the real part is returned (default False)</span>

<span class="sd">    :param final_step_nb: (Optional) Number of samples of the</span>
<span class="sd">      resulting spectrum. If None, the number of samples of the</span>
<span class="sd">      spectrum will be the same as the interferogram (default None).</span>

<span class="sd">    :param wavenumber: (Optional) If True, the returned spectrum is</span>
<span class="sd">      projected onto its original wavenumber axis (emission lines and</span>
<span class="sd">      especially unapodized sinc emission lines are thus symetric</span>
<span class="sd">      which is not the case if the spectrum is projected onto a, more</span>
<span class="sd">      convenient, regular wavelength axis) (default False).</span>

<span class="sd">    :param low_order_correction: (Optional) If True substract a low</span>
<span class="sd">      order polynomial to remove low frequency noise. Useful for</span>
<span class="sd">      unperfectly corrected interferograms (default False).</span>

<span class="sd">    :param high_order_phase: (Optional) High order phase to be added</span>
<span class="sd">      to the phase computed via a low order polynomial (generally 1</span>
<span class="sd">      order). Note that it must be a orb.core.PhaseFile instance or a</span>
<span class="sd">      scipy.interpolate.UnivariateSpline instance to accelerate the</span>
<span class="sd">      process.</span>

<span class="sd">    :param sampling_steps: (Optional) If the sampling steps are not</span>
<span class="sd">      uniform, the real sampling function can be given. It must have</span>
<span class="sd">      the exact same size as the interferogram. Note that a NDFT will</span>
<span class="sd">      be performed which is much slower than a FFT.</span>

<span class="sd">    .. note:: Interferogram can be complex</span>

<span class="sd">    .. note:: Only NANs or INFs are interpreted as bad values</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">interf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">interf</span><span class="p">)</span>
    <span class="n">interf_orig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">interf</span><span class="p">)</span>
        
    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wavenumber</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;order 0: Wavenumber output automatically set to True. Please set manually wavenumber option to True if you don&#39;t want to see this warning message.&quot;</span><span class="p">)</span>
        <span class="n">wavenumber</span> <span class="o">=</span> <span class="kc">True</span>
   
    <span class="k">if</span> <span class="n">return_phase</span> <span class="ow">and</span> <span class="n">phase_correction</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;phase correction and return_phase cannot be all set to True&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">return_phase</span> <span class="ow">and</span> <span class="n">ext_phase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;return_phase=True and ext_phase != None options are not compatible. Set the phase or get it !&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">smoothing_coeff</span> <span class="o">&lt;</span> <span class="mf">0.</span> <span class="ow">or</span> <span class="n">smoothing_coeff</span> <span class="o">&gt;</span> <span class="mf">0.2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;smoothing coeff must be between 0. and 0.2&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sampling_steps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sampling_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sampling_steps</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">sampling_steps</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">interf</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;sampling_steps must have the same size as interf&#39;</span>

    <span class="n">dimz</span> <span class="o">=</span> <span class="n">interf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">smoothing_deg</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">dimz</span> <span class="o">*</span> <span class="n">smoothing_coeff</span><span class="p">))</span>
    <span class="n">min_zeros_length</span> <span class="o">=</span> <span class="n">smoothing_deg</span> <span class="o">*</span> <span class="mi">2</span> <span class="c1"># Minimum length of a zeros band to smooth it    </span>

    <span class="k">if</span> <span class="n">final_step_nb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">final_step_nb</span> <span class="o">=</span> <span class="n">dimz</span>

    <span class="c1"># discard zeros and nans interferogram</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">interf</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">return_phase</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">interf</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">interf</span><span class="p">)):</span> <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># discard interferograms with a bad phase vector</span>
    <span class="k">if</span> <span class="n">ext_phase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ext_phase</span><span class="p">)):</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># replace Inf by Nan</span>
    <span class="n">interf</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">interf</span><span class="p">))]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c1"># reverse unbalanced vector</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">balanced</span><span class="p">:</span>
        <span class="n">interf</span> <span class="o">=</span> <span class="o">-</span><span class="n">interf</span>

    <span class="c1">#####</span>
    <span class="c1"># 1 - substraction of the mean of the interferogram where the</span>
    <span class="c1"># interferogram is not nan</span>
    <span class="n">interf</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">interf</span><span class="p">)]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">interf</span><span class="p">)</span>
        
    <span class="c1">#####</span>
    <span class="c1"># 2 - low order polynomial substraction to suppress </span>
    <span class="c1"># low frequency noise</span>
    <span class="k">if</span> <span class="n">low_order_correction</span><span class="p">:</span>
        <span class="n">interf</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">interf</span><span class="p">)]</span> <span class="o">-=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">polyfit1d</span><span class="p">(</span>
            <span class="n">interf</span><span class="p">,</span> <span class="mi">3</span><span class="p">)[</span><span class="n">nonans</span><span class="p">]</span>
        
    <span class="c1">#####</span>
    <span class="c1"># 3 - ZPD shift to center the spectrum</span>
    
    <span class="c1"># Check phase vector to guess a better ZPD shift</span>
    <span class="k">if</span> <span class="n">ext_phase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">order1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ext_phase</span><span class="p">))</span> <span class="o">*</span> <span class="n">ext_phase</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">phase_shift</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">order1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
        <span class="n">ext_phase_corr</span> <span class="o">=</span> <span class="p">(</span><span class="n">ext_phase</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ext_phase</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                          <span class="o">*</span> <span class="n">phase_shift</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">ext_phase</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">zpd_shift_corr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">zpd_shift</span><span class="p">)</span> <span class="o">+</span> <span class="n">phase_shift</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ext_phase_corr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">zpd_shift_corr</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">zpd_shift</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">zpd_shift_corr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">zpd_shift_corr</span> <span class="o">&gt;</span> <span class="n">interf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Bad zpd shift (must be &lt;= </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">interf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">temp_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">interf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">zpd_shift_corr</span><span class="p">),</span>
                               <span class="n">dtype</span><span class="o">=</span><span class="n">interf</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">temp_vector</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">zpd_shift_corr</span><span class="p">):</span><span class="nb">abs</span><span class="p">(</span><span class="n">zpd_shift_corr</span><span class="p">)</span> <span class="o">+</span> <span class="n">dimz</span><span class="p">]</span> <span class="o">=</span> <span class="n">interf</span>
        <span class="n">interf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">temp_vector</span><span class="p">)</span>
        <span class="n">interf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">interf</span><span class="p">,</span> <span class="n">zpd_shift_corr</span><span class="p">)</span>            
        <span class="k">if</span> <span class="n">bad_frames_vector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;bad frames handling not implemented&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">bad_frames_vector</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">temp_vector</span><span class="p">[</span>
                    <span class="nb">abs</span><span class="p">(</span><span class="n">zpd_shift_corr</span><span class="p">):</span><span class="nb">abs</span><span class="p">(</span><span class="n">zpd_shift_corr</span><span class="p">)</span> <span class="o">+</span> <span class="n">dimz</span><span class="p">]</span> <span class="o">=</span> <span class="n">bad_frames_vector</span>
                <span class="n">bad_frames_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">temp_vector</span><span class="p">)</span>
                <span class="n">bad_frames_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">bad_frames_vector</span><span class="p">,</span> <span class="n">zpd_shift_corr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bad_frames_vector</span> <span class="o">=</span> <span class="kc">None</span>
                
    <span class="c1">### Replace Nans by zeros in interf vector</span>
    <span class="n">interf</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">interf</span><span class="p">)]</span> <span class="o">=</span> <span class="mf">0.</span>
    

    <span class="c1">#####</span>
    <span class="c1"># 4 - Ramp-like truncation function from Mertz (1967) Infrared</span>
    <span class="c1"># Physics, 7, 17-23</span>
    
    
    <span class="c1"># count zeros to detect which side is the truncation</span>
    <span class="n">zpd_pos</span> <span class="o">=</span> <span class="n">interf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span>
    
    <span class="k">if</span> <span class="n">interf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
        <span class="n">left_zeros_nb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">interf</span><span class="p">[:</span><span class="n">zpd_pos</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">left_zeros_nb</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">if</span> <span class="n">interf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.</span><span class="p">:</span>
        <span class="n">right_zeros_nb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">interf</span><span class="p">[</span><span class="n">zpd_pos</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="n">right_zeros_nb</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># create ramp</span>
    <span class="n">start_pos</span> <span class="o">=</span> <span class="n">interf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">dimz</span>
    <span class="n">sym_len</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">zpd_pos</span> <span class="o">-</span> <span class="n">start_pos</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
    
    <span class="n">zeros_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">interf</span><span class="p">)</span>
    <span class="n">zeros_vector</span><span class="p">[</span><span class="n">start_pos</span><span class="p">:</span><span class="n">start_pos</span><span class="o">+</span><span class="n">sym_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">sym_len</span><span class="p">)</span>
    <span class="n">zeros_vector</span><span class="p">[</span><span class="n">start_pos</span><span class="o">+</span><span class="n">sym_len</span><span class="p">:]</span> <span class="o">=</span> <span class="mf">2.</span>

    <span class="k">if</span> <span class="n">left_zeros_nb</span> <span class="o">&lt;</span> <span class="n">right_zeros_nb</span><span class="p">:</span>
        <span class="n">zeros_vector</span> <span class="o">=</span> <span class="n">zeros_vector</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
    <span class="n">interf</span> <span class="o">*=</span> <span class="n">zeros_vector</span>

    <span class="c1">#####</span>
    <span class="c1"># 5 - Apodization of the real interferogram</span>
    <span class="k">if</span> <span class="n">window_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">window_type</span> <span class="o">!=</span> <span class="s1">&#39;1.0&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">window_type</span> <span class="o">==</span> <span class="s1">&#39;learner95&#39;</span><span class="p">:</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">learner95_window</span><span class="p">(</span><span class="n">interf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">gaussian_window</span><span class="p">(</span><span class="n">window_type</span><span class="p">,</span> <span class="n">interf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            
        <span class="n">interf</span> <span class="o">*=</span> <span class="n">window</span>

    <span class="c1">#####</span>
    <span class="c1"># 6 - Zero padding</span>
    <span class="c1">#</span>
    <span class="c1"># Define the size of the zero padded vector to have at</span>
    <span class="c1"># least 2 times more points than the initial vector to</span>
    <span class="c1"># compute its FFT. FFT computation is faster for a vector</span>
    <span class="c1"># size equal to a power of 2. ???</span>
    <span class="c1">#zero_padded_size = next_power_of_two(2*final_step_nb)</span>
    <span class="n">zero_padded_size</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">final_step_nb</span>
    
    <span class="n">temp_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">zero_padded_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">interf</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">zeros_border</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">zero_padded_size</span> <span class="o">-</span> <span class="n">interf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">2.</span><span class="p">)</span>
    <span class="n">temp_vector</span><span class="p">[</span><span class="n">zeros_border</span><span class="p">:(</span><span class="n">zeros_border</span> <span class="o">+</span> <span class="n">interf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">interf</span>
    <span class="n">zero_padded_vector</span> <span class="o">=</span> <span class="n">temp_vector</span>

    <span class="c1">#####</span>
    <span class="c1"># 7 - ZPD rolled at the beginning of the interferogram</span>
    <span class="n">zero_padded_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">zero_padded_vector</span><span class="p">,</span>
                                 <span class="n">zero_padded_vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="c1">#####</span>
    <span class="c1"># 8 - Fast Fourier Transform of the interferogram</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">zero_padded_size</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="c1"># spectrum is cropped at zero_padded_size / 2 instead of</span>
    <span class="c1"># zero_padded_size / 2 + 1 which would output a spectrum with 1</span>
    <span class="c1"># more sample than the input length. Computed axis must be</span>
    <span class="c1"># cropped accordingly.</span>
    <span class="k">if</span> <span class="n">return_zp_vector</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">zero_padded_vector</span>

    <span class="k">if</span> <span class="n">sampling_steps</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">interf_fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">zero_padded_vector</span><span class="p">)[:</span><span class="n">center</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sampling_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">sampling_steps</span><span class="p">,</span>
                                    <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">zero_padded_vector</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">sampling_steps</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                                    <span class="o">+</span> <span class="n">sampling_steps</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>        
        <span class="n">interf_fft</span> <span class="o">=</span> <span class="n">ndft</span><span class="p">(</span><span class="n">zero_padded_vector</span><span class="p">,</span>
                          <span class="n">sampling_steps</span><span class="p">,</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">zero_padded_vector</span><span class="o">.</span><span class="n">size</span><span class="p">))[:</span><span class="n">center</span><span class="p">]</span>
        
    <span class="c1"># normalization of the vector to take into account zero-padding</span>
    <span class="c1"># and mimic a dispersive instrument: if the same energy is</span>
    <span class="c1"># dispersed over more channels (more zeros) then you get less</span>
    <span class="c1"># counts/channel</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">interf</span><span class="p">):</span>
        <span class="n">interf_fft</span> <span class="o">/=</span> <span class="p">(</span><span class="n">zero_padded_size</span> <span class="o">/</span> <span class="n">dimz</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">interf_fft</span> <span class="o">/=</span> <span class="p">(</span><span class="n">zero_padded_size</span> <span class="o">/</span> <span class="n">dimz</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>
                            

    <span class="c1">#### Create spectrum original cm-1 axis</span>
    <span class="k">if</span> <span class="n">wave_calibration</span><span class="p">:</span>
        <span class="n">correction_coeff</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">calibration_nm_laser</span><span class="p">)</span> <span class="o">/</span> <span class="n">nm_laser</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">correction_coeff</span> <span class="o">=</span> <span class="mf">1.</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">wavenumber</span><span class="p">:</span>
        <span class="n">base_axis</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">create_nm_axis_ireg</span><span class="p">(</span>
            <span class="n">interf_fft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">step</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
            <span class="n">corr</span><span class="o">=</span><span class="n">correction_coeff</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">base_axis</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">create_cm1_axis</span><span class="p">(</span>
            <span class="n">interf_fft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">step</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">corr</span><span class="o">=</span><span class="n">correction_coeff</span><span class="p">)</span>
        
    <span class="c1">#####</span>
    <span class="c1"># 9 - Phase correction</span>
    <span class="k">if</span> <span class="n">phase_correction</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ext_phase_corr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ext_phase_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dimz</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">high_order_phase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">phase_axis</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">create_cm1_axis</span><span class="p">(</span>
                <span class="n">dimz</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
                <span class="n">corr</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">calibration_nm_laser</span><span class="p">)</span> <span class="o">/</span> <span class="n">nm_laser</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span> <span class="c1"># if high_order_phase is a PhaseFile instance</span>
                <span class="n">high_order_phase</span> <span class="o">=</span> <span class="n">high_order_phase</span><span class="o">.</span><span class="n">get_improved_phase</span><span class="p">(</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">calibration_nm_laser</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="k">pass</span>
            <span class="n">ext_phase_corr</span> <span class="o">+=</span> <span class="n">high_order_phase</span><span class="p">(</span><span class="n">phase_axis</span><span class="p">)</span>

        <span class="c1"># interpolation of the phase to zero padded size</span>
        <span class="n">ext_phase_corr</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">interpolate_size</span><span class="p">(</span>
            <span class="n">ext_phase_corr</span><span class="p">,</span> <span class="n">interf_fft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>

    
        <span class="n">spectrum_corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">interf_fft</span><span class="p">)</span>
        <span class="n">spectrum_corr</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="p">(</span><span class="n">interf_fft</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ext_phase_corr</span><span class="p">)</span>
                              <span class="o">+</span> <span class="n">interf_fft</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ext_phase_corr</span><span class="p">))</span>
        <span class="n">spectrum_corr</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="p">(</span><span class="n">interf_fft</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ext_phase_corr</span><span class="p">)</span>
                              <span class="o">-</span> <span class="n">interf_fft</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ext_phase_corr</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spectrum_corr</span> <span class="o">=</span> <span class="n">interf_fft</span>
        
    <span class="c1">#####</span>
    <span class="c1"># 10 - Off-axis effect correction with maxima map   </span>
    <span class="c1"># Irregular wavelength axis creation</span>
    
    <span class="c1"># Spectrum is returned if folding order is even</span>
    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">order</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">spectrum_corr</span> <span class="o">=</span> <span class="n">spectrum_corr</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Interpolation (order 5) of the spectrum from its irregular axis</span>
    <span class="c1"># to the regular one</span>
    
    <span class="c1"># regular axis creation (in nm, if step is in nm)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">wavenumber</span><span class="p">:</span>
        <span class="n">final_axis</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">create_nm_axis</span><span class="p">(</span>
            <span class="n">final_step_nb</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">final_axis</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">create_cm1_axis</span><span class="p">(</span>
            <span class="n">final_step_nb</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">corr</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
 
    <span class="c1"># spectrum interpolation</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">wavenumber</span> <span class="ow">and</span> <span class="n">correction_coeff</span> <span class="o">==</span> <span class="mf">1.</span><span class="p">):</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">interpolate_axis</span><span class="p">(</span>
            <span class="n">spectrum_corr</span><span class="p">,</span> <span class="n">final_axis</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">old_axis</span><span class="o">=</span><span class="n">base_axis</span><span class="p">)</span>
        <span class="c1"># Extrapolated parts of the spectrum are set to NaN</span>
        <span class="n">spectrum</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">final_axis</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">base_axis</span><span class="p">))]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">spectrum</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">final_axis</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">base_axis</span><span class="p">))]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="n">spectrum_corr</span>

    
    <span class="k">if</span> <span class="n">return_phase</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)))</span>
    <span class="k">elif</span> <span class="n">return_complex</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">phase_correction</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>    
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spectrum</span><span class="p">))</span></div>


<div class="viewcode-block" id="transform_spectrum"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.transform_spectrum">[docs]</a><span class="k">def</span> <span class="nf">transform_spectrum</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">nm_laser</span><span class="p">,</span> <span class="n">calibration_nm_laser</span><span class="p">,</span>
                       <span class="n">step</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">window_type</span><span class="p">,</span> <span class="n">zpd_shift</span><span class="p">,</span>
                       <span class="n">ext_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_complex</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">wavenumber</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">final_step_nb</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sampling_vector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">zero_padding</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Transform a spectrum into an interferogram.</span>

<span class="sd">    This function is the inverse of :py:meth:`utils.transform_interferogram`.</span>

<span class="sd">    So that to get the initial interferogram, the same options used in</span>
<span class="sd">    transform interferogram must be passed to this function. The</span>
<span class="sd">    spectrum must also be the complex form (use return_complex option</span>
<span class="sd">    in :py:meth:`utils.transform_interferogram`)</span>

<span class="sd">    :param spectrum: Spectrum to transform</span>

<span class="sd">    :param nm_laser: Wavelength of the laser used for calibration.</span>
<span class="sd">    </span>
<span class="sd">    :param calibration_nm_laser: Wavelength of the laser emission line</span>
<span class="sd">      corresponding to the computed interferogram.</span>

<span class="sd">    :param step: Step size of the moving mirror in nm.</span>

<span class="sd">    :param order: Folding order (can be 0 but the input must be in</span>
<span class="sd">      wavenumber).</span>

<span class="sd">    :param window_type: Name of the apodization function.</span>

<span class="sd">    :param zpd_shift: Shift of the interferogram to decenter the ZPD.</span>
<span class="sd">      </span>
<span class="sd">    :param ext_phase: (Optional) External phase vector. If given this</span>
<span class="sd">      phase vector is used in place of the original phase of the</span>
<span class="sd">      spectrum. Useful to add a phase to an interferogram. Note that</span>
<span class="sd">      this phase is intended to be used to inverse transform an</span>
<span class="sd">      already transformed interferogram. The computed phase correction</span>
<span class="sd">      can thus be used directly. As the phase vector given by</span>
<span class="sd">      :py:meth:`utils.transform_interferogram` is not reversed for</span>
<span class="sd">      even orders, it is reversed here in this function.</span>

<span class="sd">    :param return_complex: (Optional) If True return a complex</span>
<span class="sd">      interferogram. Else return the real part of it (default False).</span>

<span class="sd">    :param wavenumber: (Optional) If True the spectrum axis is in</span>
<span class="sd">      cm-1. In this case, and if no wavelength correction has to be</span>
<span class="sd">      applied (calibration_nm_laser == nm_laser) there will be no</span>
<span class="sd">      interpolation of the original spectrum (better precision)</span>
<span class="sd">      (default False).</span>

<span class="sd">    :param final_step_nb: (Optional) Final size of the</span>
<span class="sd">      interferogram. Must be less than the size of the original</span>
<span class="sd">      spectrum. If None the final size of the interferogram is the</span>
<span class="sd">      same as the size of the original spectrum (default None).</span>

<span class="sd">    :sampling_vector: (Optional) If the samples of the interferogram</span>
<span class="sd">      are not uniformly distributed, a vector giving the positions of</span>
<span class="sd">      the samples can be passed. In this case an inverse NDFT is</span>
<span class="sd">      computed which may be really slow for long vectors. A uniformly</span>
<span class="sd">      sampled vector would be range(final_step_nb). The size of the</span>
<span class="sd">      vector must be equal to final_step_nb (default None).</span>

<span class="sd">    :zero_padding: (Optional) If True and if final_step_nb is &gt;</span>
<span class="sd">      spectrum step number, ouput is zero padded. Can be used to</span>
<span class="sd">      compare a high resolution interferogram to a low resolution</span>
<span class="sd">      interferogram.</span>
<span class="sd">    </span>
<span class="sd">    .. note:: Interferogram can be complex</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">zpd_shift</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;ZPD shift must be an integer and will be converted&quot;</span><span class="p">)</span>
        <span class="n">zpd_shift</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">zpd_shift</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">wavenumber</span><span class="p">:</span>
        <span class="n">wavenumber</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Order 0: spectrum input automatically set to wavenumber. Please set manually wavenumber option to True if you don&#39;t want this warning message to be printed.&quot;</span><span class="p">)</span>
    <span class="n">spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
    <span class="n">spectrum</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
    <span class="n">step_nb</span> <span class="o">=</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">final_step_nb</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">final_step_nb</span> <span class="o">&gt;</span> <span class="n">step_nb</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;final_step_nb must be less than the size of the original spectrum&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">final_step_nb</span> <span class="o">=</span> <span class="n">step_nb</span>

    <span class="c1"># On-axis -&gt; Off-axis [nm - &gt; cm-1]</span>
    <span class="n">correction_coeff</span> <span class="o">=</span> <span class="n">calibration_nm_laser</span> <span class="o">/</span> <span class="n">nm_laser</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">wavenumber</span><span class="p">:</span>
        <span class="n">base_axis</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">create_nm_axis</span><span class="p">(</span>
            <span class="n">step_nb</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">base_axis</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">create_nm_axis_ireg</span><span class="p">(</span>
            <span class="n">step_nb</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span><span class="n">corr</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
    
    <span class="n">nm_axis_ireg</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">create_nm_axis_ireg</span><span class="p">(</span>
        <span class="n">step_nb</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">corr</span><span class="o">=</span><span class="n">correction_coeff</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">wavenumber</span> <span class="ow">and</span> <span class="n">correction_coeff</span> <span class="o">==</span> <span class="mf">1.</span><span class="p">):</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">interpolate_axis</span><span class="p">(</span>
            <span class="n">spectrum</span><span class="p">,</span> <span class="n">nm_axis_ireg</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">5</span><span class="p">,</span>
            <span class="n">old_axis</span><span class="o">=</span><span class="n">base_axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="n">spectrum</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1"># Add phase to the spectrum (Re-phase)</span>
    <span class="k">if</span> <span class="n">ext_phase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">ext_phase</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">order</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">ext_phase</span> <span class="o">=</span> <span class="n">ext_phase</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ext_phase</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">vector</span><span class="o">.</span><span class="n">interpolate_size</span><span class="p">(</span><span class="n">ext_phase</span><span class="p">,</span> <span class="n">step_nb</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
            <span class="n">spectrum_real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
            <span class="n">spectrum_imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
            <span class="n">spectrum</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="p">(</span><span class="n">spectrum_real</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ext_phase</span><span class="p">)</span>
                             <span class="o">-</span> <span class="n">spectrum_imag</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ext_phase</span><span class="p">))</span>
            <span class="n">spectrum</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="p">(</span><span class="n">spectrum_real</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ext_phase</span><span class="p">)</span>
                             <span class="o">+</span> <span class="n">spectrum_imag</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ext_phase</span><span class="p">))</span>

    
    <span class="c1"># Zero-filling</span>
    <span class="n">zeros_spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">step_nb</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">spectrum</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">order</span><span class="o">&amp;</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">zeros_spectrum</span><span class="p">[:</span><span class="n">spectrum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">spectrum</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">zeros_spectrum</span><span class="p">[:</span><span class="n">spectrum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">spectrum</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">spectrum</span> <span class="o">=</span> <span class="n">zeros_spectrum</span>

    <span class="c1"># IFFT and re-shift + center burst</span>
    <span class="k">if</span> <span class="n">sampling_vector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">interf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
        <span class="n">interf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">interf</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">step_nb</span> <span class="o">-</span> <span class="n">zpd_shift</span><span class="p">))</span>
        <span class="n">interf</span> <span class="o">=</span> <span class="n">interf</span><span class="p">[</span>
            <span class="n">step_nb</span><span class="o">-</span><span class="p">(</span><span class="n">final_step_nb</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">final_step_nb</span><span class="o">%</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">step_nb</span><span class="o">+</span><span class="p">(</span><span class="n">final_step_nb</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sampling_vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">final_step_nb</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span>
            <span class="s1">&#39;Sampling vector size must be equal to the final_step_nb&#39;</span><span class="p">)</span>
        <span class="n">interf</span> <span class="o">=</span> <span class="n">indft</span><span class="p">(</span><span class="n">spectrum</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">sampling_vector</span><span class="p">)</span>
    
    <span class="n">interf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">interf</span><span class="p">)</span>

    <span class="c1"># De-apodize</span>
    <span class="k">if</span> <span class="n">window_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">gaussian_window</span><span class="p">(</span><span class="n">window_type</span><span class="p">,</span> <span class="n">final_step_nb</span><span class="p">)</span>
        <span class="n">interf</span> <span class="o">/=</span> <span class="n">window</span>

    <span class="c1"># Normalization to remove zero filling effect on the mean energy</span>
    <span class="n">interf</span> <span class="o">*=</span> <span class="n">step_nb</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">final_step_nb</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span>

    <span class="c1"># Zero-padding of the output</span>
    <span class="k">if</span> <span class="n">zero_padding</span> <span class="ow">and</span> <span class="n">final_step_nb</span> <span class="o">&lt;</span> <span class="n">step_nb</span><span class="p">:</span>
        <span class="n">zp_interf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">step_nb</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
        <span class="n">zp_interf</span><span class="p">[</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">step_nb</span><span class="o">/</span><span class="mf">2.</span><span class="p">))</span><span class="o">-</span><span class="p">(</span><span class="n">final_step_nb</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">final_step_nb</span><span class="o">%</span><span class="mi">2</span><span class="p">:</span>
            <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">step_nb</span><span class="o">/</span><span class="mf">2.</span><span class="p">))</span><span class="o">+</span><span class="p">(</span><span class="n">final_step_nb</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">interf</span>
        <span class="n">interf</span> <span class="o">=</span> <span class="n">zp_interf</span>
        
    <span class="k">if</span> <span class="n">return_complex</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">interf</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">interf</span><span class="o">.</span><span class="n">real</span></div>

<div class="viewcode-block" id="ndft"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.ndft">[docs]</a><span class="k">def</span> <span class="nf">ndft</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">xk</span><span class="p">,</span> <span class="n">vj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Non-uniform Discret Fourier Tranform</span>

<span class="sd">    Compute the spectrum from an interferogram. Noth axis can be</span>
<span class="sd">    irregularly sampled.</span>

<span class="sd">    If the spectral axis (output axis) is irregular the result is</span>
<span class="sd">    exact. But there is no magic: if the input axis (interferogram</span>
<span class="sd">    sampling) is irregular the output spectrum is not exact because</span>
<span class="sd">    the projection basis is not orthonormal.</span>

<span class="sd">    If the interferogram is the addition of multiple regularly sampled</span>
<span class="sd">    scans with a opd shift between each scan, the result will be good</span>
<span class="sd">    as long as there are not too much scans added one after the</span>
<span class="sd">    other. But if the interferogram steps are randomly distributed, it</span>
<span class="sd">    will be better to use a classic FFT because the resulting noise</span>
<span class="sd">    will be much lower.</span>

<span class="sd">    :param a: 1D interferogram</span>
<span class="sd">    </span>
<span class="sd">    :param xk: 1D sampling steps of the interferogram. Must have the</span>
<span class="sd">      same size as a and must be relative to the real step length,</span>
<span class="sd">      i.e. if the sampling is uniform xk = np.arange(a.size).</span>
<span class="sd">    </span>
<span class="sd">    :param vj: 1D frequency sampling of the output spectrum.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;a must be a 1d vector&#39;</span>
    <span class="k">assert</span> <span class="n">vj</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;vj must be a 1d vector&#39;</span>
    <span class="k">assert</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">xk</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s1">&#39;size of a must equal size of xk&#39;</span>
    
    <span class="n">angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">((</span><span class="o">-</span><span class="mf">2.</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">xk</span> <span class="o">/</span> <span class="n">xk</span><span class="o">.</span><span class="n">size</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">vj</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">angle</span><span class="p">))</span></div>



<div class="viewcode-block" id="indft"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.indft">[docs]</a><span class="k">def</span> <span class="nf">indft</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Inverse Non-uniform Discret Fourier Transform.</span>

<span class="sd">    Compute the irregularly sampled interferogram from a regularly</span>
<span class="sd">    sampled spectrum.</span>

<span class="sd">    :param a: regularly sampled spectrum.</span>
<span class="sd">    </span>
<span class="sd">    :param x: positions of the interferogram samples. If x =</span>
<span class="sd">      range(size(a)), this function is equivalent to an idft or a</span>
<span class="sd">      ifft. Note that the ifft is of course much faster to</span>
<span class="sd">      compute. This vector may have any length.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">orb</span><span class="o">.</span><span class="n">cutils</span><span class="o">.</span><span class="n">indft</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span></div>

<div class="viewcode-block" id="spectrum_mean_energy"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.spectrum_mean_energy">[docs]</a><span class="k">def</span> <span class="nf">spectrum_mean_energy</span><span class="p">(</span><span class="n">spectrum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the mean energy of a spectrum by channel.</span>

<span class="sd">    :param spectrum: a 1D spectrum</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">orb</span><span class="o">.</span><span class="n">cutils</span><span class="o">.</span><span class="n">spectrum_mean_energy</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span></div>


<div class="viewcode-block" id="interf_mean_energy"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.interf_mean_energy">[docs]</a><span class="k">def</span> <span class="nf">interf_mean_energy</span><span class="p">(</span><span class="n">interf</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the mean energy of an interferogram by step.</span>

<span class="sd">    :param interf: an interferogram</span>

<span class="sd">    .. warning:: The mean of the interferogram is substracted to</span>
<span class="sd">      compute only the modulation energy. This is the modulation</span>
<span class="sd">      energy which must be conserved in the resulting spectrum. Note</span>
<span class="sd">      that the interferogram transformation function (see</span>
<span class="sd">      :py:meth:`utils.transform_interferogram`) remove the mean of the</span>
<span class="sd">      interferogram before computing its FFT.</span>

<span class="sd">    .. note:: NaNs are set to 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">orb</span><span class="o">.</span><span class="n">cutils</span><span class="o">.</span><span class="n">interf_mean_energy</span><span class="p">(</span><span class="n">interf</span><span class="p">)</span></div>
    

<div class="viewcode-block" id="variable_me"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.variable_me">[docs]</a><span class="k">def</span> <span class="nf">variable_me</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
     <span class="sd">&quot;&quot;&quot;Return a sinusoidal function representing a variable</span>
<span class="sd">     modulation efficiency.</span>

<span class="sd">     This function is used to correct for fringes.</span>

<span class="sd">     :param params: A tuple of floats [frequency, amplitude,</span>
<span class="sd">       phase]. The frequency gives the number of repetition of a sinus</span>
<span class="sd">       over the vector. The amplitude must be between 0. (returns a</span>
<span class="sd">       vector of 1) and 1. (returns a sinus going from 0 to 1). Phase</span>
<span class="sd">       can be a single float or a vector of size n</span>
<span class="sd">     &quot;&quot;&quot;</span>
     <span class="n">f</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
     <span class="n">a</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
     <span class="n">phi</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
     <span class="n">me_real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                      <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">f</span><span class="p">)</span>
     <span class="n">me_imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                      <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">f</span><span class="p">)</span>
     <span class="n">me</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">me_real</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
     <span class="n">me</span><span class="o">.</span><span class="n">real</span> <span class="o">=</span> <span class="p">(</span><span class="n">me_real</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">-</span> <span class="n">me_imag</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span> <span class="o">*</span> <span class="n">a</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="n">a</span><span class="p">)</span>
     <span class="n">me</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="p">(</span><span class="n">me_imag</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">+</span> <span class="n">me_real</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span> <span class="o">*</span> <span class="n">a</span>
     <span class="k">return</span> <span class="n">me</span></div>


<div class="viewcode-block" id="optimize_phase"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.optimize_phase">[docs]</a><span class="k">def</span> <span class="nf">optimize_phase</span><span class="p">(</span><span class="n">interf</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">zpd_shift</span><span class="p">,</span>
                   <span class="n">calib</span><span class="p">,</span> <span class="n">nm_laser</span><span class="p">,</span>
                   <span class="n">guess</span><span class="o">=</span><span class="p">[</span><span class="mf">0.0001</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">],</span> <span class="n">return_coeffs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">fixed_params</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">high_order_phase</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return an optimized phase vector based on the minimization of</span>
<span class="sd">    the imaginary part.</span>

<span class="sd">    :param interf: Interferogram</span>
<span class="sd">    </span>
<span class="sd">    :param step: Step size (in nm)</span>
<span class="sd">    </span>
<span class="sd">    :param order: Alisasing order</span>
<span class="sd">    </span>
<span class="sd">    :param zpd_shift: ZPD shift</span>

<span class="sd">    :param calib: Calibration laser observed wavelength</span>

<span class="sd">    :param nm_laser: Calibration laser real wavelength</span>

<span class="sd">    :param guess: (Optional) First guess. The number of values defines the order</span>
<span class="sd">      of the polynomial used used to fit (default [0,0]).</span>
<span class="sd">    </span>
<span class="sd">    :param return_coeffs: (Optional) If True, coeffs and residual are</span>
<span class="sd">      returned instead of the phase vector (default False).</span>

<span class="sd">    :param fixed_params: (Optional) Define free and fixed parameters</span>
<span class="sd">      (1 for fixed, 0 for free, default [0,0])</span>

<span class="sd">    :param weights: (Optional) spectrum weighting (a vector with</span>
<span class="sd">      values ranging from 0 to 1, 1 being the maximum weight)</span>

<span class="sd">    :param high_order_phase: (Optional) High order phase to be</span>
<span class="sd">      subtracted during the optimization process. Must be a</span>
<span class="sd">      orb.core.PhaseFile instance or a</span>
<span class="sd">      scipy.interpolate.UnivariateSpline instance to accelerate the</span>
<span class="sd">      process (as returned by</span>
<span class="sd">      :py:meth:`orb.utils.fft.read_phase_file`).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">vp</span><span class="p">,</span> <span class="n">interf_fft</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">findex</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">high_phase</span><span class="p">):</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">findex</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">p</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">findex</span><span class="o">==</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">vp</span>
        <span class="n">p</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">findex</span><span class="p">)]</span> <span class="o">=</span> <span class="n">fp</span>
        <span class="n">ext_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">interf</span><span class="p">)),</span> <span class="n">p</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">high_phase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ext_phase</span> <span class="o">+=</span> <span class="n">high_phase</span>
        <span class="c1"># phase correction</span>
        <span class="n">a_fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">interf_fft</span><span class="p">)</span>
        <span class="c1">## a_fft.real = (interf_fft.real * np.cos(ext_phase)</span>
        <span class="c1">##               + interf_fft.imag * np.sin(ext_phase))</span>
        <span class="n">a_fft</span><span class="o">.</span><span class="n">imag</span> <span class="o">=</span> <span class="p">(</span><span class="n">interf_fft</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ext_phase</span><span class="p">)</span>
                      <span class="o">-</span> <span class="n">interf_fft</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ext_phase</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">a_fft</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">weights</span>

    <span class="n">guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">guess</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">fixed_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fixed_params</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">vguess</span> <span class="o">=</span> <span class="n">guess</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">fixed_params</span><span class="o">==</span><span class="mi">0</span><span class="p">)]</span>
    <span class="n">fguess</span> <span class="o">=</span> <span class="n">guess</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">fixed_params</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">interf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    
    <span class="n">interf_fft</span> <span class="o">=</span> <span class="n">transform_interferogram</span><span class="p">(</span>
        <span class="n">interf</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="s1">&#39;2.0&#39;</span><span class="p">,</span> <span class="n">zpd_shift</span><span class="p">,</span>
        <span class="n">wavenumber</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">ext_phase</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">interf</span><span class="p">),</span>
        <span class="n">phase_correction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">return_complex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">high_order_phase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cm1_axis</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">create_cm1_axis</span><span class="p">(</span>
            <span class="n">interf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">step</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
            <span class="n">corr</span><span class="o">=</span><span class="n">calib</span><span class="o">/</span><span class="n">nm_laser</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span> <span class="c1"># if high_order_phase is a PhaseFile instance</span>
            <span class="n">high_order_phase</span> <span class="o">=</span> <span class="n">high_order_phase</span><span class="o">.</span><span class="n">get_improved_phase</span><span class="p">(</span><span class="n">calib</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="k">pass</span>
            
        <span class="n">high_phase</span> <span class="o">=</span> <span class="n">high_order_phase</span><span class="p">(</span><span class="n">cm1_axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">high_phase</span> <span class="o">=</span> <span class="kc">None</span>
    
    <span class="n">optim</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">leastsq</span><span class="p">(</span>
        <span class="n">diff</span><span class="p">,</span> <span class="n">vguess</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span>
            <span class="n">interf_fft</span><span class="p">,</span> <span class="n">fguess</span><span class="p">,</span> <span class="n">fixed_params</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span>
            <span class="n">high_phase</span><span class="p">),</span>
        <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">optim</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">fixed_params</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">p</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">fixed_params</span><span class="o">==</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="n">optim</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">p</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">fixed_params</span><span class="p">)]</span> <span class="o">=</span> <span class="n">guess</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">fixed_params</span><span class="p">)]</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">optim</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="s1">&#39;fvec&#39;</span><span class="p">]</span><span class="o">**</span><span class="mf">2.</span><span class="p">))</span>
               <span class="o">/</span><span class="n">interf_mean_energy</span><span class="p">(</span><span class="n">interf</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">return_coeffs</span><span class="p">:</span>
            <span class="n">optim_phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">interf</span><span class="p">)),</span> <span class="n">p</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">high_phase</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">optim_phase</span> <span class="o">+</span> <span class="n">high_phase</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">optim_phase</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">res</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="optimize_phase3d"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.optimize_phase3d">[docs]</a><span class="k">def</span> <span class="nf">optimize_phase3d</span><span class="p">(</span><span class="n">interf_cube</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">zpd_shift</span><span class="p">,</span>
                     <span class="n">calib_map</span><span class="p">,</span> <span class="n">nm_laser</span><span class="p">,</span>
                     <span class="n">high_order_phase</span><span class="p">,</span> <span class="n">pm0</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pm1</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Return the 3 coefficents that define the linear phase terms (p0</span>
<span class="sd">    + p1 * x).</span>

<span class="sd">    The optimization is based on the maximization of the real part of</span>
<span class="sd">    the spectrum. It is done on the complete interferogram cube (a</span>
<span class="sd">    binned version is much faster) with a given calibration map. In</span>
<span class="sd">    this process the calibration map is considered to be exact and the</span>
<span class="sd">    order 0 phase map is directly calculated from it unless a phase</span>
<span class="sd">    map is given.</span>

<span class="sd">    This method is very efficient for cubes with poor phase</span>
<span class="sd">    informations in each pixel: e.g. extended galactic nebula that</span>
<span class="sd">    covers the whole field of view.</span>

<span class="sd">    :param interf_cube: Interferogram cube</span>
<span class="sd">    </span>
<span class="sd">    :param step: Step size</span>
<span class="sd">    </span>
<span class="sd">    :param order: Folding order</span>
<span class="sd">    </span>
<span class="sd">    :param zpd_shift: ZPD shift</span>
<span class="sd">    </span>
<span class="sd">    :param calib_map: Calibration laser map</span>
<span class="sd">    </span>
<span class="sd">    :param nm_laser: Calibration laser wavelength</span>
<span class="sd">    </span>
<span class="sd">    :param high_order_phase: A scipy.Spline instance of the high order</span>
<span class="sd">      phase or an orb.core.PhaseFile instance.</span>

<span class="sd">    :param pm0: (Optional) Order 0 phase map. This map is adjusted</span>
<span class="sd">      instead of calculating a phase map from a calibration laser</span>
<span class="sd">      frame (default None).</span>
<span class="sd">      </span>
<span class="sd">    :param pm1: (Optional) Order 1 phase map. This map is adjusted</span>
<span class="sd">      instead of considering a single order 1 coefficient (default</span>
<span class="sd">      None). WARNING: this phase map must be in a &quot;portable format&quot;,</span>
<span class="sd">      i.e.: it must have been multiplied by the number of steps of the</span>
<span class="sd">      original cube.</span>
<span class="sd">  </span>
<span class="sd">    :return: Phase map coefficients (a0, a1, p1) if the phase map has</span>
<span class="sd">      to be calculated from the calibration map (pm0 set to None) or</span>
<span class="sd">      (a0, p1) if the order 0 phase map is given</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">interf_cube_fft</span><span class="p">,</span> <span class="n">calib_map</span><span class="p">,</span> <span class="n">nm_laser</span><span class="p">,</span>
              <span class="n">high_order_cube</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">pm0</span><span class="p">,</span> <span class="n">pm1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pm1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_pm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">calib_map</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_pm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">pm1</span><span class="p">)</span> <span class="o">/</span> <span class="n">interf_cube_fft</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            
        <span class="k">if</span> <span class="n">pm0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_pm0</span> <span class="o">=</span> <span class="n">calib_map2phase_map0</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">calib_map</span><span class="p">),</span> <span class="n">nm_laser</span><span class="p">)</span>
            <span class="n">_pm1</span> <span class="o">=</span> <span class="n">_pm1</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_pm0</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">pm0</span>
            <span class="n">_pm1</span> <span class="o">=</span> <span class="n">_pm1</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    
        <span class="n">ext_phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">_pm0</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="p">(</span><span class="n">_pm1</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">Z</span><span class="o">.</span><span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">high_order_cube</span>
        <span class="k">if</span> <span class="n">real</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">interf_cube_fft</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ext_phase</span><span class="p">)</span>
                    <span class="o">+</span> <span class="n">interf_cube_fft</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ext_phase</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">interf_cube_fft</span><span class="o">.</span><span class="n">imag</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ext_phase</span><span class="p">)</span>
                    <span class="o">-</span> <span class="n">interf_cube_fft</span><span class="o">.</span><span class="n">real</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ext_phase</span><span class="p">))</span>
        

    <span class="k">def</span> <span class="nf">objf</span><span class="p">(</span><span class="n">pfree</span><span class="p">,</span> <span class="n">pfixed</span><span class="p">,</span> <span class="n">interf_cube_fft</span><span class="p">,</span> 
             <span class="n">calib_map</span><span class="p">,</span> <span class="n">nm_laser</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">high_order_cube</span><span class="p">,</span> <span class="n">w3d</span><span class="p">,</span>
             <span class="n">real</span><span class="p">,</span> <span class="n">pm0</span><span class="p">,</span> <span class="n">pm1</span><span class="p">):</span>
        <span class="n">pfixed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pfixed</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">pfixed</span><span class="p">)</span>
        <span class="n">p</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pfixed</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pfree</span><span class="p">)</span>
        
        <span class="n">fft_3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">model</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">interf_cube_fft</span><span class="p">,</span> <span class="n">calib_map</span><span class="p">,</span>
                               <span class="n">nm_laser</span><span class="p">,</span> <span class="n">high_order_cube</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">real</span><span class="p">,</span> <span class="n">pm0</span><span class="p">,</span> <span class="n">pm1</span><span class="p">))</span>
        <span class="n">fft_3d</span> <span class="o">*=</span> <span class="n">w3d</span>
        <span class="k">if</span> <span class="n">real</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">fft_3d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">fft_3d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">brute</span><span class="p">(</span><span class="n">gridsz</span><span class="p">,</span> <span class="n">guess_min</span><span class="p">,</span> <span class="n">guess_max</span><span class="p">,</span> <span class="n">use_pm1</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">r_pm1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_pm1</span><span class="p">:</span> <span class="n">_r_pm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">r_pm1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">_r_pm1</span> <span class="o">=</span> <span class="kc">None</span>
            
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">p_fixed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        
        <span class="nb">print</span> <span class="s1">&#39;Brute force exploration space:&#39;</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">guess_min</span><span class="p">)):</span>
            <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">guess_min</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">guess_max</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">gridsz</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="p">))</span>
            <span class="n">p_fixed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
            <span class="n">axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">guess_min</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">guess_max</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">gridsz</span><span class="p">))</span>
            <span class="n">steps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="nb">print</span> <span class="s1">&#39; a</span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1"> [</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">guess_min</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">guess_max</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">start_brute_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">brute</span> <span class="o">=</span> <span class="n">optimize</span><span class="o">.</span><span class="n">brute</span><span class="p">(</span>
            <span class="n">objf</span><span class="p">,</span> <span class="n">slices</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">p_fixed</span><span class="p">,</span>
                  <span class="n">r_interf_cube_fft</span><span class="p">,</span> <span class="n">r_calib_map</span><span class="p">,</span> <span class="n">nm_laser</span><span class="p">,</span>
                  <span class="n">r_Z</span><span class="p">,</span> <span class="n">r_high_order_cube</span><span class="p">,</span> <span class="n">r_w3d</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">r_pm0</span><span class="p">,</span> <span class="n">_r_pm1</span><span class="p">),</span>
            <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">finish</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="nb">print</span> <span class="s1">&#39;Brute force exploration time: </span><span class="si">{}</span><span class="s1"> s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_brute_time</span><span class="p">)</span>
        <span class="nb">print</span> <span class="s1">&#39;Brute force guess: </span><span class="si">{}</span><span class="s1"> [min value: </span><span class="si">{:.4e}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">brute</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">brute</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1">## brute_gridv = brute[3]</span>
        <span class="c1">## best_index = np.unravel_index(np.argmin(brute_gridv),</span>
        <span class="c1">##                               brute_gridv.shape)        </span>
        <span class="c1">## orb.utils.io.write_fits(&#39;brute_gridv.fits&#39;, brute_gridv, overwrite=True)</span>
        <span class="c1">## import pylab as pl</span>
        <span class="c1">## pl.figure(0)</span>
        <span class="c1">## pl.plot(axes[0], brute_gridv[:,best_index[1]]) # x</span>
        <span class="c1">## pl.figure(1)</span>
        <span class="c1">## pl.plot(axes[1], brute_gridv[best_index[0],:]) # y        </span>
        <span class="c1">## pl.show()</span>
        <span class="c1">## import pylab as pl</span>
        <span class="c1">## pl.figure(0)</span>
        <span class="c1">## pl.plot(axes[0], np.nanmin(np.nanmin(brute_gridv, axis=2), axis=1)) # x</span>
        <span class="c1">## pl.figure(1)</span>
        <span class="c1">## pl.plot(axes[1], np.nanmin(np.nanmin(brute_gridv, axis=2), axis=0)) # y</span>
        <span class="c1">## pl.figure(2)</span>
        <span class="c1">## pl.plot(axes[2], np.nanmin(np.nanmin(brute_gridv, axis=0), axis=0)) # z</span>
        <span class="c1">## pl.show()</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">brute</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">steps</span><span class="p">)</span>
                
    <span class="n">BORDER</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="c1"># Relative size of the borders</span>
    <span class="n">ZPD_RANGE</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1"># range checked around the real ZPD</span>
    <span class="n">RND_COEFF</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="c1"># ratio of the randomly picked interferograms</span>
    <span class="n">GRIDSZ</span> <span class="o">=</span> <span class="mi">40</span> <span class="c1"># Brute force grid size</span>
    <span class="n">SUB_GRIDSZ</span> <span class="o">=</span> <span class="n">GRIDSZ</span> <span class="o">/</span> <span class="mi">2</span> <span class="c1"># Brute force subgrid size</span>
    <span class="n">REFINE_COEFF</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># number of steps of the grid used for the subgrid</span>

    <span class="n">dimx</span><span class="p">,</span> <span class="n">dimy</span><span class="p">,</span> <span class="n">dimz</span> <span class="o">=</span> <span class="n">interf_cube</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># compute ZPD shift</span>
    <span class="k">if</span> <span class="n">pm1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">zpd_pos</span> <span class="o">=</span> <span class="n">dimz</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">zpd_shift</span>
        <span class="n">zpd_check_range</span> <span class="o">=</span> <span class="n">zpd_pos</span> <span class="o">-</span> <span class="n">ZPD_RANGE</span><span class="p">,</span> <span class="n">zpd_pos</span> <span class="o">+</span> <span class="n">ZPD_RANGE</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">zpd_check_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">zpd_check_range</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">zpd_check_range</span><span class="p">)):</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="n">interf_cube</span><span class="p">[:,:,</span><span class="n">i</span><span class="p">]</span>
            <span class="n">zpd_check_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">))</span>

        <span class="n">new_zpd_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">(</span><span class="n">zpd_check_list</span><span class="p">)</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="n">zpd_check_range</span><span class="p">)</span>
        <span class="n">new_zpd_shift</span> <span class="o">=</span> <span class="n">dimz</span><span class="o">/</span><span class="mi">2</span> <span class="o">-</span> <span class="n">new_zpd_pos</span>
        <span class="nb">print</span> <span class="s1">&#39;Init ZPD shift: </span><span class="si">{}</span><span class="s1">, real ZPD shift: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">zpd_shift</span><span class="p">,</span> <span class="n">new_zpd_shift</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">new_zpd_shift</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">zpd_shift</span><span class="p">)</span>
    
    <span class="c1"># compute complex fft of interf cube</span>
    <span class="n">interf_cube_fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">interf_cube</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">high_order_cube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">interf_cube</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimx</span><span class="p">):</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r</span><span class="s1">Transforming column </span><span class="si">{}</span><span class="s1">/</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">dimx</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ij</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dimy</span><span class="p">):</span>
            <span class="n">interf_cube_fft</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="n">ij</span><span class="p">]</span> <span class="o">=</span> <span class="n">transform_interferogram</span><span class="p">(</span>
                <span class="n">interf_cube</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="n">ij</span><span class="p">],</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="s1">&#39;1.0&#39;</span><span class="p">,</span> <span class="n">new_zpd_shift</span><span class="p">,</span>
                <span class="n">wavenumber</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">ext_phase</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dimz</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">),</span>
                <span class="n">phase_correction</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">return_complex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">phase_axis</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">spectrum</span><span class="o">.</span><span class="n">create_cm1_axis</span><span class="p">(</span>
                <span class="n">dimz</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span>
                <span class="n">corr</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">calib_map</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="n">ij</span><span class="p">])</span> <span class="o">/</span> <span class="n">nm_laser</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span> <span class="c1"># if high_order_phase is a PhaseFile instance</span>
                <span class="n">high_order_phase</span> <span class="o">=</span> <span class="n">high_order_phase</span><span class="o">.</span><span class="n">get_improved_phase</span><span class="p">(</span>
                    <span class="nb">float</span><span class="p">(</span><span class="n">calib_map</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="n">ij</span><span class="p">]))</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="k">pass</span>
            <span class="n">high_order_cube</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span><span class="n">ij</span><span class="p">]</span> <span class="o">=</span> <span class="n">high_order_phase</span><span class="p">(</span><span class="n">phase_axis</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="c1">## orb.utils.io.write_fits(&#39;interf_cube_fft.real.fits&#39;, interf_cube_fft.real,</span>
    <span class="c1">##                         overwrite=True)</span>
    <span class="c1">## orb.utils.io.write_fits(&#39;interf_cube_fft.imag.fits&#39;, interf_cube_fft.imag,</span>
    <span class="c1">##                         overwrite=True)</span>
    <span class="c1">## orb.utils.io.write_fits(&#39;high_order_cube.fits&#39;, high_order_cube,</span>
    <span class="c1">##                         overwrite=True)</span>
    <span class="c1">## interf_cube_fft.real = orb.utils.io.read_fits(&#39;interf_cube_fft.real.fits&#39;)</span>
    <span class="c1">## interf_cube_fft.imag = orb.utils.io.read_fits(&#39;interf_cube_fft.imag.fits&#39;)</span>
    <span class="c1">## high_order_cube = orb.utils.io.read_fits(&#39;high_order_cube.fits&#39;)</span>

    <span class="c1"># compute weights</span>
    <span class="n">w3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">interf_cube_fft</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">w3d</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="n">BORDER</span><span class="o">*</span><span class="n">dimx</span><span class="p">),:,:]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">w3d</span><span class="p">[</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">BORDER</span><span class="o">*</span><span class="n">dimx</span><span class="p">):,:,:]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">w3d</span><span class="p">[:,:</span><span class="nb">int</span><span class="p">(</span><span class="n">BORDER</span><span class="o">*</span><span class="n">dimy</span><span class="p">),:]</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">w3d</span><span class="p">[:,</span><span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">BORDER</span><span class="o">*</span><span class="n">dimy</span><span class="p">):,:]</span> <span class="o">=</span> <span class="mf">0.</span>
    
    <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[:</span><span class="n">dimx</span><span class="p">,</span> <span class="p">:</span><span class="n">dimy</span><span class="p">,</span> <span class="p">:</span><span class="n">dimz</span><span class="p">][</span><span class="mi">2</span><span class="p">,:,:,:]</span>

    <span class="c1"># create randomized cubes to accelerate the process</span>
    <span class="n">rndsize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dimx</span> <span class="o">*</span> <span class="n">dimy</span> <span class="o">*</span> <span class="n">RND_COEFF</span><span class="p">)</span>
    <span class="n">rndx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dimx</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">rndsize</span><span class="p">)</span>
    <span class="n">rndy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dimy</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">rndsize</span><span class="p">)</span>

    <span class="n">r_interf_cube_fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">rndsize</span><span class="p">,</span> <span class="n">dimz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">r_calib_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">rndsize</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">r_Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">rndsize</span><span class="p">,</span> <span class="n">dimz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">r_high_order_cube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">rndsize</span><span class="p">,</span> <span class="n">dimz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">r_w3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">rndsize</span><span class="p">,</span> <span class="n">dimz</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">r_pm0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">rndsize</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">r_pm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">rndsize</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rndsize</span><span class="p">):</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">rndx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">iy</span> <span class="o">=</span> <span class="n">rndy</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">interf_cube_fft</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="p">:]))</span> <span class="o">&lt;</span> <span class="mi">45000</span><span class="p">:</span>
            <span class="n">r_interf_cube_fft</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">interf_cube_fft</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">r_calib_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">calib_map</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>
            <span class="n">r_Z</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">r_high_order_cube</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">high_order_cube</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">r_w3d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">w3d</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">if</span> <span class="n">pm0</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">r_pm0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pm0</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">r_pm0</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">pm1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="n">r_pm1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pm1</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">r_pm1</span> <span class="o">=</span> <span class="kc">None</span>
        
    <span class="c1"># brute force exploration</span>
    <span class="k">if</span> <span class="n">pm1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">order1_max</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">dimz</span>
        <span class="n">order1_min</span> <span class="o">=</span> <span class="o">-</span><span class="n">order1_max</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">order1_min</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.2</span>
        <span class="n">order1_max</span> <span class="o">=</span> <span class="mf">0.2</span>

    <span class="k">if</span> <span class="n">pm0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">a0_min</span> <span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">a0_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">a1_min</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="n">a1_max</span> <span class="o">=</span> <span class="mi">250</span>
        <span class="n">guess_min</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0_min</span><span class="p">,</span> <span class="n">a1_min</span><span class="p">,</span> <span class="n">order1_min</span><span class="p">]</span>
        <span class="n">guess_max</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0_max</span><span class="p">,</span> <span class="n">a1_max</span><span class="p">,</span> <span class="n">order1_max</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a0_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">a0_max</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">guess_min</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0_min</span><span class="p">,</span> <span class="n">order1_min</span><span class="p">]</span>
        <span class="n">guess_max</span> <span class="o">=</span> <span class="p">[</span><span class="n">a0_max</span><span class="p">,</span> <span class="n">order1_max</span><span class="p">]</span>

    <span class="n">best_coeffs</span><span class="p">,</span> <span class="n">steps</span> <span class="o">=</span> <span class="n">brute</span><span class="p">(</span>
        <span class="n">GRIDSZ</span><span class="p">,</span> <span class="n">guess_min</span><span class="p">,</span> <span class="n">guess_max</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
        <span class="n">guess_min</span> <span class="o">=</span> <span class="n">best_coeffs</span> <span class="o">-</span> <span class="n">REFINE_COEFF</span> <span class="o">*</span> <span class="n">steps</span>
        <span class="n">guess_max</span> <span class="o">=</span> <span class="n">best_coeffs</span> <span class="o">+</span> <span class="n">REFINE_COEFF</span> <span class="o">*</span> <span class="n">steps</span>
        <span class="n">best_coeffs</span><span class="p">,</span> <span class="n">steps</span> <span class="o">=</span> <span class="n">brute</span><span class="p">(</span>
            <span class="n">SUB_GRIDSZ</span><span class="p">,</span> <span class="n">guess_min</span><span class="p">,</span> <span class="n">guess_max</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
    
    <span class="c1">## orb.utils.io.write_fits(</span>
    <span class="c1">##     &#39;fftreal3d.fits&#39;,</span>
    <span class="c1">##     model(best_coeffs,</span>
    <span class="c1">##           interf_cube_fft,</span>
    <span class="c1">##           calib_map, nm_laser, high_order_cube, Z, True, pm0, pm1),</span>
    <span class="c1">##     overwrite=True)</span>

    <span class="k">if</span> <span class="n">pm1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># order 1 is corrected for the new zpd shift</span>
        <span class="n">best_coeffs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">new_zpd_shift</span> <span class="o">-</span> <span class="n">zpd_shift</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">dimz</span>
    
        <span class="nb">print</span> <span class="s1">&#39;Order 1 fitted value corrected for ZPD init shift (</span><span class="si">{}</span><span class="s1"> steps): </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">new_zpd_shift</span> <span class="o">-</span> <span class="n">zpd_shift</span><span class="p">,</span> <span class="n">best_coeffs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        
    <span class="k">return</span> <span class="n">best_coeffs</span></div>
    
<div class="viewcode-block" id="calib_map2phase_map0"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.calib_map2phase_map0">[docs]</a><span class="k">def</span> <span class="nf">calib_map2phase_map0</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">calib_map</span><span class="p">,</span> <span class="n">nm_laser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute order 0 phase map from calibration laser map </span>

<span class="sd">    :param p: Transformation parameters [a0, a1]</span>
<span class="sd">    :param calib_map: Calibration laser map</span>
<span class="sd">    :param nm_laser: Calibration laser wavelength</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">theta_inv</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">calib_map</span> <span class="o">/</span> <span class="n">nm_laser</span><span class="p">)</span>
    <span class="c1">#theta_inv = calib_map</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">polynomial</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">theta_inv</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span></div>

<div class="viewcode-block" id="phase_map02calib_map"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.phase_map02calib_map">[docs]</a><span class="k">def</span> <span class="nf">phase_map02calib_map</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">phase_map0</span><span class="p">,</span> <span class="n">nm_laser</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute calibration laser map from order 0 phase map.</span>

<span class="sd">    :param p: Transformation parameters [a0, a1]</span>
<span class="sd">    :param calib_map: Order 0 phase map</span>
<span class="sd">    :param nm_laser: Calibration laser wavelength</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">nm_laser</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">((</span><span class="n">phase_map0</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span></div>

<span class="c1">## def create_mean_phase_vector(phase_cube, step, order,</span>
<span class="c1">##                              calib_map, nm_laser,</span>
<span class="c1">##                              filter_file_path,</span>
<span class="c1">##                              size_coeff=0.45,</span>
<span class="c1">##                              border_coeff=0.05):</span>

<span class="c1">##     &quot;&quot;&quot;Compute mean phase vector of order &gt; 1.</span>

<span class="c1">##     :param phase_cube: Phase cube (generally binned) as computed by</span>
<span class="c1">##       ORBS Interferogram class.</span>

<span class="c1">##     :param step: Step size in nm</span>

<span class="c1">##     :param order: Folding order</span>

<span class="c1">##     :param filter_file_path: Filter file path</span>

<span class="c1">##     :param size_coeff: Relative size of the central part used to compute mean</span>
<span class="c1">##       phase vector.</span>

<span class="c1">##     :param border_coeff: Relative size of the border inside the filter</span>
<span class="c1">##       edges. This part is not considered as good.</span>

<span class="c1">##     :returns: a tuple (Phase axis [cm-1], Phase [radians])</span>
<span class="c1">##     &quot;&quot;&quot;</span>
    
<span class="c1">##     x_min, x_max, y_min, y_max = orb.utils.image.get_box_coords(</span>
<span class="c1">##         phase_cube.shape[0]/2,</span>
<span class="c1">##         phase_cube.shape[1]/2,</span>
<span class="c1">##         int(float(min(phase_cube.shape))*size_coeff),</span>
<span class="c1">##         0, phase_cube.shape[0],</span>
<span class="c1">##         0, phase_cube.shape[1])</span>
    
<span class="c1">##     cm1_axis_base = orb.utils.spectrum.create_cm1_axis(</span>
<span class="c1">##                 phase_cube.shape[2], step, order, corr=1.)</span>
    
<span class="c1">##     phase = np.zeros(phase_cube.shape[2], dtype=float)</span>

<span class="c1">##     counts = 0</span>
<span class="c1">##     range_axis = np.arange(phase_cube.shape[2])</span>

<span class="c1">##     z_min, z_max = orb.utils.filters.get_filter_edges_pix(</span>
<span class="c1">##         filter_file_path, 1., step, order,</span>
<span class="c1">##         phase.shape[0])</span>

<span class="c1">##     border_pix = int(float(z_max - z_min) * border_coeff)</span>
<span class="c1">##     z_min += border_pix</span>
<span class="c1">##     z_max -= border_pix</span>
    
<span class="c1">##     for ii in range(x_min, x_max):</span>
<span class="c1">##         phase_col = list()</span>
<span class="c1">##         for ij in range(y_min, y_max):</span>
<span class="c1">##             # interpolate phase to 0deg axis</span>
<span class="c1">##             corr =  calib_map[ii,ij] / nm_laser</span>
<span class="c1">##             cm1_axis = orb.utils.spectrum.create_cm1_axis(</span>
<span class="c1">##                 phase_cube.shape[2], step, order, corr=corr)</span>
<span class="c1">##             iphase = phase_cube[ii,ij,:]</span>
<span class="c1">##             iphase = orb.utils.vector.interpolate_axis(</span>
<span class="c1">##                 iphase, cm1_axis_base, 1, old_axis=cm1_axis)</span>
<span class="c1">##             if int(order) &amp; 1: iphase = iphase[::-1]</span>
<span class="c1">##             # remove parts outside filter</span>
<span class="c1">##             iphase[:z_min] = np.nan</span>
<span class="c1">##             iphase[z_max:] = np.nan</span>
            
<span class="c1">##             # remove a 1 order polynomial to avoid order 0 and order 1</span>
<span class="c1">##             # variable contribution.</span>
<span class="c1">##             range_nans = range_axis[~np.isnan(iphase)]</span>
<span class="c1">##             iphase_nans = iphase[~np.isnan(iphase)]</span>
            
<span class="c1">##             iphase -= np.polyval(np.polyfit(</span>
<span class="c1">##                 range_nans, iphase_nans, 1), range_axis)</span>
<span class="c1">##             phase_col.append(iphase)</span>
        
<span class="c1">##         # each column of phase vectors is reduced to one phase vector</span>
<span class="c1">##         # with a sigmacut</span>
<span class="c1">##         phase_col = np.array(phase_col, dtype=float)</span>
<span class="c1">##         iphase = np.empty(phase_col.shape[1], dtype=float)</span>
<span class="c1">##         for ik in range(iphase.shape[0]):</span>
<span class="c1">##             iphase[ik] = np.nanmean(orb.utils.stats.sigmacut(</span>
<span class="c1">##                 phase_col[:,ik], sigma=2.0))</span>
<span class="c1">##         # computed phase vector for the column is added to the final</span>
<span class="c1">##         # phase vector</span>
<span class="c1">##         phase += iphase</span>
<span class="c1">##         counts += 1</span>
        
  
<span class="c1">##     phase /= counts</span>
<span class="c1">##     phase -= phase[~np.isnan(phase)][0] # first sample at 0.</span>
            
    
<span class="c1">##     return cm1_axis_base, phase</span>

<div class="viewcode-block" id="create_phase_file"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.create_phase_file">[docs]</a><span class="k">def</span> <span class="nf">create_phase_file</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">phase_vector</span><span class="p">,</span> <span class="n">cm1_axis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Write a phase vector in a phase file.</span>

<span class="sd">    Phase vector is interpolated via a cubic spline.</span>

<span class="sd">    :param file_path: Path to the output phase file.</span>

<span class="sd">    :param phase_vector: Phase vector</span>

<span class="sd">    :param cm1_axis: Phase vector axis in cm-1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">STEP_NB</span> <span class="o">=</span> <span class="mi">2000</span>

    <span class="c1"># interpolate phase</span>
    <span class="n">cm1_axis</span> <span class="o">=</span> <span class="n">cm1_axis</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">cm1_axis_nans</span> <span class="o">=</span> <span class="n">cm1_axis</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">phase_vector</span><span class="p">)]</span>
    <span class="n">phase_vector_nans</span> <span class="o">=</span> <span class="n">phase_vector</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">phase_vector</span><span class="p">)]</span>
    <span class="n">phase_finterp</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">UnivariateSpline</span><span class="p">(</span>
        <span class="n">cm1_axis_nans</span><span class="p">,</span> <span class="n">phase_vector_nans</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">cm1_axis_interp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cm1_axis_nans</span><span class="p">),</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cm1_axis_nans</span><span class="p">),</span>
                                  <span class="n">STEP_NB</span><span class="p">)</span>
    <span class="n">phase_interp</span> <span class="o">=</span> <span class="n">phase_finterp</span><span class="p">(</span><span class="n">cm1_axis_interp</span><span class="p">)</span>

    <span class="c1"># write phase in a phase file</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">STEP_NB</span><span class="p">):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">cm1_axis_interp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">phase_interp</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span></div>


<div class="viewcode-block" id="read_phase_file"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.fft.read_phase_file">[docs]</a><span class="k">def</span> <span class="nf">read_phase_file</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="n">return_spline</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Read a basic phase file and return its content.</span>

<span class="sd">    :param file_path: Path to the phase file</span>

<span class="sd">    :param return_spline: If True a cubic spline</span>
<span class="sd">      (scipy.interpolate.UnivariateSpline instance) is returned</span>
<span class="sd">      instead of a tuple.</span>

<span class="sd">    :returns: a tuple (Phase axis [cm-1], Phase [radians]) or a</span>
<span class="sd">      scipy.interpolate.UnivariateSpline instance if return_spline is</span>
<span class="sd">      True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cm1_axis</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;#&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">line</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">cm1</span><span class="p">,</span> <span class="n">ph</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">cm1_axis</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">cm1</span><span class="p">))</span>
                <span class="n">phase</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ph</span><span class="p">))</span>
    <span class="n">cm1_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cm1_axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">return_spline</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cm1_axis</span><span class="p">,</span> <span class="n">phase</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">UnivariateSpline</span><span class="p">(</span>
            <span class="n">cm1_axis</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Thomas Martin (thomas.martin.1@ulaval.ca).
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
    </div>

    

    
  </body>
</html>