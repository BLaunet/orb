#!/usr/bin/env python -W ignore::FutureWarning
# *-* coding: utf-8 *-*
# Author: Thomas Martin <thomas.martin.1@ulaval.ca> based on
#   example1_gtk.py created by Eric Jeschke (eric@naoj.org) as a part of
#   Ginga (http://ejeschke.github.io/ginga/)
# File: orb-viewer

## Copyright (c) 2010-2014 Thomas Martin <thomas.martin.1@ulaval.ca>
## 
## This file is part of ORB
##
## ORB is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## ORB is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
## License for more details.
##
## You should have received a copy of the GNU General Public License
## along with ORB.  If not, see <http://www.gnu.org/licenses/>.


# BASIC IMPORTS
import sys, os
import logging
import threading



# GINGA IMPORTS
from ginga.gtkw.ImageViewCanvasGtk import ImageViewCanvas
from ginga.gtkw.ImageViewCanvasTypesGtk import DrawingCanvas, Point
import ginga.gtkw.Widgets
from ginga.gtkw import FileSelection, Plot
from ginga import AstroImage
from matplotlib.widgets import SpanSelector, RectangleSelector
from ginga.util import wcsmod
from ginga.util.wcsmod import AstropyWCS
wcsmod.use('astropy')

# ORB IMPORTS
from orb.core import Tools, Cube, Lines
import orb.utils
from orb.astrometry import Astrometry


# OTHER IMPORTS
import gtk, gobject, glib
import gtk.gdk
import numpy as np
from  matplotlib.backends.backend_gtkcairo import FigureCanvasGTKCairo as FigureCanvas
import astropy.wcs as pywcs

gobject.threads_init()

###########################################
### CLASS ZPLOT ###########################
###########################################

class ZPlot(Plot.Plot):

    ax2 = None

    zregion = None
    
    plot_xarr = None
    plot_yarr = None
    
    plot2_xarr = None
    plot2_yarr = None

    xlim1 = None
    xlim2 = None
    ylim1 = None
    ylim2 = None

    axvlines = None
    fitted_vector = None

    channels = ['1', '2', '3', 'S']
    channel = '1'

    modes = ['ax1' , 'ax2', 'both']

    wavenumber = None

    _kwdargs = None
    
    span_selector1 = None
    span_selector1_cb = None
    span_selector1_onmove_cb = None
    rect_selector1 = None
    rect_selector2 = None
    

    def change_mode(self, mode):
        """
        Change visualization mode when 2 graph are displayed.
    
        :param mode: Can be 'ax1', 'ax2' or 'both'. If 'ax1', only the
          ax1 graph is displayed. If 'ax2', only ax2 graph is
          displayed. If 'both', both graphs are displayed.
        """
        if mode in self.modes:
            self.mode = mode
        else: return None

        if self.mode == 'ax1':
            if self.ax2 is not None: self.fig.delaxes(self.ax2)
            if self.ax1 is not None: self.fig.delaxes(self.ax1)
            
            self.ax2 = None
            self.ax1 = self.fig.add_subplot(111, **self._kwdargs)
            self.fig.canvas.draw()
            self._draw()

        if self.mode == 'ax2':
            if self.ax2 is not None: self.fig.delaxes(self.ax2)
            if self.ax1 is not None: self.fig.delaxes(self.ax1)
            self.ax1 = None
            self.ax2 = self.fig.add_subplot(111, **self._kwdargs)
            self.fig.canvas.draw()
            self._draw()

        if self.mode == 'both':
            if self.ax2 is not None: self.fig.delaxes(self.ax2)
            if self.ax1 is not None: self.fig.delaxes(self.ax1)
            self.ax1 = self.fig.add_subplot(211, **self._kwdargs)
            self.ax2 = self.fig.add_subplot(212, **self._kwdargs)
            self.fig.canvas.draw()
            self._draw()
    

    def _get_null_array(self):
        null_arr = dict()
        for channel in self.channels:
            null_arr[channel] = None
        return null_arr
    
    def add_axis(self, ax2=False, wavenumber=None, **kwdargs):
        self._kwdargs = kwdargs
        self.wavenumber = wavenumber
        self.fig.set_tight_layout(True)
        self.fitted_vector = self._get_null_array()
        self.plot_xarr = self._get_null_array()
        self.plot_yarr = self._get_null_array()
        if ax2:
            self.ax1 = self.fig.add_subplot(211, **self._kwdargs)
            self.ax2 = self.fig.add_subplot(212, **self._kwdargs)
            self.plot2_xarr = self._get_null_array()
            self.plot2_yarr = self._get_null_array()
        else:
            self.ax1 = self.fig.add_subplot(111, **self._kwdargs)
        return self.ax1

    def clear(self):
        self.logger.debug('clearing canvas...')
        if self.ax1 is not None:
            self.ax1.cla()
        if self.plot_yarr is not None:
            self.plot_yarr[self.channel] = None
            
        if self.ax2 is not None:
            self.ax2.cla()
        if self.plot2_yarr is not None:
            self.plot2_yarr[self.channel] = None
        
        self.fitted_vector[self.channel] = None


    def plot(self, xarr, yarr):
        if xarr.shape[0] != yarr.shape[0]:
            xarr = orb.utils.interpolate_size(xarr, yarr.shape[0], 1)
        self.plot_xarr[self.channel] = xarr
        self.plot_yarr[self.channel] = yarr        
        self._draw()
        
    def plot2(self, xarr, yarr):
        if xarr.shape[0] != yarr.shape[0]:
            xarr = orb.utils.interpolate_size(xarr, yarr.shape[0], 1)
        self.plot2_xarr[self.channel] = xarr
        self.plot2_yarr[self.channel] = yarr
        self._draw()
        
    def set_axvlines(self, axvlines):
        self.axvlines = axvlines
        self._draw()

    def add_fitted_vector(self, fitted_vector):
        self.fitted_vector[self.channel] = fitted_vector
        self._draw()

    def redraw(self):
        self._draw()

    def set_xlim1(self, xlim1):
        self.xlim1 = xlim1

    def set_xlim2(self, xlim2):
        self.xlim2 = xlim2

    def set_ylim1(self, ylim1):
        self.ylim1 = ylim1

    def set_ylim2(self, ylim2):
        self.ylim2 = ylim2

    def set_channel(self, index):
        if index in self.channels:
            self.channel = index
        self._draw()
       
    def _draw(self):
        
        if self.ax1 is not None:
            self.ax1.cla()
            
            if self.plot_yarr[self.channel] is not None:
                if self.xlim1 is not None:
                    self.ax1.set_xlim(self.xlim1)
                    
                if self.ylim1 is not None:
                    self.ax1.set_ylim(self.ylim1)
                else:
                    self.ax1.set_ylim(
                        [np.nanmin(self.plot_yarr[self.channel]),
                         np.nanmax(self.plot_yarr[self.channel])])
                    
                self.ax1.grid(True)
                self.ax1.plot(self.plot_xarr[self.channel],
                              self.plot_yarr[self.channel], color='0.',
                              linewidth=1.)
                if (self.fitted_vector[self.channel] is not None
                    and self.ax2 is None):
                    self.ax1.plot(self.plot_xarr[self.channel],
                                  self.fitted_vector[self.channel],
                                  color='0.5', linewidth=1.)
                if self.zregion is not None:
                    self.ax1.fill_between(
                        self.plot_xarr[self.channel][
                            self.zregion[0]:self.zregion[1]],
                        self.ax1.get_ylim()[0],
                        self.ax1.get_ylim()[1],
                        facecolor='red', alpha=0.5)
        
        if self.ax2 is not None:
            self.ax2.cla()

            if self.plot2_yarr[self.channel] is not None:
                if self.ylim2 is not None:
                    self.ax2.set_ylim(self.ylim2)
                else:
                    self.ax2.set_ylim(
                        [np.nanmin(self.plot2_yarr[self.channel]),
                         np.nanmax(self.plot2_yarr[self.channel])])
                if self.xlim2 is not None:
                    self.ax2.set_xlim(self.xlim2)
                    
                self.ax2.grid(True)
                self.ax2.plot(self.plot2_xarr[self.channel],
                              self.plot2_yarr[self.channel], color='0.',
                         linewidth=1.)
                if self.fitted_vector[self.channel] is not None:
                    self.ax2.plot(self.plot2_xarr[self.channel],
                                  self.fitted_vector[self.channel],
                                  color='0.5', linewidth=1.)
                    
        
                
        if self.axvlines is not None:
            for x in self.axvlines:
                if self.ax2 is not None:
                    self.ax2.axvline(x=x, color='0.', alpha=0.5)
                elif self.ax1 is not None:
                    self.ax1.axvline(x=x, color='0.', alpha=0.5)

        if self.wavenumber is None:
            if self.ax1 is not None:
                self.ax1.set_xlabel('Step')
            if self.ax2 is not None:
                self.ax2.set_xlabel('Wavelength [nm]')
                
        elif self.ax1 is not None:
            if self.wavenumber:
                self.ax1.set_xlabel('Wavenumber [cm-1]')
            else:
                self.ax1.set_xlabel('Wavelength [nm]')
                    
        self.fig.canvas.draw()
        self.start_plot_widgets()
        
            


               
    def zoom_ax1(self, eclick, erelease):
        xlim = [np.min((eclick.xdata, erelease.xdata)),
                np.max((eclick.xdata, erelease.xdata))]
        if (xlim[1] - xlim[0]
            < (self.plot_xarr[self.channel][1]
               - self.plot_xarr[self.channel][0])):
            self.unzoom() ; return
        self.set_xlim1(xlim)

        ylim = [np.min((eclick.ydata, erelease.ydata)),
                np.max((eclick.ydata, erelease.ydata))]
        if (ylim[1] - ylim[0]
            < (self.plot_yarr[self.channel][1]
               - self.plot_yarr[self.channel][0])):
            self.unzoom() ; return
        self.set_ylim1(ylim)
        
        self._draw()

    def zoom_ax2(self, eclick, erelease):
        xlim = [np.min((eclick.xdata, erelease.xdata)),
                np.max((eclick.xdata, erelease.xdata))]
        if (xlim[1] - xlim[0]
            < (self.plot2_xarr[self.channel][1]
               - self.plot2_xarr[self.channel][0])):
            self.unzoom() ; return
        self.set_xlim2(xlim)

        ylim = [np.min((eclick.ydata, erelease.ydata)),
                np.max((eclick.ydata, erelease.ydata))]
        if (ylim[1] - ylim[0]
            < (self.plot2_yarr[self.channel][1]
               - self.plot2_yarr[self.channel][0])):
            self.unzoom() ; return
        self.set_ylim2(ylim)
        
        self._draw()
        self.start_plot_widgets()

    def unzoom(self):
        self.set_ylim1(None)
        self.set_xlim1(None)
        self.set_ylim2(None)
        self.set_xlim2(None)
        self._draw()
        
    def start_plot_widgets(self):

        if self.ax1 is not None:
            self.span_selector1 = SpanSelector(
                self.ax1, self.span_selector1_cb, 'horizontal',
                onmove_callback=self.span_selector1_onmove_cb)
            
            self.rect_selector1 = RectangleSelector(
                self.ax1, self.zoom_ax1, drawtype=u'box', minspanx=None, minspany=None, useblit=False, lineprops=None, rectprops=None, spancoords=u'data', button=3)
            
        if self.ax2 is not None:
            self.rect_selector2 = RectangleSelector(
                self.ax2, self.zoom_ax2, drawtype=u'box', minspanx=None, minspany=None, useblit=False, lineprops=None, rectprops=None, spancoords=u'data', button=3)

###########################################
### CLASS CUBEVIEWER ######################
###########################################

class CubeViewer(object):

    filepath = None
    image = None
    continuum_frame = None

    large_cube_mode = None

    image_1 = None
    image_2 = None
    image_3 = None
    image_index = None
    init_set = None
    
    xy_start = None
    xy_stop = None
    spectrum = None
    
    mode = None
    key_pressed = None

    header = None
    order = None
    step = None
    apod = None
    dimx = None
    dimy = None
    dimz = None
    zaxis = None
    zaxis2 = None
    fit_axis = None
    spectrum_range = None
    interf_range = None
    wavenumber = None
    wcs = None
    fov = None
    astrom = None
    
    target_x = None
    target_y = None
    target_ra = None
    target_dec = None
    wcs_rotation = None
    target_point = None
    star_objects = None
    star_list_deg = None
    
    
    calib_map = None

    fitsimage = None
    root = None
    logger = None
    select = None
    canvas = None
    old_canvas_objs = None
    canvas_objects = None
    plot = None
    
    spectrum_channel = '1'
    mean_zvector = None
    image_region = None
    
    autocut_methods = None
    line_name = None
    fit_lines = None
    fit_lines_velocity = 0


    DRAW_COLOR_DEFAULT = 'green'
    DRAW_COLOR_SKY = 'lightblue'
    DRAW_COLOR_1 = 'lightgreen'
    DRAW_COLOR_2 = 'pink'
    DRAW_COLOR_3 = 'yellow'
    
    BAD_WCS_FLAG = False

    IMAGE_SIZE = 300

    MAX_CUBE_SIZE = 4. # Max cube size in Go
    MAX_CUBE_SECTION_SIZE = 1. # max section size to load in Go
    
    def __init__(self, logger, large_cube_mode, config_file_name='config.orb',
                 no_log=True):
        
        self.logger = logger
        self.select = FileSelection.FileSelection()
        self.large_cube_mode = large_cube_mode
        self.tools = Tools()
        self.tools._no_log = no_log
        self.tools.config_file_name = config_file_name
        self.image_index = 1
        self.init_set = True
        self.spectrum_channel = 1
        self.wcs_rotation = float(
            self.tools._get_config_parameter('WCS_ROTATION'))
        self.fov = float(
            self.tools._get_config_parameter('FIELD_OF_VIEW'))

        
        # Define GTK GUI
        root = gtk.Window(gtk.WINDOW_TOPLEVEL)
        root.set_title("ORB CubeViewer")
        root.set_border_width(2)
        root.connect("delete_event", lambda w, e: self.quit(w))
        self.root = root
                         
        # define ImageView
        fi = ImageViewCanvas(logger)
        fake_image = AstroImage.AstroImage(logger=self.logger)
        fake_image.set_data(np.zeros((10,10), dtype=float))
        fi.set_image(fake_image)
        fi.enable_autocuts('on')
        
        fi.set_autocut_params('zscale')
        
        fi.enable_autozoom('on')
        fi.set_callback('drag-drop', self.drop_file)
        fi.set_callback('none-move', self.motion)
        fi.set_callback('button-press', self.start_box)
        fi.set_callback('button-release', self.stop_box)
        fi.set_callback('key-press', self.key_pressed)
        fi.set_callback('key-release', self.key_released)
        fi.set_bg(0.2, 0.2, 0.2)
        
        fi.ui_setActive(True)
        self.fitsimage = fi
        self.autocut_methods = self.fitsimage.get_autocut_methods()
        
        bd = fi.get_bindings()
        bd.enable_all(True)
        bm = fi.get_bindmap()
        bm.add_callback('mode-set', self.mode_change_cb)
        
        # canvas that we will draw on
        canvas = DrawingCanvas()
        canvas.enable_draw(True)
        canvas.set_drawtype(
            'rectangle', color=self.DRAW_COLOR_DEFAULT, alpha=1)
        canvas.setSurface(fi)
        self.canvas = canvas
        # add canvas to view
        fi.add(canvas)
        canvas.ui_setActive(True)

        w = fi.get_widget()
        w.set_size_request(self.IMAGE_SIZE,self. IMAGE_SIZE)

        # BIG BOX
        bigbox = gtk.VBox(spacing=2)

        # RIGHT BOX
        rightbox = gtk.VBox(spacing=2)

        # FIT BOX
        fitframe = gtk.Frame('Spectrum Fit')
        fitbox = gtk.VBox(spacing=2)

        # Observation Params
        buttonbox = gtk.HBox()

        stepbox = gtk.VBox()
        self.wstep = gtk.Entry()
        self.wstep.set_width_chars(10)
        self.wstep.connect('changed', self.set_step)
        wstep_label = gtk.Label('Step (nm)')
        wstep_label.set_max_width_chars(10)
        
        stepbox.pack_start(wstep_label)
        stepbox.pack_start(self.wstep)
        
        orderbox = gtk.VBox()
        self.worder = gtk.Entry()
        self.worder.set_width_chars(10)
        self.worder.connect('changed', self.set_order)
        worder_label = gtk.Label('Order')
        worder_label.set_max_width_chars(10)
        orderbox.pack_start(worder_label)
        orderbox.pack_start(self.worder)

        apodbox = gtk.VBox()
        self.wapod = gtk.Entry()
        self.wapod.connect('changed', self.set_apod)
        self.wapod.set_width_chars(10)
        wapod_label = gtk.Label('Apod')
        wapod_label.set_max_width_chars(10)
        apodbox.pack_start(wapod_label)
        apodbox.pack_start(self.wapod)


        # calibration map
        calibbox = gtk.VBox()
        caliblabel = gtk.Label('Calibration Map')
        
        wcalib = gtk.FileChooserButton("Choose a calibration map")
        wcalib.connect('file-set', self.get_calib_map_path_cb)
        calibbox.pack_start(caliblabel)
        calibbox.pack_start(wcalib)
        
        for box in (stepbox, orderbox, apodbox, calibbox):
            buttonbox.pack_start(box, fill=False, expand=False)
            
        fitbox.pack_start(buttonbox, fill=False, expand=False)

        # define choose line box
        linebox = gtk.HBox(spacing=2)
        wselectline = ginga.gtkw.Widgets.ComboBox()
        for line in self.get_lines_keys():
            wselectline.append_text(line)
        wselectline.set_index(0)
        self.line_name = self.get_lines_keys()[0]
        wselectline.add_callback('activated', self.set_line_name)
        linebox.pack_start(wselectline.get_widget(), fill=True, expand=True)
        
        
        waddline = gtk.Button("+")
        waddline.connect('clicked', self.add_fit_line)
        linebox.pack_start(waddline, fill=True, expand=True)
        wdelline = gtk.Button("-")
        wdelline.connect('clicked', self.del_fit_line)
        linebox.pack_start(wdelline, fill=True, expand=True)

        fitbox.pack_start(linebox, fill=False, expand=False)

        # define velocity / redshift box
        velocitybox = gtk.HBox(spacing=2)
        wvelocity_label = gtk.Label('Velocity in km/s')
        self.wvelocity = gtk.SpinButton(climb_rate=1., digits=1)
        self.wvelocity.set_range(-1e6,1e6)
        self.wvelocity.set_increments(10,100)
        self.wvelocity.connect('value-changed', self.update_velocity_cb)
        velocitybox.pack_start(wvelocity_label, fill=True, expand=True)
        velocitybox.pack_start(self.wvelocity, fill=True, expand=True)
        wredshift_label = gtk.Label('Redshift')
        self.wredshift = gtk.Label('Redshift')
        self.wredshift = gtk.SpinButton(climb_rate=1., digits=4)
        self.wredshift.set_range(0, 1e8)
        self.wredshift.set_increments(0.01, 0.1)
        self.wredshift.connect('value-changed', self.update_velocity_cb)
        velocitybox.pack_start(wredshift_label, fill=True, expand=True)
        velocitybox.pack_start(self.wredshift, fill=True, expand=True)
        fitbox.pack_start(velocitybox, fill=False, expand=False)

        self.fit_lines_velocity = 0.
        self.fit_lines_redshift = 0.

        # fit spectrum button
        wfit = gtk.Button("Fit Spectrum")
        wfit.connect('clicked', self.fit_lines_in_spectrum)
        fitbox.pack_start(wfit, fill=False, expand=False)

        # fit results
        sw = gtk.ScrolledWindow()
        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)

        self.fit_results_store = gtk.ListStore(
            str, str, str, str, str, str, str)
        wfit_results = gtk.TreeView(self.fit_results_store)
        renderer = gtk.CellRendererText()
        col_name = gtk.TreeViewColumn("Name", renderer, text=0)
        col_line = gtk.TreeViewColumn("Line", renderer, text=1)
        col_hei = gtk.TreeViewColumn("Height", renderer, text=2)
        col_amp = gtk.TreeViewColumn("Amplitude", renderer, text=3)
        col_vel = gtk.TreeViewColumn("Velocity", renderer, text=4)
        col_fwhm = gtk.TreeViewColumn("FWHM", renderer, text=5)
        col_snr = gtk.TreeViewColumn("SNR", renderer, text=6)
        wfit_results.append_column(col_name)
        wfit_results.append_column(col_line)
        wfit_results.append_column(col_hei)
        wfit_results.append_column(col_amp)
        wfit_results.append_column(col_vel)
        wfit_results.append_column(col_fwhm)
        wfit_results.append_column(col_snr)
        
        sw.add(wfit_results)
        fitbox.pack_start(sw, fill=True, expand=True)

        fitframe.add(fitbox)
        rightbox.pack_start(fitframe, fill=True, expand=True)
        
        # WCS FRAME
        wcsframe = gtk.Frame('WCS')
        wcsframebox = gtk.VBox()

        targetlabel = gtk.Label('Target')
        self.wtarget = gtk.Entry()

        targetbox = gtk.HBox()
        targetbox.pack_start(targetlabel, fill=False, expand=False)
        targetbox.pack_start(self.wtarget, fill=False, expand=False)
        
        getcat = gtk.Button('Get Catalogue')
        getcat.connect('clicked', self.get_cat_cb)
        targetbox.pack_start(getcat, fill=False, expand=False)
        
        wcsframebox.pack_start(targetbox, fill=False, expand=False)

        shiftbox = gtk.HBox()
        wshiftxlabel = gtk.Label('X Shift')
        self.wshiftx = gtk.SpinButton(climb_rate=1., digits=1)
        self.wshiftx.set_range(-2000,2000)
        self.wshiftx.set_increments(1,10)
        self.wshiftx.connect('value-changed', self.update_target_position_cb)
        shiftbox.pack_start(wshiftxlabel, fill=False, expand=False)
        shiftbox.pack_start(self.wshiftx, fill=False, expand=False)
        wshiftylabel = gtk.Label('Y Shift')
        self.wshifty = gtk.SpinButton(climb_rate=1., digits=1)
        self.wshifty.set_range(-2000,2000)
        self.wshifty.set_increments(1,10)
        self.wshifty.connect('value-changed', self.update_target_position_cb)
        shiftbox.pack_start(wshiftylabel, fill=False, expand=False)
        shiftbox.pack_start(self.wshifty, fill=False, expand=False)
        wrotationlabel = gtk.Label('Rotation')
        self.wrotation = gtk.SpinButton(climb_rate=1., digits=1)
        self.wrotation.set_range(-180,180)
        self.wrotation.set_increments(0.1,1)
        self.wrotation.set_value(self.wcs_rotation)
        self.wrotation.connect('value-changed', self.update_wcs_rotation_cb)
        shiftbox.pack_start(wrotationlabel, fill=False, expand=False)
        shiftbox.pack_start(self.wrotation, fill=False, expand=False)
        wcsframebox.pack_start(shiftbox, fill=False, expand=False)

        registerbox = gtk.HBox()
        register = gtk.Button('Register')
        register.connect('clicked', self.register_cb)
        registerbox.pack_start(register)
        self.register_spinner = gtk.Spinner()
        self.register_spinner.stop()
        registerbox.pack_start(self.register_spinner, fill=False, expand=False)
        wcsframebox.pack_start(registerbox, expand=False)
        
        wcsframe.add(wcsframebox)
        rightbox.pack_start(wcsframe, fill=True, expand=True)
        
        # IMAGE FRAME
        imageframe = gtk.Frame('Image')
        imageframebox = gtk.VBox()

        # imageoptionsbox
        imageoptionsbox = gtk.HBox()
        autocutbox = gtk.VBox()
        wautocuts = ginga.gtkw.Widgets.ComboBox()
        for name in self.autocut_methods:
            wautocuts.append_text(name)
        wautocuts.set_index(4)
        wautocuts.add_callback('activated', self.set_autocut_method_cb)
        wautocuts_label = gtk.Label('Scale')
        autocutbox.pack_start(wautocuts_label)
        autocutbox.pack_start(wautocuts.widget)
        imageoptionsbox.pack_start(autocutbox, fill=False, expand=False)

        channelbox = gtk.VBox()
        channel_label = gtk.Label('Channel')
        channelsbox = gtk.HBox()
        self.channel1 = gtk.Button('1')
        self.channel1.connect('clicked', self.set_channel, 1)
        self.channel2 = gtk.Button('2')
        self.channel2.connect('clicked', self.set_channel, 2)
        self.channel3 = gtk.Button('3')
        self.channel3.connect('clicked', self.set_channel, 3)
        self.set_channel(self.channel1, 1)
        
        for box in (self.channel1, self.channel2, self.channel3):
            channelsbox.pack_start(box)
        channelbox.pack_start(channel_label)
        channelbox.pack_start(channelsbox)
        imageoptionsbox.pack_start(channelbox, fill=False, expand=False)

        spacebox = gtk.HBox()
        imageoptionsbox.pack_start(spacebox, fill=True, expand=True)

        savebox = gtk.VBox()
        saveimage_label = gtk.Label('')
        saveimage = gtk.Button('Save Image')
        saveimage.connect('clicked', self.save_image_cb)
        savebox.pack_start(saveimage)
        savebox.pack_start(saveimage_label)
        imageoptionsbox.pack_start(savebox, fill=False, expand=False)
        
        imageframebox.pack_start(imageoptionsbox, fill=False, expand=False)
        imageframebox.pack_start(w)
        
        # Coordsbox
        coordsbox = gtk.HBox()
        ra_label = gtk.Label('RA ')
        self.ra = gtk.Label('')
        self.ra.set_width_chars(13)
        dec_label = gtk.Label(' DEC ')
        self.dec = gtk.Label('')
        self.dec.set_width_chars(13)
        x_label = gtk.Label(' X ')
        self.x = gtk.Label('')
        self.x.set_width_chars(10)
        y_label = gtk.Label(' Y ')
        self.y = gtk.Label('')
        self.y.set_width_chars(10)
        value_label = gtk.Label(' Value ')
        self.value = gtk.Label('')
        self.value.set_width_chars(10)
        
        for box in (ra_label, self.ra, dec_label, self.dec,
                    x_label, self.x, y_label, self.y, value_label, self.value):
            coordsbox.pack_start(box)
        imageframebox.pack_start(coordsbox, fill=True, expand=False)

        # Statbox
        STAT_WIDTH = 10
        statsbox = gtk.HBox()
        mean_label = gtk.Label('MEAN ')
        self.mean = gtk.Label('')
        self.mean.set_width_chars(STAT_WIDTH)
        median_label = gtk.Label(' MED ')
        self.median = gtk.Label('')
        self.median.set_width_chars(STAT_WIDTH)
        std_label = gtk.Label(' STD ')
        self.std = gtk.Label('')
        self.std.set_width_chars(STAT_WIDTH)
        sum_label = gtk.Label(' SUM ')
        self.sum = gtk.Label('')
        self.sum.set_width_chars(STAT_WIDTH)
        surf_label = gtk.Label(' SURF ')
        self.surf = gtk.Label('')
        self.surf.set_width_chars(STAT_WIDTH)
        
        for box in (mean_label, self.mean, median_label, self.median,
                    std_label, self.std, sum_label, self.sum, surf_label,
                    self.surf):
            statsbox.pack_start(box)
        
        imageframebox.pack_start(statsbox, fill=True, expand=True)

        imageframe.add(imageframebox)
        
        # IMAGE BOX
        imagebox = gtk.HBox(spacing=2)
        imagebox.pack_start(imageframe, fill=True, expand=True)
        imagebox.pack_start(rightbox, fill=True, expand=False)
        
        # SPECTRUM BOX
        # Graph box
        self.plot = ZPlot(self.logger, width=5, height=3, dpi=75)
        self.plot.span_selector1_cb = self.select_zregion
        self.plot.span_selector1_onmove_cb = self.spanselector_onmove
        self.canvas_objs = dict()
        self.spectrum = dict()
        for channel in self.plot.channels:
            self.canvas_objs[channel] = None
            self.spectrum[channel] = None

        
        spectrumframe = gtk.Frame('Spectrum/Interferogram')
        spectrumbox = gtk.VBox(spacing=2)
        spectrum_optionline = gtk.HBox()
        
        spec_channelbox = gtk.VBox()
        spec_channel_label = gtk.Label('Channel')
        spec_channelsbox = gtk.HBox()
        self.spec_channel1 = gtk.Button('1')
        self.spec_channel1.connect('clicked', self.set_spectrum_channel_cb, '1')
        self.spec_channel2 = gtk.Button('2')
        self.spec_channel2.connect('clicked', self.set_spectrum_channel_cb, '2')
        self.spec_channel3 = gtk.Button('3')
        self.spec_channel3.connect('clicked', self.set_spectrum_channel_cb, '3')
        self.spec_channelS = gtk.Button('S')
        self.spec_channelS.connect('clicked', self.set_spectrum_channel_cb, 'S')
        
        
        for box in [self.spec_channel1, self.spec_channel2,
                    self.spec_channel3, self.spec_channelS]:
            spec_channelsbox.pack_start(box, fill=False, expand=False)
        spec_channelbox.pack_start(spec_channel_label, fill=False, expand=False)
        spec_channelbox.pack_start(spec_channelsbox, fill=False, expand=False)
        spectrum_optionline.pack_start(spec_channelbox, fill=False, expand=False)
        spacebox = gtk.HBox()
        spectrum_optionline.pack_start(spacebox, fill=True, expand=True)


        uzbox = gtk.VBox()
        uzspec_label = gtk.Label('')
        uzspec = gtk.Button('Unzoom')
        uzspec.connect('clicked', self.unzoom_spectrum_cb)
        uzbox.pack_start(uzspec)
        uzbox.pack_start(uzspec_label)
        spectrum_optionline.pack_start(uzbox, fill=False, expand=False)
        
        savebox = gtk.VBox()
        saveimage_label = gtk.Label('')
        saveimage = gtk.Button('Save Spectrum')
        saveimage.connect('clicked', self.save_spectrum_cb)
        savebox.pack_start(saveimage)
        savebox.pack_start(saveimage_label)
        spectrum_optionline.pack_start(savebox, fill=False, expand=False)

        self.modebox = gtk.VBox()
        changemode_label = gtk.Label('')
        changemode = ginga.gtkw.Widgets.ComboBox()
        for mode in ['interferogram', 'spectrum', 'both']:
            changemode.append_text(mode)
        changemode.set_index(0)
        changemode.add_callback('activated', self.set_plot_mode_cb)
        
        self.modebox.pack_start(changemode.get_widget())
        self.modebox.pack_start(changemode_label)
        spectrum_optionline.pack_start(self.modebox, fill=False, expand=False)
        
        spectrumbox.pack_start(spectrum_optionline, fill=True, expand=True)
        
        # plot widget defined before to create other widgets of the
        # 'spectrum box'
        spectrumbox.pack_start(self.plot.get_widget(), fill=False,
                               expand=False)

        # Messageline
        self.msgline = gtk.Label('')
        #self.msgline.set_justify(gtk.JUSTIFY_RIGHT)
        self.msgline.set_alignment(0, 0.5)
        spectrumbox.pack_start(self.msgline, fill=True, expand=True)
        
        spectrumframe.add(spectrumbox)

        # PACK BIGBOX
        bigbox.pack_start(imagebox, fill=False, expand=False)
        bigbox.pack_start(spectrumframe, fill=False, expand=False)
        
        root.add(bigbox)


    def unzoom_spectrum_cb(self, w):
        
        self.plot.unzoom()
        
    def set_plot_mode_cb(self, w, idx):
        self.plot.change_mode(self.plot.modes[idx])
        self.start_plot_widgets()

    def update_header(self):
        if self.filepath is not None:
            self.header.extend(self.wcs.wcs.to_header(), update=True)
            self.tools.write_fits(
                self.filepath, self.cube, fits_header=self.header)

    def register_cb(self, w):
        self.register_spinner.start()
        thread = threading.Thread(target=self.register)
        thread.start()

    def register(self):
        if np.all(self.image == 0.): return None

        if (self.target_x is None or self.target_y is None
            or self.target_ra is None or self.target_dec is None):
            return None

        image = self.image / np.max(self.image) * 10000.
        
        astrom = Astrometry(
            image, 2.5, self.fov,
            profile_name='gaussian',
            target_xy = [self.target_x, self.target_y],
            target_radec = [self.target_ra, self.target_dec],
            wcs_rotation=self.wcs_rotation)
        self.wcs.wcs = astrom.register(compute_precision=False)
        self.register_spinner.stop()
        self.BAD_WCS_FLAG = False
        self.update_header()

    def update_wcs_rotation_cb(self, w):
        self.wcs_rotation = self.wrotation.get_value()
        self.display_stars()

    def update_target_position_cb(self, w):
        self.target_x = self.dimx / 2. +  self.wshiftx.get_value()
        self.target_y = self.dimy / 2. +  self.wshifty.get_value()
        self.display_target()
        self.display_stars()
    
    def get_cat_cb(self, w):
        self.get_cat()
        

    def get_cat(self):
        target = self.wtarget.get_text()
        self.update_target_position_cb(None)
        self.display_target()

        if not self.BAD_WCS_FLAG:
            self.target_x, self.target_y = self.dimx/2., self.dimy/2.
            self.target_ra, self.target_dec = (
                self.wcs.wcs.wcs_pix2world(self.target_x, self.target_y, 1))
        else:
            if not target.isspace():
                
                self.target_ra, self.target_dec = orb.utils.query_sesame(target)
                self.target_ra = orb.utils.ra2deg(self.target_ra)
                self.target_dec = orb.utils.dec2deg(self.target_dec)
                
        self.astrom = Astrometry(
            self.image, 2.5, self.fov,
            profile_name='gaussian',
            target_xy = [self.target_x, self.target_y],
            target_radec = [self.target_ra, self.target_dec])
            
        self.star_list_deg = self.astrom.query_vizier(max_stars=500)
        self.display_stars()
        
    def display_stars(self):
        if self.star_list_deg is None: return None

        if not self.BAD_WCS_FLAG:
            ## Define a basic WCS
            delta = self.astrom.scale / 3600.
            wcs = pywcs.WCS(naxis=2)
            wcs.wcs.crpix = [self.target_x,  self.target_y]
            wcs.wcs.cdelt = np.array([-delta, delta])
            wcs.wcs.crval = [self.target_ra, self.target_dec]
            wcs.wcs.ctype = ["RA---TAN", "DEC--TAN"]
            wcs.wcs.crota = [self.wcs_rotation, self.wcs_rotation]
        else:
            wcs = self.wcs.wcs
        
        # Compute initial star positions from initial transformation
        # parameters
        full_star_list_pix = list()
        for istar in self.star_list_deg:
            pos = wcs.wcs_world2pix(istar[0], istar[1], 0)
            posx = pos[0] ; posy = pos[1]
            full_star_list_pix.append((posx, posy))
        star_list_pix = np.array(full_star_list_pix)
            
            
        # clear old stars
        if self.star_objects is not None:
            for obj in self.star_objects:
                self.canvas.objects.remove(obj)
        
        self.star_objects = list()
             
        for istar in star_list_pix:
            self.canvas.addObject(Point(istar[1], istar[0], 1))
            self.star_objects.append(self._get_new_object())
            
        self.canvas.redraw()
        
    def display_target(self):
        if (self.target_x is not None
            and self.target_y is not None
            and self.target_ra is not None
            and self.target_dec is not None):
            
            if self.target_point is not None:
                self.canvas.objects.remove(self.target_point)
      
            self.canvas.addObject(Point(self.target_y, self.target_x, 5))
            self.target_point = self._get_new_object()
            self.canvas.redraw()
            
        
    def set_spectrum_channel_cb(self, w, i):
        self.set_spectrum_channel(i)

    def set_spectrum_channel(self, i):
        self.plot.set_channel(i)
        self.spectrum_channel = str(self.plot.channel)
        self.update_spectrum_channels_color(i)
        self.plot.start_plot_widgets()
        
    def update_spectrum_channels_color(self, active_channel):
        states = [gtk.STATE_NORMAL, gtk.STATE_PRELIGHT]
      
        channels = self.plot.channels
        
        for channel in channels:
            if channel == active_channel:
                if channel == '1':
                    color = gtk.gdk.color_parse(self.DRAW_COLOR_1)
                elif channel == '2':
                    color = gtk.gdk.color_parse(self.DRAW_COLOR_2)
                elif channel == '3':
                    color = gtk.gdk.color_parse(self.DRAW_COLOR_3)
                elif channel == 'S':
                    color = gtk.gdk.color_parse(self.DRAW_COLOR_SKY)
            else:
                color = None
                
            if channel == '1':
                for state in states:
                    self.spec_channel1.modify_bg(state, color)
            elif channel == '2':
                for state in states:
                    self.spec_channel2.modify_bg(state, color)
            elif channel == '3':
                for state in states:
                    self.spec_channel3.modify_bg(state, color)
            elif channel == 'S':
                for state in states:
                    self.spec_channelS.modify_bg(state, color)

    def set_channel(self, w, i):
        self.set_image_index(i)

    def update_channels_color(self, active_channel):
        states = [gtk.STATE_NORMAL, gtk.STATE_PRELIGHT]
      
        channels = [1,2,3]
        for channel in channels:
            if channel == active_channel:
                color = gtk.gdk.color_parse("light pink")
            else:
                color = None
                
            if channel == 1:
                for state in states:
                    self.channel1.modify_bg(state, color)
            elif channel == 2:
                for state in states:
                    self.channel2.modify_bg(state, color)
            elif channel == 3:
                for state in states:
                    self.channel3.modify_bg(state, color)


    def save_image_cb(self, w):
        self.pop_save_file_dialog(self.save_image)

    def save_spectrum_cb(self, w):
        if self.spectrum[self.spectrum_channel] is not None:
            self.pop_save_file_dialog(self.save_spectrum)

    def pop_save_file_dialog(self, action):
        fc = gtk.FileChooserDialog(
            title='Save Image as ...',
            parent=self.root,
            buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                     gtk.STOCK_SAVE, gtk.RESPONSE_OK),
            action=gtk.FILE_CHOOSER_ACTION_SAVE)
        response = fc.run()

        
        if response == gtk.RESPONSE_OK:
            filepath = fc.get_filename()
            fc.destroy()
            action(filepath)
            
        elif response == gtk.RESPONSE_CANCEL:
            fc.destroy()
        
    def save_image(self, filepath):
        self.tools.write_fits(
            filepath, self.image, fits_header=self.header, overwrite=True)

    def save_spectrum(self, filepath):
        self.tools.write_fits(
            filepath, self.spectrum[self.spectrum_channel],
            fits_header=self.header, overwrite=True)
    

    def key_pressed(self, w, key):
        if key == 'KP_1':
            self.set_image_index(1)
        elif key == 'KP_2':
            self.set_image_index(2)
        elif key == 'KP_3':
            self.set_image_index(3)
        else:
            self.key_pressed = key

    def key_released(self, w, key):
        self.key_pressed = None

    def get_calib_map_path_cb(self, w):
        self.set_calib_map(w.get_filename())

    def set_calib_map(self, file_path):
        self.calib_map = self.tools.read_fits(file_path)
        self.calib_map = orb.utils.interpolate_map(self.calib_map, self.dimx,
                                                   self.dimy)
        

    def set_step(self, w):
        self.step = float(w.get_text())
        self.create_zaxes()

    def set_order(self, w):
        self.order = int(float(w.get_text()))
        self.create_zaxes()

    def set_apod(self, w):
        if w.get_text() == 'None': self.apod = 1.0
        else: self.apod = float(w.get_text())

    def fit_lines_in_spectrum(self, w):
        if (self.fit_lines is not None
            and self.spectrum[self.spectrum_channel] is not None
            and self.step is not None and self.order is not None):
            if len(self.fit_lines) > 0:

                
                lines = orb.utils.nm2pix(self.fit_axis, self.get_fit_lines())
                
                # remove lines that are not in the spectral range
                if self.wavenumber:
                    spectrum_range = orb.utils.cm12pix(self.fit_axis,
                                                       self.spectrum_range)
                else:
                    spectrum_range = orb.utils.nm2pix(self.fit_axis,
                                                      self.spectrum_range)

                lines = [line for line in lines
                         if (line > np.nanmin(spectrum_range)
                             and line < np.nanmax(spectrum_range))]


                if self.apod == 1.0: fmodel = 'sinc'
                else: fmodel = 'gaussian'

                # guess fwhm
                fwhm_guess = orb.utils.compute_line_fwhm(
                    self.dimz, self.step, self.order, apod_coeff=self.apod,
                    wavenumber=self.wavenumber)
                if self.wavenumber:
                    fwhm_guess_pix = orb.utils.cm12pix(
                        self.fit_axis, self.fit_axis[0] + fwhm_guess)
                else:
                    fwhm_guess_pix = orb.utils.nm2pix(
                        self.fit_axis, self.fit_axis[0] + fwhm_guess)
                
                fit_results = orb.utils.fit_lines_in_vector(
                    self.spectrum[self.spectrum_channel],
                    lines, fwhm_guess=fwhm_guess_pix,
                    signal_range=[np.nanmin(spectrum_range),
                                  np.nanmax(spectrum_range)],
                    return_fitted_vector=True, wavenumber=self.wavenumber,
                    observation_params=[self.step, self.order],
                    fmodel=fmodel)
                
                self.plot.add_fitted_vector(fit_results['fitted-vector'])
                self.plot.start_plot_widgets()

                # print results
                par = fit_results['lines-params']
                par_err = fit_results['lines-params-err']
                self.fit_results_store.clear()
                for iline in range(len(self.fit_lines)):
                    store = np.zeros(7, dtype=float)
                    store[2] = par[iline][0]
                    store[3] = par[iline][1]
                    
                    # convert velocity in km/s
                    if self.wavenumber:
                        pos = orb.utils.pix2cm1(self.fit_axis, par[iline][2])
                    else:
                        pos = orb.utils.pix2nm(self.fit_axis, par[iline][2])
                        
                    store[4] = orb.utils.compute_radial_velocity(pos,
                        self.fit_lines[iline], wavenumber=self.wavenumber)
                    
                    store[5] = par[iline][3] * abs(
                        self.fit_axis[1] - self.fit_axis[0])
                    store = ['{:.2e}'.format(store[i])
                             for i in range(store.shape[0])]

                    if self.wavenumber:
                        store[0] = Lines().get_line_name(
                            orb.utils.cm12nm(self.fit_lines[iline]))
                    else:
                        store[0] = Lines().get_line_name(
                            self.fit_lines[iline])
                        
                    store[1] = '{:.3f}'.format(self.fit_lines[iline])
                    store[6] = '{:.1f}'.format(
                        par[iline][1] / par_err[iline][1])
                    
                    self.fit_results_store.append(store)

                    
    def get_lines_keys(self):
        keys = Lines().air_lines_nm.keys()
        keys.sort()
        keys.append('Filter lines')
        keys.append('Sky lines')
        return keys
     
    def get_line_nm(self, line_name):
        
        if self.spectrum_range is None:
            return None

        if line_name == 'Sky lines':
            delta_nm = orb.utils.compute_line_fwhm(
                    self.dimz, self.step, self.order, apod_coeff=self.apod,
                    wavenumber=False)
            if self.wavenumber:
                nm_max, nm_min = orb.utils.cm12nm(self.spectrum_range)
            else:
                nm_min, nm_max = self.spectrum_range
            return Lines().get_sky_lines(nm_min, nm_max, delta_nm)

        elif line_name == 'Filter lines':
            filter_lines = list()
            all_lines = Lines().air_lines_nm
        
            for line in all_lines.keys():
                line_nm = all_lines[line]
                if self.wavenumber:
                    line_nm = orb.utils.nm2cm1(line_nm)
                
                if (line_nm > np.nanmin(self.spectrum_range) and
                    line_nm < np.nanmax(self.spectrum_range)):
                    if self.wavenumber:
                        filter_lines.append(orb.utils.cm12nm(line_nm))
                    else:
                        filter_lines.append(line_nm)
            
            return filter_lines
            
        else:
            return Lines().get_line_nm(line_name)
 
    def update_velocity_cb(self, w):
        self.fit_lines_velocity = self.wvelocity.get_value()
        self.fit_lines_redshift = self.wredshift.get_value()
        self.plot_fit_lines()
        
    def get_fit_lines(self):
        if self.fit_lines is not None:
            fit_lines = (np.array(self.fit_lines)
                         + np.array(orb.utils.line_shift(
                             self.fit_lines_velocity, self.fit_lines,
                             wavenumber=self.wavenumber)))
            if self.wavenumber:
                return fit_lines / (1.+self.fit_lines_redshift)
            else:
                return fit_lines * (1.+self.fit_lines_redshift)
        else:
            return None
        

    def add_fit_line(self, w):
        """Add a line to the list of lines to fit.

        Action called by the '+' button.
        """
        self.change_fit_lines(w, True)

        
    def del_fit_line(self, w):
        self.change_fit_lines(w, False)
        
    def change_fit_lines(self, w, add):
    
        if self.fit_lines is None:
            self.fit_lines = []

        new_lines = list()
        new_lines = self.get_line_nm(self.line_name)
        
        if new_lines is None:
            return None
        
        if isinstance(new_lines, float):
            new_lines = list([new_lines])
        
        if self.wavenumber:
            new_lines = orb.utils.nm2cm1(new_lines)

        
        for new_line in new_lines:
            if add:
                if new_line not in self.fit_lines:
                    if self.fit_axis is not None:
                        self.fit_lines.append(new_line)
            elif new_line in self.fit_lines:
                self.fit_lines.remove(new_line)
                
                
        # add lines to table
        self.fit_results_store.clear()
        for line in self.get_fit_lines():
            store = list(np.zeros(7, dtype=float))
            if self.wavenumber:
                store[0] = Lines().get_line_name(
                    orb.utils.cm12nm(line))
            else:
                store[0] = Lines().get_line_name(line)
                        
                store[1] = '{:.3f}'.format(line)
            self.fit_results_store.append(store)

        # add lines to plot
        self.plot_fit_lines()
        
        
    def plot_fit_lines(self):
        if self.fit_lines is not None:
            self.plot.set_axvlines(self.get_fit_lines())
            self.plot.start_plot_widgets()
            
    def clear_plot(self):
        self.plot.clear()
        self.plot_fit_lines()

        
    def set_line_name(self, w, idx):
        self.line_name = self.get_lines_keys()[idx]

    def set_autocut_method_cb(self, w, idx):
        self.fitsimage.set_autocut_params(self.autocut_methods[idx])

    def spanselector_onmove(self, zmin, zmax):
        if self.spectrum_range is None:
            return None
        
        self.msgline.set_text('Region selected: min {:.1f} | max: {:.1f} | width: {:.1f}'.format(zmin, zmax, abs(zmax-zmin)))
        

    def select_zregion(self, zmin, zmax):
        
        MIN_REGION_SIZE = 1
        
        if self.spectrum_range is None:
            return None
        elif (zmin < np.nanmin(self.spectrum_range)
              or zmax > np.nanmax(self.spectrum_range)):
            self.msgline.set_text('Region not in range')
            return None
        
        if zmax-zmin < MIN_REGION_SIZE:
            self.msgline.set_text('Region too small')
            return None
        
        if self.continuum_frame is None:
            self.continuum_frame = np.zeros((self.dimx, self.dimy), dtype=float)
        else:
            if np.all(
                np.isnan(self.continuum_frame*1.)
                + self.continuum_frame*1. == 0):
                self.continuum_frame = np.zeros((self.dimx, self.dimy), dtype=float)

        
        self.msgline.set_text('Region selected: min {:.1f} | max: {:.1f} | width: {:.1f}'.format(zmin, zmax, abs(zmax-zmin)))
        
        indmin, indmax = np.searchsorted(self.zaxis, (zmin, zmax))
        
        self.plot.zregion = [indmin, indmax]
        self.interf_range = [indmin, indmax]
        self.update_graph()

        section_size = self.dimx * self.dimy * (indmax-indmin) * 8 / 1e9
        if section_size > self.MAX_CUBE_SECTION_SIZE:
            print 'Error: deep frame is too big to be created ({:} Go)'.format(section_size)
            return None
        
        deep_frame = np.nanmean(self.cube[:,:,indmin:indmax], axis=2)
        
        if self.key_pressed != 'KP_0':
            deep_frame -= self.continuum_frame
        
        if self.image is not None:
            if self.key_pressed == 'KP_Divide':
                result_frame = self.image / deep_frame
            elif self.key_pressed == 'KP_Multiply':
                result_frame = self.image * deep_frame
            elif self.key_pressed == 'KP_Add':
                result_frame = self.image + deep_frame
            elif self.key_pressed == 'KP_Subtract':
                result_frame = self.image - deep_frame
            elif self.key_pressed == 'KP_0':
                self.msgline.set_text('Continuum image set')
                self.continuum_frame = deep_frame
                result_frame = self.image
            else:
                result_frame = deep_frame
        else:
            result_frame = deep_frame

        self.set_image(result_frame)
        

    def set_image_index(self, index):
        
        if self.image_index is not None and self.image is not None:
            if self.image_index == 1:
                self.image_1 = np.copy(self.image)
            elif self.image_index == 2:
                self.image_2 = np.copy(self.image)
            elif self.image_index == 3:
                self.image_3 = np.copy(self.image)
            
        if index == 1:
            if self.image_1 is not None:
                self.image = np.copy(self.image_1)
            else:
                self.image = None
            self.image_index = 1
        elif index == 2:
            if self.image_2 is not None:
                self.image = np.copy(self.image_2)
            else:
                self.image = None
            self.image_index = 2
        elif index == 3:
            if self.image_3 is not None:
                self.image = np.copy(self.image_3)
            else:
                self.image = None
            self.image_index = 3
            
        self.set_image(self.image)
        self.update_channels_color(index)

    def set_image(self, im):
        if self.dimx is None or self.dimy is None:
            return None

        if im is None:
            im = np.zeros((self.dimx, self.dimy))
        self.image = im
        
        image = AstroImage.AstroImage(logger=self.logger)
        image.set_data(self.image)
        if self.wcs is not None:
            image.set_wcs(self.wcs)
            
        if self.fitsimage is not None:
            if not self.init_set:
                self.fitsimage.enable_autozoom('off')
                self.fitsimage.set_autocenter('off')
                self.fitsimage.set_image(image)
            else:
                self.fitsimage.transform(False, False, True)
                self.fitsimage.set_image(image)
            
        if self.init_set:
            self.init_set = False
            
        
    

    def mode_change_cb(self, bindmap, mode, modetype):
        self.mode = mode
        if mode in ['shift', 'ctrl']:
            self.canvas.enable_draw(False)
        else:
            self.canvas.enable_draw(True)

    def start_box(self, fitsimage, button, data_x, data_y):
        if self.mode not in ['ctrl', 'shift'] and button == 4:
            if self.key_pressed == 'k' or self.spectrum_channel == 'S':
                self.sky_mode = True
                self.set_spectrum_channel('S')
                self.msgline.set_text('Setting sky spectrum')
            else:
                self.sky_mode = False
                self.set_spectrum_channel(self.spectrum_channel)
                self.msgline.set_text('Setting spectrum on channel {}'.format(
                    self.spectrum_channel))
                
                
            self.xy_start = (data_x, data_y)
            
            if not self.sky_mode:
                self.plot.set_channel(self.spectrum_channel)
            else:
                self.plot.set_channel('S')
   
            if self.spectrum_channel == '1':
                self.canvas.set_drawcolor(self.DRAW_COLOR_1)
            elif self.spectrum_channel == '2':
                self.canvas.set_drawcolor(self.DRAW_COLOR_2)
            elif self.spectrum_channel == '3':
                self.canvas.set_drawcolor(self.DRAW_COLOR_3)
            elif self.spectrum_channel == 'S':
                self.canvas.set_drawcolor(self.DRAW_COLOR_SKY)
            
            self.canvas.deleteObject(
                self.canvas_objs[self.spectrum_channel])

            self.clear_plot()
                
    def _get_new_object(self):
        objs = self.canvas.getObjects()
        if self.old_canvas_objs is None:
            self.old_canvas_objs = list(objs)
            return objs[0]
        else:
            for obj in objs:
                if obj not in self.old_canvas_objs:
                    self.old_canvas_objs = list(objs)
                    return obj
            self.old_canvas_objs = list(objs)
            return None
            
        
    def stop_box(self, fitsimage, button, data_x, data_y):
        if self.mode not in ['ctrl', 'shift'] and button == 4:

            self.create_zaxes()
            
            self.xy_stop = (data_x, data_y)

            
            y_range = [min(self.xy_start[0], self.xy_stop[0]),
                       max(self.xy_start[0], self.xy_stop[0])]
            x_range = [min(self.xy_start[1], self.xy_stop[1]),
                       max(self.xy_start[1], self.xy_stop[1])]


            if x_range[1] - x_range[0] < 1.:
                 x_range[1] = x_range[0] + 1
            if y_range[1] - y_range[0] < 1.:
                 y_range[1] = y_range[0] + 1 
                 
            region = self.cube[x_range[0]:x_range[1],
                               y_range[0]:y_range[1],:]
            
            if self.image is not None:
                self.image_region = self.image[x_range[0]:x_range[1],
                                          y_range[0]:y_range[1]]
                
                self.mean.set_text('{:.3e}'.format(
                    np.nanmean(self.image_region)))
                self.median.set_text('{:.3e}'.format(
                    orb.utils.robust_median(self.image_region)))
                self.std.set_text('{:.3e}'.format(
                    np.nanstd(self.image_region)))
                self.sum.set_text('{:.3e}'.format(
                    np.nansum(self.image_region)))
                self.surf.set_text('{:.2e}'.format(
                    self.image_region.size))
                          
            self.mean_zvector = np.squeeze(np.nansum(np.nansum(
                region, axis=0), axis=0))
            
            self.update_graph()
            
    def update_graph(self):

        if self.mean_zvector is None: return None

        if self.wavenumber is None: # cube is an interferogram cube

            if self.interf_range is not None:
                interf = self.mean_zvector[
                    np.nanmin(self.interf_range):np.nanmax(self.interf_range)]
            else:
                interf = np.copy(self.mean_zvector)

            if self.step is None or self.order is None:
                interf_fft = orb.utils.raw_fft(interf, '2.0')

            else:
                calib_nm_laser = float(
                    self.tools._get_config_parameter('CALIB_NM_LASER'))

                if self.calib_map is not None:
                    # hack: coords inverted
                    calib_coeff = self.calib_map[int(np.mean(y_range)),
                                                 int(np.mean(x_range))]
                else:
                    calib_coeff = calib_nm_laser
                interf_fft = orb.utils.transform_interferogram(
                    interf, calib_nm_laser, calib_coeff,
                    self.step, self.order, '2.0', 0, n_phase=0)

            interf_fft = orb.utils.interpolate_size(interf_fft,
                                                    self.dimz, 1)

            if self.sky_mode:
                self.spectrum['S'] = interf_fft / self.image_region.size
            else:
                self.spectrum[self.spectrum_channel] = interf_fft

        else:
            if self.sky_mode:
                self.spectrum['S'] = self.mean_zvector / self.image_region.size
            else:
                self.spectrum[self.spectrum_channel] = np.copy(
                    self.mean_zvector)

        # fix spectrum and remove sky
        self.spectrum[
                self.spectrum_channel][np.nonzero(self.spectrum[
                self.spectrum_channel] == 0)] = np.nan
        if not self.sky_mode:
            # remove sky
            if self.spectrum['S'] is not None:
                self.spectrum[self.spectrum_channel] -= (
                    self.spectrum['S'] * self.image_region.size)

        # get spectral range
        spectrum_range = self.fit_axis[np.nonzero(~np.isnan(
            self.spectrum[self.spectrum_channel]))]
        if np.array(spectrum_range).size > 0:
            self.spectrum_range = [np.nanmin(spectrum_range),
                                   np.nanmax(spectrum_range)]
        else:
            self.spectrum_range = [np.nanmin(self.fit_axis),
                                   np.nanmax(self.fit_axis)]

        self.plot.fitted_vector[self.spectrum_channel] = None
        
        if self.wavenumber is None:
            self.plot.plot(self.zaxis, self.mean_zvector)
            self.plot.plot2(self.zaxis2, self.spectrum[
                self.spectrum_channel])
        else:
            self.plot.plot(self.zaxis, self.spectrum[
                self.spectrum_channel])

        self.plot.start_plot_widgets()
        self.sky_mode = False

        # register new canvas object
        new_obj = self._get_new_object()
        if new_obj is not None:
            self.canvas_objs[self.spectrum_channel] = new_obj
        
        
    def motion(self, fitsimage, button, data_x, data_y):

        # Get the value under the data coordinates
        try:
            value = fitsimage.get_data(int(data_x+0.5), int(data_y+0.5))

        except Exception:
            value = None

        fits_x, fits_y = data_x + 1, data_y + 1

        # Calculate WCS RA/DEC
        try:
            ra, dec = self.wcs.wcs.wcs_pix2world(fits_y, fits_x, 0)
            ra_txt = '{:.0f}:{:.0f}:{:.1f}'.format(*orb.utils.deg2ra(ra))
            dec_txt = '{:.0f}:{:.0f}:{:.1f}'.format(*orb.utils.deg2dec(dec))
            
        except Exception as e:
            self.logger.warn("Bad coordinate conversion: %s" % (
                str(e)))
            ra_txt  = 'BAD WCS'
            dec_txt = 'BAD WCS'

        # hack: x/y inverted
        self.ra.set_text('{}'.format(ra_txt))
        self.dec.set_text('{}'.format(dec_txt))
        self.x.set_text('{:.2f}'.format(fits_y))
        self.y.set_text('{:.2f}'.format(fits_x))
        if value is not None:
            self.value.set_text('{:.2e}'.format(value))
        else:
            self.value.set_text('NaN')
        
    

    def get_widget(self):
        return self.root


    def create_zaxes(self):
        if (self.order is not None
            and self.step is not None):
            if self.wavenumber == False:
                self.zaxis = orb.utils.create_nm_axis(self.dimz,
                                                      self.step,
                                                      self.order)
                
            elif self.wavenumber == True:
                self.zaxis = orb.utils.create_cm1_axis(self.dimz,
                                                       self.step,
                                                       self.order)
            else: # interferogram cube
                self.zaxis2 = orb.utils.create_nm_axis(self.dimz,
                                                       self.step,
                                                       self.order)
        else:
            self.zaxis = np.arange(self.dimz)
            
            if self.wavenumber is None:
                self.zaxis2 = np.copy(self.zaxis)
                
        # set fit axis
        if self.wavenumber is None:
            self.fit_axis = np.copy(self.zaxis2)
        else:
            self.fit_axis = np.copy(self.zaxis)
        

    def load_file(self, filepath):
        
        if os.path.splitext(filepath)[-1] in ['.fits']:
            hdu = self.tools.read_fits(filepath, return_hdu_only=True)
            cube_size = float(hdu[0].header['NAXIS1']) * float(hdu[0].header['NAXIS2']) * float(hdu[0].header['NAXIS3']) * 4 / 1e9
            
            if cube_size > self.MAX_CUBE_SIZE:
                raise Exception('Cube size is too large: {} Go > {} Go'.format(cube_size, self.MAX_CUBE_SIZE))
                
            self.cube, self.header = self.tools.read_fits(filepath,
                                                          return_header=True,
                                                          memmap=True,
                                                          dtype=np.float32)
            
            self.filepath = filepath
            
        else:
            if large_cube_mode:
                self.cube = Cube(filepath)
                self.header = self.cube.get_frame_header(0)
            else:
                self.cube = Cube(filepath)[:,:,:]
                self.header = self.cube.get_frame_header(0)

        self.dimx, self.dimy, self.dimz = self.cube.shape

        
        # SET WCS
        self.wcs = AstropyWCS(self.logger)
        wcs_header = self.header
        if wcs_header['NAXIS'] == 3:
            wcs_header.remove('NAXIS')
            wcs_header.remove('NAXIS3')
            if 'CUNIT3' in wcs_header:
                wcs_header.remove('CUNIT3')
            if 'CTYPE3' in wcs_header:
                wcs_header.remove('CTYPE3')
            if 'CRVAL3' in wcs_header:
                wcs_header.remove('CRVAL3')
            if 'CRPIX3' in wcs_header:
                wcs_header.remove('CRPIX3')
            if 'CDELT3' in wcs_header:
                wcs_header.remove('CDELT3')
            if 'CROTA3' in wcs_header:
                wcs_header.remove('CROTA3')
                
            
                
        
        self.wcs.wcs = pywcs.WCS(wcs_header)
        
        try:
            ra, dec = self.wcs.wcs.wcs_pix2world(-1, -1, 0)
            if ra < 1e-15 and dec < 1e-15:
                raise Exception('BAD WCS')
            self.BAD_WCS_FLAG = False
        except Exception as e:
            print 'WCS Error: ', e
            self.BAD_WCS_FLAG = True
            
        image_data = self.cube[:,:,0]
        if np.all(np.isnan(image_data)):
            image_data.fill(0.)
            
        self.set_image(image_data)
        
        
        self.root.set_title(filepath)

        # CREATE ZAXIS
        if 'ORDER' in self.header:
            self.order = self.header['ORDER']
            self.worder.set_text(str(self.order))
            self.worder.set_editable(False)
            
        if 'STEP' in self.header:
            self.step = self.header['STEP']
            self.wstep.set_text(str(self.step))
            self.wstep.set_editable(False)

        if 'APODIZ' in self.header:
            self.apod = self.header['APODIZ']
            self.wapod.set_text(str(self.apod))
            self.wapod.set_editable(False)
            
        if 'WAVTYPE' in self.header:
            if self.header['WAVTYPE'] == 'WAVELENGTH':
                self.wavenumber = False
            elif self.header['WAVTYPE'] == 'WAVENUMBER':
                self.wavenumber = True
            else:
                self.wavenumber = None

        self.create_zaxes()
        
        if self.wavenumber is None:
            self.plot.add_axis(ax2=True,
                               wavenumber=self.wavenumber)
        else:
            self.modebox.set_sensitive(False)
            self.plot.add_axis(ax2=False,
                               wavenumber=self.wavenumber)
            
        self.plot.plot(self.zaxis, np.zeros(self.dimz))
        self.plot._draw()
        self.plot.start_plot_widgets()
        self.set_spectrum_channel('1')

        self.plot.change_mode('ax1')

    def open_file(self, w):
        self.select.popup("Open FITS file", self.load_file)

    def drop_file(self, fitsimage, paths):
        fileName = paths[0]
        self.load_file(fileName)
        
    def quit(self, w):
        gtk.main_quit()
        return True

###########################################
### MAIN ##################################
###########################################
    
def main(options, args, large_cube_mode):

    STD_FORMAT = '%(asctime)s | %(levelname)1.1s | %(filename)s:%(lineno)d (%(funcName)s) | %(message)s'
    
    logger = logging.getLogger("orb-viewer")
    logger.setLevel(options.loglevel)
    fmt = logging.Formatter(STD_FORMAT)
    if options.logfile:
        fileHdlr  = logging.handlers.RotatingFileHandler(options.logfile)
        fileHdlr.setLevel(options.loglevel)
        fileHdlr.setFormatter(fmt)
        logger.addHandler(fileHdlr)

    if options.logstderr:
        stderrHdlr = logging.StreamHandler()
        stderrHdlr.setLevel(options.loglevel)
        stderrHdlr.setFormatter(fmt)
        logger.addHandler(stderrHdlr)

    cv = CubeViewer(logger, large_cube_mode)
    root = cv.get_widget()
    root.show_all()

    if len(args) > 0:
        cv.load_file(args[0])

    gtk.main()

if __name__ == "__main__":
   
    # Parse command line options with nifty optparse module
    from optparse import OptionParser

    usage = "usage: %prog [options] cmd [args]"
    optprs = OptionParser(usage=usage, version=('%%prog'))
    
    optprs.add_option("--debug", dest="debug", default=False,
                      action="store_true",
                      help="Enter the pdb debugger on main()")
    optprs.add_option("--log", dest="logfile", metavar="FILE",
                      help="Write logging output to FILE")
    optprs.add_option("--loglevel", dest="loglevel", metavar="LEVEL",
                      type='int', default=logging.INFO,
                      help="Set logging level to LEVEL")
    optprs.add_option("--stderr", dest="logstderr", default=False,
                      action="store_true",
                      help="Copy logging also to stderr")
    optprs.add_option("--profile", dest="profile", action="store_true",
                      default=False,
                      help="Run the profiler on main()")
    optprs.add_option("--large", dest="large", action="store_true",
                      default=False,
                      help="A large data cube is not fully loaded in memory")

    (options, args) = optprs.parse_args(sys.argv[1:])

    if options.large:
        large_cube_mode = True
    else:
        large_cube_mode = False

    # Are we debugging this?
    if options.debug:
        import pdb

        pdb.run('main(options, args)')

    # Are we profiling this?
    elif options.profile:
        import profile

        print(("%s profile:" % sys.argv[0]))
        profile.run('main(options, args)')


    else:
        main(options, args, large_cube_mode)
        
# END

