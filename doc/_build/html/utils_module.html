

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Utils module &mdash; Orb 2.0-DR1-beta documentation</title>
  

  
  
    <link rel="shortcut icon" href="_static/logo.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/sphinx_paramlinks.css" type="text/css" />
  

  
    <link rel="top" title="Orb 2.0-DR1-beta documentation" href="index.html"/>
        <link rel="next" title="CUtils module" href="cutils_module.html"/>
        <link rel="prev" title="Core module" href="core_module.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Orb
          

          
            
            <img src="_static/logo_sidebar.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                2.0-DR1-beta
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="installing_orb.html">Installing Orb</a></li>
<li class="toctree-l1"><a class="reference internal" href="installing_python.html">Installing Python</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="python_for_orb.html">Python for ORB users</a></li>
<li class="toctree-l1"><a class="reference internal" href="data_analysis_with_orb.html">Data analysis with ORB</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="core_module.html">Core module</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Utils module</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.astrometry">Astrometry</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.debug">Debug</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.fft">FFT</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.filters">Filters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.image">Image</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.io">IO</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.misc">Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.parallel">Parallel</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.photometry">Photometry</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.pyneb">Pyneb</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.spectrum">Spectrum</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.stats">Stats</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.vector">Vector</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-orb.utils.web">Web</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="cutils_module.html">CUtils module</a></li>
<li class="toctree-l1"><a class="reference internal" href="astrometry_module.html">Astrometry module</a></li>
<li class="toctree-l1"><a class="reference internal" href="viewer_module.html">Viewer module</a></li>
<li class="toctree-l1"><a class="reference internal" href="fit_module.html">Fit module</a></li>
<li class="toctree-l1"><a class="reference internal" href="data_module.html">Data module</a></li>
<li class="toctree-l1"><a class="reference internal" href="constants_module.html">Constants module</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">Orb</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Utils module</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/utils_module.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="utils-module">
<span id="id1"></span><h1><a class="toc-backref" href="#id4">Utils module</a><a class="headerlink" href="#utils-module" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#utils-module" id="id4">Utils module</a><ul>
<li><a class="reference internal" href="#module-orb.utils.astrometry" id="id5">Astrometry</a></li>
<li><a class="reference internal" href="#module-orb.utils.debug" id="id6">Debug</a></li>
<li><a class="reference internal" href="#module-orb.utils.fft" id="id7">FFT</a></li>
<li><a class="reference internal" href="#module-orb.utils.filters" id="id8">Filters</a></li>
<li><a class="reference internal" href="#module-orb.utils.image" id="id9">Image</a></li>
<li><a class="reference internal" href="#module-orb.utils.io" id="id10">IO</a></li>
<li><a class="reference internal" href="#module-orb.utils.misc" id="id11">Miscellaneous</a></li>
<li><a class="reference internal" href="#module-orb.utils.parallel" id="id12">Parallel</a></li>
<li><a class="reference internal" href="#module-orb.utils.photometry" id="id13">Photometry</a></li>
<li><a class="reference internal" href="#module-orb.utils.pyneb" id="id14">Pyneb</a></li>
<li><a class="reference internal" href="#module-orb.utils.spectrum" id="id15">Spectrum</a></li>
<li><a class="reference internal" href="#module-orb.utils.stats" id="id16">Stats</a></li>
<li><a class="reference internal" href="#module-orb.utils.vector" id="id17">Vector</a></li>
<li><a class="reference internal" href="#module-orb.utils.web" id="id18">Web</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="module-orb.utils.astrometry">
<span id="astrometry"></span><h2><a class="toc-backref" href="#id5">Astrometry</a><a class="headerlink" href="#module-orb.utils.astrometry" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="orb.utils.astrometry.Gaussian">
<em class="property">class </em><code class="descclassname">orb.utils.astrometry.</code><code class="descname">Gaussian</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.utils.astrometry.PSF" title="orb.utils.astrometry.PSF"><code class="xref py py-class docutils literal"><span class="pre">orb.utils.astrometry.PSF</span></code></a></p>
<p>Class implementing the gaussian profile</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The Gaussian profile used here is:
<span class="math">\(f(x,y) = H + A \times \exp(\frac{-r^2}{2 W^2})\)</span></p>
<p>and,
<span class="math">\(r = (x - dx)^2 + (y - dy)^2\)</span></p>
<p class="last">The total flux F under the 2D profile is:
<span class="math">\(F = 2 \pi A W^2\)</span></p>
</div>
<dl class="method">
<dt id="orb.utils.astrometry.Gaussian.array2d">
<code class="descname">array2d</code><span class="sig-paren">(</span><em>nx</em>, <em>ny</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Gaussian.array2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 2D profile given the size of the returned
array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.astrometry.Gaussian.array2d.params.nx"></span><strong>nx</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.Gaussian.array2d.params.nx">¶</a> &#8211; Length of the returned array along x axis</li>
<li><span class="target" id="orb.utils.astrometry.Gaussian.array2d.params.ny"></span><strong>ny</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.Gaussian.array2d.params.ny">¶</a> &#8211; Length of the returned array along y axis</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.utils.astrometry.Gaussian.flux">
<code class="descname">flux</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Gaussian.flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total flux under the 2D profile.</p>
<p>The total flux F under a 2D profile is :
<span class="math">\(F = 2 \pi A W^2\)</span></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Under a 1d profile the flux is <span class="math">\(F = \sqrt{2\pi}A W\)</span></p>
</div>
</dd></dl>

<dl class="method">
<dt id="orb.utils.astrometry.Gaussian.flux_error">
<code class="descname">flux_error</code><span class="sig-paren">(</span><em>amplitude_err</em>, <em>width_err</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Gaussian.flux_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Return flux error.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.astrometry.Gaussian.flux_error.params.amplitude_err"></span><strong>amplitude_err</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.Gaussian.flux_error.params.amplitude_err">¶</a> &#8211; estimation of the amplitude error</li>
<li><span class="target" id="orb.utils.astrometry.Gaussian.flux_error.params.width_err"></span><strong>width_err</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.Gaussian.flux_error.params.width_err">¶</a> &#8211; estimation of the width error</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="orb.utils.astrometry.Gaussian.input_params">
<code class="descname">input_params</code><em class="property"> = ['height', 'amplitude', 'x', 'y', 'fwhm']</em><a class="headerlink" href="#orb.utils.astrometry.Gaussian.input_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Keys of the input parameters</p>
</dd></dl>

<dl class="attribute">
<dt id="orb.utils.astrometry.Gaussian.params">
<code class="descname">params</code><em class="property"> = {}</em><a class="headerlink" href="#orb.utils.astrometry.Gaussian.params" title="Permalink to this definition">¶</a></dt>
<dd><p>dictionary containing the parameters of the profile</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.utils.astrometry.Moffat">
<em class="property">class </em><code class="descclassname">orb.utils.astrometry.</code><code class="descname">Moffat</code><span class="sig-paren">(</span><em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Moffat" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#orb.utils.astrometry.PSF" title="orb.utils.astrometry.PSF"><code class="xref py py-class docutils literal"><span class="pre">orb.utils.astrometry.PSF</span></code></a></p>
<p>Class implementing the Moffat profile.</p>
<p>This profile is useful to fit stars on CCD arrays.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The Moffat profile has been first proposed by Moffat
(1969) A&amp;A. The exact form of the equation used has been derived
from Trujillo et al. (2001) MNRAS, 977. The PSF:</p>
<p><span class="math">\(f(x,y) = H + A \times [1+(\frac{r}{\alpha})^2]^{-\beta}\)</span></p>
<p>with,
<span class="math">\(\alpha = \frac{\text{FWHM}}{2\sqrt{2^{1/\beta} - 1}}\)</span></p>
<p>and,
<span class="math">\(r = (x - dx)^2 + (y - dy)^2\)</span></p>
<p class="last">The total flux F under the 2D profile is thus:
<span class="math">\(F = A \times \frac{\pi \alpha^2}{\beta - 1}\)</span></p>
</div>
<dl class="method">
<dt id="orb.utils.astrometry.Moffat.array2d">
<code class="descname">array2d</code><span class="sig-paren">(</span><em>nx</em>, <em>ny</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Moffat.array2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 2D profile given the size of the returned
array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.astrometry.Moffat.array2d.params.nx"></span><strong>nx</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.Moffat.array2d.params.nx">¶</a> &#8211; Length of the returned array along x axis</li>
<li><span class="target" id="orb.utils.astrometry.Moffat.array2d.params.ny"></span><strong>ny</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.Moffat.array2d.params.ny">¶</a> &#8211; Length of the returned array along y axis</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.utils.astrometry.Moffat.flux">
<code class="descname">flux</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Moffat.flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the total flux under the 2D profile.</p>
</dd></dl>

<dl class="method">
<dt id="orb.utils.astrometry.Moffat.flux_error">
<code class="descname">flux_error</code><span class="sig-paren">(</span><em>amplitude_err</em>, <em>width_err</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.Moffat.flux_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Return flux error.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.astrometry.Moffat.flux_error.params.amplitude_err"></span><strong>amplitude_err</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.Moffat.flux_error.params.amplitude_err">¶</a> &#8211; estimation of the amplitude error</li>
<li><span class="target" id="orb.utils.astrometry.Moffat.flux_error.params.width_err"></span><strong>width_err</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.Moffat.flux_error.params.width_err">¶</a> &#8211; estimation of the width error</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Not implemented yet!</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="orb.utils.astrometry.Moffat.input_params">
<code class="descname">input_params</code><em class="property"> = ['height', 'amplitude', 'x', 'y', 'fwhm', 'beta']</em><a class="headerlink" href="#orb.utils.astrometry.Moffat.input_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Keys of the input parameters</p>
</dd></dl>

<dl class="attribute">
<dt id="orb.utils.astrometry.Moffat.params">
<code class="descname">params</code><em class="property"> = {}</em><a class="headerlink" href="#orb.utils.astrometry.Moffat.params" title="Permalink to this definition">¶</a></dt>
<dd><p>dictionary containing the parameters of the profile</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="orb.utils.astrometry.PSF">
<em class="property">class </em><code class="descclassname">orb.utils.astrometry.</code><code class="descname">PSF</code><a class="headerlink" href="#orb.utils.astrometry.PSF" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>General class of inheritance for point spread functions (PSFs)</p>
<dl class="method">
<dt id="orb.utils.astrometry.PSF.array2d">
<code class="descname">array2d</code><span class="sig-paren">(</span><em>nx</em>, <em>ny</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.PSF.array2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 2D profile given the size of the returned
array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.astrometry.PSF.array2d.params.nx"></span><strong>nx</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.PSF.array2d.params.nx">¶</a> &#8211; Length of the returned array along x axis</li>
<li><span class="target" id="orb.utils.astrometry.PSF.array2d.params.ny"></span><strong>ny</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.PSF.array2d.params.ny">¶</a> &#8211; Length of the returned array along y axis</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="orb.utils.astrometry.PSF.varray2d">
<code class="descname">varray2d</code><span class="sig-paren">(</span><em>nx</em>, <em>ny</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.PSF.varray2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a vectorized 2D profile given the size of the returned
array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.astrometry.PSF.varray2d.params.nx"></span><strong>nx</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.PSF.varray2d.params.nx">¶</a> &#8211; Length of the returned array along x axis</li>
<li><span class="target" id="orb.utils.astrometry.PSF.varray2d.params.ny"></span><strong>ny</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.PSF.varray2d.params.ny">¶</a> &#8211; Length of the returned array along y axis</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.aperture_photometry">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">aperture_photometry</code><span class="sig-paren">(</span><em>star_box</em>, <em>fwhm_guess</em>, <em>background_guess=None</em>, <em>background_guess_err=0.0</em>, <em>aper_coeff=3.0</em>, <em>warn=True</em>, <em>x_guess=None</em>, <em>y_guess=None</em>, <em>return_surfaces=False</em>, <em>aperture_surface=None</em>, <em>annulus_surface=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.aperture_photometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the aperture photometry of a star centered in a star box.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="orb.utils.astrometry.aperture_photometry.params.star_box"></span><strong>star_box</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.aperture_photometry.params.star_box">¶</a> &#8211; Star box</li>
<li><span class="target" id="orb.utils.astrometry.aperture_photometry.params.fwhm_guess"></span><strong>fwhm_guess</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.aperture_photometry.params.fwhm_guess">¶</a> &#8211; Guessed FWHM. Used to get the aperture radius.</li>
<li><span class="target" id="orb.utils.astrometry.aperture_photometry.params.background_guess"></span><strong>background_guess</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.aperture_photometry.params.background_guess">¶</a> &#8211; (Optional) If not None, this guess is
used instead of the background determination in an annulus
around the star (default None).</li>
<li><span class="target" id="orb.utils.astrometry.aperture_photometry.params.background_guess_err"></span><strong>background_guess_err</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.aperture_photometry.params.background_guess_err">¶</a> &#8211; (Optional) Error on the background
guess. Used to compute the aperture photometry error (default 0.).</li>
<li><span class="target" id="orb.utils.astrometry.aperture_photometry.params.aper_coeff"></span><strong>aper_coeff</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.aperture_photometry.params.aper_coeff">¶</a> &#8211; (Optional) Aperture coefficient. The aperture
radius is Rap = aper_coeff * FWHM. Better when between 1.5 to
reduce the variation of the collected photons with varying FWHM
and 3. to account for the flux in the wings (default 3., better
for Moffat stars with a high SNR).</li>
<li><span class="target" id="orb.utils.astrometry.aperture_photometry.params.warn"></span><strong>warn</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.aperture_photometry.params.warn">¶</a> &#8211; (Optional) If True, print a warning when the background cannot
be well estimated (default True).</li>
<li><span class="target" id="orb.utils.astrometry.aperture_photometry.params.x_guess"></span><strong>x_guess</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.aperture_photometry.params.x_guess">¶</a> &#8211; (Optional) position of the star along x axis. If
None, star is assumed to lie at the very center of the frame
(default None).</li>
<li><span class="target" id="orb.utils.astrometry.aperture_photometry.params.y_guess"></span><strong>y_guess</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.aperture_photometry.params.y_guess">¶</a> &#8211; (Optional) position of the star along y axis. If
None, star is assumed to lie at the very center of the frame
(default None).</li>
<li><span class="target" id="orb.utils.astrometry.aperture_photometry.params.return_surfaces"></span><strong>return_surfaces</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.aperture_photometry.params.return_surfaces">¶</a> &#8211; (Optional) If True returns also the
aperture_surface and annulus_surface computed. Useful if
multiple stars with the same FWHM must be done (default False).</li>
<li><span class="target" id="orb.utils.astrometry.aperture_photometry.params.aperture_surface"></span><strong>aperture_surface</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.aperture_photometry.params.aperture_surface">¶</a> &#8211; (Optional) Pre-computed
aperture_surface. Accelerate the process for multiple stars with
the same FWHM but must be used with caution. aper_coeff is of no
use if aperture_surface if given (default None). See
<a class="reference internal" href="#orb.utils.astrometry.multi_aperture_photometry" title="orb.utils.astrometry.multi_aperture_photometry"><code class="xref py py-meth docutils literal"><span class="pre">orb.utils.astrometry.multi_aperture_photometry()</span></code></a>.</li>
<li><span class="target" id="orb.utils.astrometry.aperture_photometry.params.annulus_surface"></span><strong>annulus_surface</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.aperture_photometry.params.annulus_surface">¶</a> &#8211; (Optional) Pre-computed
annulus_surface. Accelerate the process for multiple stars with
the same FWHM but must be used with caution. aper_coeff is of no
use if annulus_surface if given (default None). See
<a class="reference internal" href="#orb.utils.astrometry.multi_aperture_photometry" title="orb.utils.astrometry.multi_aperture_photometry"><code class="xref py py-meth docutils literal"><span class="pre">orb.utils.astrometry.multi_aperture_photometry()</span></code></a>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A Tuple (flux, flux_error, aperture surface,
bad_estimation_flag). If the estimation is bad,
bad_estimation_flat is set to 1, else it is set to 0.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Best aperture for maximum S/N: 1. FWHM (Howell 1989,
Howell 1992). But that works only when the PSF is well sampled
which is not always the case so a higher aperture coefficient
may be better. More over, to get exact photometry the result
must be corrected by aperture growth curve for the &#8216;missing
light&#8217;. A coefficient of 1.27 FWHM corresponds to 3 sigma and
collects more than 99% of the light if the star is a pure
Gaussian. A coefficient of 3 for Moffat stars reduces the
variations of the proportion of collected photons when the FWHM
is changing and seems to be the best.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Best radius for sky background annulus is determined
from this rule of thumb: The number of pixels to estimate the
background must be al least 3 times the number of pixel in the
aperture (Merline &amp; Howell 1995). Choosing the aperture radius
coefficient(Cap) as Rap = Cap * FWHM and the inner radius
coefficient (Cin) as Rin = Cin * FWHM, gives the outer radius
coefficient (Cout): Cout = sqrt(3*Cap^2 + Cin^2)</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The star MUST be at the center (+/- 1 pixel) of the
star box.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#orb.utils.astrometry.multi_aperture_photometry" title="orb.utils.astrometry.multi_aperture_photometry"><code class="xref py py-meth docutils literal"><span class="pre">orb.utils.astrometry.multi_aperture_photometry()</span></code></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.detect_fwhm_in_frame">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">detect_fwhm_in_frame</code><span class="sig-paren">(</span><em>frame</em>, <em>star_list</em>, <em>fwhm_guess_pix</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.detect_fwhm_in_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Detect stars FWHM in a frame.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">star positions must be known precisely</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="orb.utils.astrometry.detect_fwhm_in_frame.params.frame"></span><strong>frame</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.detect_fwhm_in_frame.params.frame">¶</a> &#8211; Frame</li>
<li><span class="target" id="orb.utils.astrometry.detect_fwhm_in_frame.params.star_list"></span><strong>star_list</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.detect_fwhm_in_frame.params.star_list">¶</a> &#8211; List of the positions of the stars used to
detect FWHM.</li>
<li><span class="target" id="orb.utils.astrometry.detect_fwhm_in_frame.params.fwhm_guess_pix"></span><strong>fwhm_guess_pix</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.detect_fwhm_in_frame.params.fwhm_guess_pix">¶</a> &#8211; Initial guess on the FWHM of the stars.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(FWHM, FWHM_ERR) in pixels</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.fit_star">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">fit_star</code><span class="sig-paren">(</span><em>star_box</em>, <em>profile_name='gaussian'</em>, <em>fwhm_pix=None</em>, <em>amp=None</em>, <em>beta=3.5</em>, <em>height=None</em>, <em>pos=None</em>, <em>fix_height=False</em>, <em>fix_amp=False</em>, <em>fix_beta=True</em>, <em>fix_fwhm=False</em>, <em>fix_pos=False</em>, <em>fit_tol=0.001</em>, <em>check=True</em>, <em>fwhm_min=0.5</em>, <em>check_reject=False</em>, <em>ron=10.0</em>, <em>dcl=0.0</em>, <em>estimate_local_noise=True</em>, <em>precise_guess=False</em>, <em>saturation=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.fit_star" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a single star</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.astrometry.fit_star.params.star_box"></span><strong>star_box</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.star_box">¶</a> &#8211; The box where the star has to be fitted.</li>
<li><span class="target" id="orb.utils.astrometry.fit_star.params.profile_name"></span><strong>profile_name</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.profile_name">¶</a> &#8211; (Optional) Name of the PSF profile to use to
fit stars. May be &#8216;gaussian&#8217; or &#8216;moffat&#8217; (default &#8216;gaussian&#8217;).</li>
<li><span class="target" id="orb.utils.astrometry.fit_star.params.amp"></span><strong>amp</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.amp">¶</a> &#8211; (Optional) Amplitude guess, replace the value of the
automatic estimation (default None).</li>
<li><span class="target" id="orb.utils.astrometry.fit_star.params.fwhm_pix"></span><strong>fwhm_pix</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.fwhm_pix">¶</a> &#8211; (Optional) Estimate of the FWHM in pixels. If
None given FWHM is estimated to half the box size (default
None).</li>
<li><span class="target" id="orb.utils.astrometry.fit_star.params.beta"></span><strong>beta</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.beta">¶</a> &#8211; (Optional) Beta parameter of the moffat psf. Used
only if the fitted profile is a Moffat psf (default 3.5).</li>
<li><span class="target" id="orb.utils.astrometry.fit_star.params.height"></span><strong>height</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.height">¶</a> &#8211; (Optional) Height guess, replace the value of the
automatic estimation (default None).</li>
<li><span class="target" id="orb.utils.astrometry.fit_star.params.pos"></span><strong>pos</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.pos">¶</a> &#8211; (Optional) Position guess as a tuple (x,y), replace
the value of the automatic estimation (default None).</li>
<li><span class="target" id="orb.utils.astrometry.fit_star.params.fix_amp"></span><strong>fix_amp</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.fix_amp">¶</a> &#8211; (Optional) Fix amplitude parameter to its
estimation (default False)</li>
<li><span class="target" id="orb.utils.astrometry.fit_star.params.fix_height"></span><strong>fix_height</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.fix_height">¶</a> &#8211; (Optional) Fix height parameter to its
estimation (default False)</li>
<li><span class="target" id="orb.utils.astrometry.fit_star.params.fix_beta"></span><strong>fix_beta</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.fix_beta">¶</a> &#8211; (Optional) Fix beta to the given value (default
True).</li>
<li><span class="target" id="orb.utils.astrometry.fit_star.params.fix_fwhm"></span><strong>fix_fwhm</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.fix_fwhm">¶</a> &#8211; (Optional) Fix FWHM to its estimation (default
False).</li>
<li><span class="target" id="orb.utils.astrometry.fit_star.params.fix_pos"></span><strong>fix_pos</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.fix_pos">¶</a> &#8211; (Optional) Fix position parameters (x,y) at their
estimated value (default False).</li>
<li><span class="target" id="orb.utils.astrometry.fit_star.params.fit_tol"></span><strong>fit_tol</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.fit_tol">¶</a> &#8211; (Optional) Tolerance on the paramaters fit (the
lower the better but the longer too) (default 1e-2).</li>
<li><span class="target" id="orb.utils.astrometry.fit_star.params.check"></span><strong>check</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.check">¶</a> &#8211; (Optional) If True, check fit results for oddities
(default True).</li>
<li><span class="target" id="orb.utils.astrometry.fit_star.params.fwhm_min"></span><strong>fwhm_min</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.fwhm_min">¶</a> &#8211; (Optional) Minimum valid FWHM [in pixel] of the
fitted star (default 0.5)</li>
<li><span class="target" id="orb.utils.astrometry.fit_star.params.check_reject"></span><strong>check_reject</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.check_reject">¶</a> &#8211; (Optional) [Debug] If True, print the reason
why a fit is rejected (default False).</li>
<li><span class="target" id="orb.utils.astrometry.fit_star.params.ron"></span><strong>ron</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.ron">¶</a> &#8211; (Optional) Readout noise in ADU/pixel (default
10.). estimate_local_noise must be set to False for this noise
to be taken into account.</li>
<li><span class="target" id="orb.utils.astrometry.fit_star.params.dcl"></span><strong>dcl</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.dcl">¶</a> &#8211; (Optional) Dark current level in ADU/pixel (default
0.). estimate_local_noise must be set to False for this noise to
be taken into account.</li>
<li><span class="target" id="orb.utils.astrometry.fit_star.params.estimate_local_noise"></span><strong>estimate_local_noise</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.estimate_local_noise">¶</a> &#8211; (Optional) If True, the level of
noise is computed from the background pixels around the
stars. ron and dcl are thus not used (default True).</li>
<li><span class="target" id="orb.utils.astrometry.fit_star.params.precise_guess"></span><strong>precise_guess</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.precise_guess">¶</a> &#8211; (Optional) If True, the fit guess will be
more precise but this can lead to errors if the stars positions
are not already well known (default False).</li>
<li><span class="target" id="orb.utils.astrometry.fit_star.params.saturation"></span><strong>saturation</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_star.params.saturation">¶</a> &#8211; (Optional) If not None, all pixels above the
saturation level are removed from the fit (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.fit_stars_in_frame">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">fit_stars_in_frame</code><span class="sig-paren">(</span><em>frame</em>, <em>star_list</em>, <em>box_size</em>, <em>profile_name='gaussian'</em>, <em>scale=None</em>, <em>fwhm_pix=None</em>, <em>beta=3.5</em>, <em>fit_tol=0.01</em>, <em>fwhm_min=0.5</em>, <em>fix_height=None</em>, <em>fix_aperture_fwhm_pix=None</em>, <em>fix_beta=True</em>, <em>fix_fwhm=False</em>, <em>readout_noise=10.0</em>, <em>dark_current_level=0.0</em>, <em>local_background=True</em>, <em>no_aperture_photometry=False</em>, <em>precise_guess=False</em>, <em>aper_coeff=3.0</em>, <em>blur=False</em>, <em>no_fit=False</em>, <em>estimate_local_noise=True</em>, <em>multi_fit=False</em>, <em>enable_zoom=False</em>, <em>enable_rotation=False</em>, <em>saturation=None</em>, <em>fix_pos=False</em>, <em>nozero=False</em>, <em>silent=True</em>, <em>sip=None</em>, <em>background_value=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.fit_stars_in_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit stars in a frame.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>2 fitting modes are possible:</p>
<ul class="last simple">
<li>Individual fit mode [multi_fit=False]: Stars are all fit
independantly.</li>
<li>Multi fit mode [multi_fit=True]: Stars are fitted all together
considering that the position pattern is well known, the same
shift in x and y will be applied. Optionally the pattern can be
rotated and zoomed. The FWHM is also considered to be the
same. This option is far more robust and precise for alignment
purpose.</li>
</ul>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.frame"></span><strong>frame</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.frame">¶</a> &#8211; The frame containing the stars to fit.</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.star_list"></span><strong>star_list</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.star_list">¶</a> &#8211; A list of star positions as an array of shape
(star_nb, 2)</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.box_size"></span><strong>box_size</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.box_size">¶</a> &#8211; The size of the box created around a star to fit
its parameter.</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.profile_name"></span><strong>profile_name</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.profile_name">¶</a> &#8211; (Optional) Name of the PSF profile to use to
fit stars. May be &#8216;gaussian&#8217; or &#8216;moffat&#8217; (default &#8216;gaussian&#8217;).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.fwhm_pix"></span><strong>fwhm_pix</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.fwhm_pix">¶</a> &#8211; (Optional) Estimate of the FWHM in pixels. If
None given FWHM is estimated to half the box size (default
None).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.scale"></span><strong>scale</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.scale">¶</a> &#8211; (Optional) Scale of the frame in arcsec/pixel. If
given the fwhm in arcseconds is also computed (keyword:
&#8216;fwhm_arc&#8217;) with the fit parameters (default None).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.beta"></span><strong>beta</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.beta">¶</a> &#8211; (Optional) Beta parameter of the moffat psf. Used
only if the fitted profile is a Moffat psf (default 3.5).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.fix_height"></span><strong>fix_height</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.fix_height">¶</a> &#8211; (Optional) Fix height parameter to its
estimation. If None, set by default to True in individual fit
mode [multi_fit=False] and False in multi fit mode
[multi_fit=True] (default None).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.fix_beta"></span><strong>fix_beta</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.fix_beta">¶</a> &#8211; (Optional) Fix beta to the given value (default
True).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.fix_fwhm"></span><strong>fix_fwhm</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.fix_fwhm">¶</a> &#8211; (Optional) Fix FWHM to the given value or the
estimated value (default False).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.fix_pos"></span><strong>fix_pos</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.fix_pos">¶</a> &#8211; (Optional) Fix x,y positions of the stars to the
given value.</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.fit_tol"></span><strong>fit_tol</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.fit_tol">¶</a> &#8211; (Optional) Tolerance on the paramaters fit (the
lower the better but the longer too) (default 1e-2).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.nozero"></span><strong>nozero</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.nozero">¶</a> &#8211; (Optional) If True do not fit any star which box
(the pixels around it) contains a zero. Valid only in individual
fit mode [multi_fit=False] (default False).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.fwhm_min"></span><strong>fwhm_min</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.fwhm_min">¶</a> &#8211; (Optional) Minimum valid FWHM of the fitted star
(default 0.5)</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.silent"></span><strong>silent</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.silent">¶</a> &#8211; (Optional) If True no messages are printed (default
True).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.local_background"></span><strong>local_background</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.local_background">¶</a> &#8211; (Optional) If True, height is estimated
localy, i.e. around the star. If False, the sky background is
determined in the whole frame. In individual fit mode
[multi_fit=False] height will be the same for all the stars, and
the fix_height option is thus automatically set to True. In
multi fit mode [multi_fit=True] height is considered as a
covarying parameter for all the stars but it won&#8217;t be fixed
(default True).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.fix_aperture_fwhm_pix"></span><strong>fix_aperture_fwhm_pix</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.fix_aperture_fwhm_pix">¶</a> &#8211; (Optional) If a positive float. FWHM
used to scale aperture size is not computed from the mean FWHM
in the frame but fixed to the given float (default None).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.no_aperture_photometry"></span><strong>no_aperture_photometry</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.no_aperture_photometry">¶</a> &#8211; (Optional) If True, aperture
photometry will not be done after profile fitting (default
False).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.precise_guess"></span><strong>precise_guess</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.precise_guess">¶</a> &#8211; (Optional) If True, the fit guess will be
more precise but this can lead to errors if the stars positions
are not already well known. Valid only in individual fit mode
[multi_fit=False] (default False).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.readout_noise"></span><strong>readout_noise</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.readout_noise">¶</a> &#8211; (Optional) Readout noise in ADU/pixel (can
be computed from bias frames: std(master_bias_frame)) (default
10.)</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.dark_current_level"></span><strong>dark_current_level</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.dark_current_level">¶</a> &#8211; (Optional) Dark current level in
ADU/pixel (can be computed from dark frames:
median(master_dark_frame)) (default 0.)</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.aper_coeff"></span><strong>aper_coeff</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.aper_coeff">¶</a> &#8211; (Optional) Aperture coefficient. The aperture
radius is Rap = aper_coeff * FWHM. Better when between 1.5 to
reduce the variation of the collected photons with varying FWHM
and 3. to account for the flux in the wings (default 3., better
for star with a high SNR).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.blur"></span><strong>blur</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.blur">¶</a> &#8211; (Optional) If True, blur frame (low pass filtering)
before fitting stars. It can be used to enhance the quality of
the fitted flux of undersampled data. Note that the error on
star position can be greater on blurred frame. This option must
not be used for alignment purpose (default False).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.no_fit"></span><strong>no_fit</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.no_fit">¶</a> &#8211; (Optional) If True, no fit is done. Only the
aperture photometry. Star positions in the star list must thus
be precise (default False).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.multi_fit"></span><strong>multi_fit</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.multi_fit">¶</a> &#8211; (Optional) If True all stars are fitted at the
same time. More robust for alignment purpose. The difference of
position between the stars in the star list must be precisely
known because the overall shift only is estimated (default
False).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.enable_zoom"></span><strong>enable_zoom</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.enable_zoom">¶</a> &#8211; (Optional) If True, the stars position pattern
can be zoomed to better adjust it to the real frame. Valid only
in multi fit mode [multi_fit=True] (default False).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.enable_rotation"></span><strong>enable_rotation</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.enable_rotation">¶</a> &#8211; (Optional) If True, the stars position
pattern can be rotated to better adjust it to the real frame
Valid only in multi fit mode [multi_fit=True] (default False).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.estimate_local_noise"></span><strong>estimate_local_noise</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.estimate_local_noise">¶</a> &#8211; (Optional) If True, the level of
noise is computed from the background pixels around the
stars. readout_noise and dark_current_level are thus not used
(default True).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.saturation"></span><strong>saturation</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.saturation">¶</a> &#8211; (Optional) If not None, all pixels above the
saturation level are removed from the fit (default None).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.sip"></span><strong>sip</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.sip">¶</a> &#8211; (Optional) A pywcs.WCS instance containing SIP
distorsion correction (default None).</li>
<li><span class="target" id="orb.utils.astrometry.fit_stars_in_frame.params.background_value"></span><strong>background_value</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.fit_stars_in_frame.params.background_value">¶</a> &#8211; (Optional) If not None, this background
value is used in the fit functions and will be fixed for fit and
aperture photometry. Note also that in this case
local_background is automatically set to False (default None).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Parameters of a 2D fit of the stars positions.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="astrometry_module.html#astrometry.Astrometry.load_star_list" title="astrometry.Astrometry.load_star_list"><code class="xref py py-meth docutils literal"><span class="pre">astrometry.Astrometry.load_star_list()</span></code></a> to load
a predefined list of stars or
<a class="reference internal" href="astrometry_module.html#astrometry.Astrometry.detect_stars" title="astrometry.Astrometry.detect_stars"><code class="xref py py-meth docutils literal"><span class="pre">astrometry.Astrometry.detect_stars()</span></code></a> to automatically
create it.</p>
</div>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">utils.astrometry.fit_star()</span></code> and
<code class="xref py py-meth docutils literal"><span class="pre">orb.cutils.multi_fit_stars()</span></code></p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.get_profile">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">get_profile</code><span class="sig-paren">(</span><em>profile_name</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.get_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the PSF profile class corresponding to the given profile name.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.astrometry.get_profile.params.name"></span><strong>name</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.get_profile.params.name">¶</a> (<em>profile</em>) &#8211; The name of the PSF profile. Must be &#8216;moffat&#8217;
or &#8216;gaussian&#8217;.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.guess">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">guess</code><span class="sig-paren">(</span><em>star_box</em>, <em>pos=None</em>, <em>height=None</em>, <em>precise_pos=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.guess" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an estimation of the star parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="orb.utils.astrometry.guess.params.star_box"></span><strong>star_box</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.guess.params.star_box">¶</a> &#8211; Sub-part of an image surrounding a star. The
center of the star must be placed near the center of the
box. The dimensions of the box must be greater than 3 times
the FWHM of the star.</li>
<li><span class="target" id="orb.utils.astrometry.guess.params.pos"></span><strong>pos</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.guess.params.pos">¶</a> &#8211; (Optional) Position guess as a tuple (x,y). Used to
estimate amplitude (default None).</li>
<li><span class="target" id="orb.utils.astrometry.guess.params.height"></span><strong>height</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.guess.params.height">¶</a> &#8211; (Optional) Guess of the background level. Used to
estimate amplitude (default None).</li>
<li><span class="target" id="orb.utils.astrometry.guess.params.precise_pos"></span><strong>precise_pos</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.guess.params.precise_pos">¶</a> &#8211; (Optional) If True, position is estimated from
the marginal distribution of the PSF. Return a far better
estimation if and only if the star is well centered in the box,
i.e. if and only if the position of the star is already
known. This can lead to errors when trying to find the star in
the box, in this case precise_pos must be set to False (default
False).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">[height,amplitude,x,y,width]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.load_star_list">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">load_star_list</code><span class="sig-paren">(</span><em>star_list_path</em>, <em>silent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.load_star_list" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a list of stars coordinates</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.astrometry.load_star_list.params.star_list_path"></span><strong>star_list_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.load_star_list.params.star_list_path">¶</a> &#8211; The path to the star list file.</li>
<li><span class="target" id="orb.utils.astrometry.load_star_list.params.silent"></span><strong>silent</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.load_star_list.params.silent">¶</a> &#8211; (Optional) If True no message is printed (default
False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>A list of stars is a list of star coordinates (x and
y). Each set of coordinates is separated by a line
break. There must not be any blank line or comments.</p>
<p>For example:</p>
<div class="last highlight-python"><div class="highlight"><pre>221.994164678 62.8374036151
135.052291354 274.848787038
186.478298303 11.8162949818
362.642981933 323.083868198
193.546595814 321.017948051
</pre></div>
</div>
</div>
<p>The star list can be created using DS9
(<a class="reference external" href="http://hea-www.harvard.edu/RD/ds9/site/Home.html">http://hea-www.harvard.edu/RD/ds9/site/Home.html</a>) on the
first image of the sequence :</p>
<blockquote>
<div><ol class="arabic simple">
<li>Select more than 3 stars with the circular tool (the
more you select, the better will be the alignment)</li>
<li>Save the regions you have created with the options:<ul>
<li>Format = &#8216;XY&#8217;</li>
<li>Coordinate system = &#8216;Image&#8217;</li>
</ul>
</li>
</ol>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.mag">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">mag</code><span class="sig-paren">(</span><em>flux</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.mag" title="Permalink to this definition">¶</a></dt>
<dd><dl class="docutils">
<dt>Return the instrumental magnitude of a given flux (magnitude 0</dt>
<dd>is set to 1 e-)</dd>
</dl>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.astrometry.mag.params.flux"></span><strong>flux</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.mag.params.flux">¶</a> &#8211; Flux in e-</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.multi_aperture_photometry">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">multi_aperture_photometry</code><span class="sig-paren">(</span><em>frame</em>, <em>pos_list</em>, <em>fwhm_guess_pix</em>, <em>aper_coeff=3.0</em>, <em>detect_fwhm=False</em>, <em>silent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.multi_aperture_photometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Aperture photometry of multiple sources in a frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.astrometry.multi_aperture_photometry.params.frame"></span><strong>frame</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.multi_aperture_photometry.params.frame">¶</a> &#8211; Frame</li>
<li><span class="target" id="orb.utils.astrometry.multi_aperture_photometry.params.pos_list"></span><strong>pos_list</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.multi_aperture_photometry.params.pos_list">¶</a> &#8211; List of the positions of the sources</li>
<li><span class="target" id="orb.utils.astrometry.multi_aperture_photometry.params.fwhm_guess_pix"></span><strong>fwhm_guess_pix</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.multi_aperture_photometry.params.fwhm_guess_pix">¶</a> &#8211; Initial guess on the FWHM of the sources.</li>
<li><span class="target" id="orb.utils.astrometry.multi_aperture_photometry.params.aper_coeff"></span><strong>aper_coeff</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.multi_aperture_photometry.params.aper_coeff">¶</a> &#8211; (Optional) Aperture coefficient used for
photometry (default 3.).</li>
<li><span class="target" id="orb.utils.astrometry.multi_aperture_photometry.params.detect_fwhm"></span><strong>detect_fwhm</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.multi_aperture_photometry.params.detect_fwhm">¶</a> &#8211; (Optional) If True FWHM is automatically
computed from a fit on the sources. Sources must be stars or
bright point sources. If most of the sources are stars this
might work well enough (default False).</li>
<li><span class="target" id="orb.utils.astrometry.multi_aperture_photometry.params.silent"></span><strong>silent</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.multi_aperture_photometry.params.silent">¶</a> &#8211; (Optional) Silent function if True (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.radial_profile">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">radial_profile</code><span class="sig-paren">(</span><em>a</em>, <em>xc</em>, <em>yc</em>, <em>rmax</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.radial_profile" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the average radial profile on a region of a 2D array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="orb.utils.astrometry.radial_profile.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.radial_profile.params.a">¶</a> &#8211; A 2D array</li>
<li><span class="target" id="orb.utils.astrometry.radial_profile.params.xc"></span><strong>xc</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.radial_profile.params.xc">¶</a> &#8211; Center of the profile along x axis</li>
<li><span class="target" id="orb.utils.astrometry.radial_profile.params.yc"></span><strong>yc</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.radial_profile.params.yc">¶</a> &#8211; Center of the profile along y axis</li>
<li><span class="target" id="orb.utils.astrometry.radial_profile.params.rmax"></span><strong>rmax</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.radial_profile.params.rmax">¶</a> &#8211; Radius of the profile</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(R axis, V axis). A tuple of 2 vectors giving the radius
axis and the corresponding values axis.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.sip_im2pix">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">sip_im2pix</code><span class="sig-paren">(</span><em>im_coords</em>, <em>sip</em>, <em>tolerance=1e-08</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.sip_im2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform perfect pixel positions to distorded pixels positions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.astrometry.sip_im2pix.params.im_coords"></span><strong>im_coords</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.sip_im2pix.params.im_coords">¶</a> &#8211; perfect pixel positions as an Nx2 array of floats.</li>
<li><span class="target" id="orb.utils.astrometry.sip_im2pix.params.sip"></span><strong>sip</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.sip_im2pix.params.sip">¶</a> &#8211; pywcs.WCS() instance containing SIP parameters.</li>
<li><span class="target" id="orb.utils.astrometry.sip_im2pix.params.tolerance"></span><strong>tolerance</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.sip_im2pix.params.tolerance">¶</a> &#8211; tolerance on the iterative method.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.sip_pix2im">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">sip_pix2im</code><span class="sig-paren">(</span><em>pix_coords</em>, <em>sip</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.sip_pix2im" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform distorded pixel positions to perfect pixels positions</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.astrometry.sip_pix2im.params.pix_coords"></span><strong>pix_coords</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.sip_pix2im.params.pix_coords">¶</a> &#8211; distorded pixel positions as an Nx2 array of floats.</li>
<li><span class="target" id="orb.utils.astrometry.sip_pix2im.params.sip"></span><strong>sip</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.sip_pix2im.params.sip">¶</a> &#8211; pywcs.WCS() instance containing SIP parameters.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.sky_background_level">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">sky_background_level</code><span class="sig-paren">(</span><em>im</em>, <em>smooth_coeff=0.1</em>, <em>return_mode=False</em>, <em>bins=25</em>, <em>return_error=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.sky_background_level" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the level of the sky background based on the maximum of
the histogram of the pixels distribution in the image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.astrometry.sky_background_level.params.im"></span><strong>im</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.sky_background_level.params.im">¶</a> &#8211; Image.</li>
<li><span class="target" id="orb.utils.astrometry.sky_background_level.params.smooth_coeff"></span><strong>smooth_coeff</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.sky_background_level.params.smooth_coeff">¶</a> &#8211; (Optional) the smoothing degree, i.e. the
number of smoothing points is defined by smooth_coeff *
size(histogram) (default 0.05). If smooth_coeff &lt;= 0. no
smoothing is applied.</li>
<li><span class="target" id="orb.utils.astrometry.sky_background_level.params.return_mode"></span><strong>return_mode</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.sky_background_level.params.return_mode">¶</a> &#8211; (Optional) If True the returned value is the
mode (an entire value for a distribution of integers). If False,
return the mean of a sigmacut realized around the mode (a
fractional value, generally more precise).</li>
<li><span class="target" id="orb.utils.astrometry.sky_background_level.params.bins"></span><strong>bins</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.sky_background_level.params.bins">¶</a> &#8211; (Optional) Number of bins for the histogram (default
20).</li>
<li><span class="target" id="orb.utils.astrometry.sky_background_level.params.return_error"></span><strong>return_error</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.sky_background_level.params.return_error">¶</a> &#8211; (Optional) If True, the error on the
estimation is returned (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.astrometry.transform_star_position_A_to_B">
<code class="descclassname">orb.utils.astrometry.</code><code class="descname">transform_star_position_A_to_B</code><span class="sig-paren">(</span><em>star_list_A</em>, <em>params</em>, <em>rc</em>, <em>zoom_factor</em>, <em>sip_A=None</em>, <em>sip_B=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.astrometry.transform_star_position_A_to_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform star positions in camera A to the positions in camera
B given the transformation parameters.</p>
<p>Optionally SIP distorsion parameters can be given.</p>
<p>The transformation steps are:</p>
<div class="highlight-python"><div class="highlight"><pre>dist_pix_camA -&gt; perf_pix_camA -&gt; geometric transformation_A2B
-&gt; perf_pix_camB -&gt; dist_pix_camB
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.astrometry.transform_star_position_A_to_B.params.star_list_A"></span><strong>star_list_A</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.transform_star_position_A_to_B.params.star_list_A">¶</a> &#8211; List of star coordinates in the cube A.</li>
<li><span class="target" id="orb.utils.astrometry.transform_star_position_A_to_B.params.params"></span><strong>params</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.transform_star_position_A_to_B.params.params">¶</a> &#8211; Transformation parameters [dx, dy, dr, da, db].</li>
<li><span class="target" id="orb.utils.astrometry.transform_star_position_A_to_B.params.rc"></span><strong>rc</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.transform_star_position_A_to_B.params.rc">¶</a> &#8211; Rotation center coordinates.</li>
<li><span class="target" id="orb.utils.astrometry.transform_star_position_A_to_B.params.zoom_factor"></span><strong>zoom_factor</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.transform_star_position_A_to_B.params.zoom_factor">¶</a> &#8211; Zooming factor between the two cameras. Can be
a couple (zx, zy).</li>
<li><span class="target" id="orb.utils.astrometry.transform_star_position_A_to_B.params.sip_A"></span><strong>sip_A</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.transform_star_position_A_to_B.params.sip_A">¶</a> &#8211; (Optional) pywcs.WCS instance containing SIP
parameters of the frame A (default None).</li>
<li><span class="target" id="orb.utils.astrometry.transform_star_position_A_to_B.params.sip_B"></span><strong>sip_B</strong><a class="paramlink headerlink reference internal" href="#orb.utils.astrometry.transform_star_position_A_to_B.params.sip_B">¶</a> &#8211; (Optional) pywcs.WCS instance containing SIP
parameters of the frame B (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.debug">
<span id="debug"></span><h2><a class="toc-backref" href="#id6">Debug</a><a class="headerlink" href="#module-orb.utils.debug" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.debug.get_open_fds">
<code class="descclassname">orb.utils.debug.</code><code class="descname">get_open_fds</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.debug.get_open_fds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of open file descriptors</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Only works on UNIX-like OS</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is a useful debugging function that has been taken from: <a class="reference external" href="http://stackoverflow.com/questions/2023608/check-what-files-are-open-in-python">http://stackoverflow.com/questions/2023608/check-what-files-are-open-in-python</a></p>
</div>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.fft">
<span id="fft"></span><h2><a class="toc-backref" href="#id7">FFT</a><a class="headerlink" href="#module-orb.utils.fft" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.fft.amplitude">
<code class="descclassname">orb.utils.fft.</code><code class="descname">amplitude</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.amplitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the amplitude of a complex number</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.apodize">
<code class="descclassname">orb.utils.fft.</code><code class="descname">apodize</code><span class="sig-paren">(</span><em>s</em>, <em>apodization_function='2.0'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.apodize" title="Permalink to this definition">¶</a></dt>
<dd><p>Apodize a spectrum</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.fft.apodize.params.s"></span><strong>s</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.apodize.params.s">¶</a> &#8211; Spectrum</li>
<li><span class="target" id="orb.utils.fft.apodize.params.apodization_function"></span><strong>apodization_function</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.apodize.params.apodization_function">¶</a> &#8211; (Optional) A Norton-Beer apodization
function (default 2.0)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.border_cut_window">
<code class="descclassname">orb.utils.fft.</code><code class="descname">border_cut_window</code><span class="sig-paren">(</span><em>n</em>, <em>coeff=0.2</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.border_cut_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a window function with only the edges cut by a nice
gaussian shape function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.fft.border_cut_window.params.n"></span><strong>n</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.border_cut_window.params.n">¶</a> &#8211; Window length</li>
<li><span class="target" id="orb.utils.fft.border_cut_window.params.coeff"></span><strong>coeff</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.border_cut_window.params.coeff">¶</a> &#8211; Border size in percentage of the total length.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.compute_phase_coeffs_vector">
<code class="descclassname">orb.utils.fft.</code><code class="descname">compute_phase_coeffs_vector</code><span class="sig-paren">(</span><em>phase_maps</em>, <em>res_map=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.compute_phase_coeffs_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a vector containing the mean of the phase
coefficients for each given phase map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.fft.compute_phase_coeffs_vector.params.phase_maps"></span><strong>phase_maps</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.compute_phase_coeffs_vector.params.phase_maps">¶</a> &#8211; Tuple of phase maps. Coefficients are
sorted in the same order as the phase maps.</li>
<li><span class="target" id="orb.utils.fft.compute_phase_coeffs_vector.params.res_map"></span><strong>res_map</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.compute_phase_coeffs_vector.params.res_map">¶</a> &#8211; (Optional) If given this map is used to
get only the well fitted coefficients in order to compute a
more precise mean coefficent.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.count_nonzeros">
<code class="descclassname">orb.utils.fft.</code><code class="descname">count_nonzeros</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.count_nonzeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of nonzeros parts in a vector as a vector of
the same length with the length of each part at each occurence of
a nonzero number.</p>
<p>e.g. : if a = [0,0,0,1,1,0,1] this function returns: [0,0,0,2,2,0,1]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.fft.count_nonzeros.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.count_nonzeros.params.a">¶</a> &#8211; A vector.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.create_phase_file">
<code class="descclassname">orb.utils.fft.</code><code class="descname">create_phase_file</code><span class="sig-paren">(</span><em>file_path</em>, <em>phase_vector</em>, <em>cm1_axis</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.create_phase_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Write a phase vector in a phase file.</p>
<p>Phase vector is interpolated via a cubic spline.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.fft.create_phase_file.params.file_path"></span><strong>file_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.create_phase_file.params.file_path">¶</a> &#8211; Path to the output phase file.</li>
<li><span class="target" id="orb.utils.fft.create_phase_file.params.phase_vector"></span><strong>phase_vector</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.create_phase_file.params.phase_vector">¶</a> &#8211; Phase vector</li>
<li><span class="target" id="orb.utils.fft.create_phase_file.params.cm1_axis"></span><strong>cm1_axis</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.create_phase_file.params.cm1_axis">¶</a> &#8211; Phase vector axis in cm-1</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.cube_raw_fft">
<code class="descclassname">orb.utils.fft.</code><code class="descname">cube_raw_fft</code><span class="sig-paren">(</span><em>x</em>, <em>apod=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.cube_raw_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the raw FFT of a cube (the last axis
beeing the interferogram axis)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.fft.cube_raw_fft.params.x"></span><strong>x</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.cube_raw_fft.params.x">¶</a> &#8211; Interferogram cube</li>
<li><span class="target" id="orb.utils.fft.cube_raw_fft.params.apod"></span><strong>apod</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.cube_raw_fft.params.apod">¶</a> &#8211; (Optional) Apodization function used. See
<code class="xref py py-meth docutils literal"><span class="pre">utils.norton_beer_window()</span></code> (default None)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.find_zpd">
<code class="descclassname">orb.utils.fft.</code><code class="descname">find_zpd</code><span class="sig-paren">(</span><em>interf</em>, <em>step_number=None</em>, <em>return_zpd_shift=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.find_zpd" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the ZPD along the z axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.fft.find_zpd.params.step_number"></span><strong>step_number</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.find_zpd.params.step_number">¶</a> &#8211; (Optional) If the full number of steps is
greater than the number of frames of the cube. Useful when
the interferograms are non symetric (default None).</li>
<li><span class="target" id="orb.utils.fft.find_zpd.params.return_zpd_shift"></span><strong>return_zpd_shift</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.find_zpd.params.return_zpd_shift">¶</a> &#8211; (Optional) If True return ZPD shift
instead of ZPD index (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.imag">
<code class="descclassname">orb.utils.fft.</code><code class="descname">imag</code><span class="sig-paren">(</span><em>amp</em>, <em>pha</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the imaginary part from amplitude and phase</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.indft">
<code class="descclassname">orb.utils.fft.</code><code class="descname">indft</code><span class="sig-paren">(</span><em>a</em>, <em>x</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.indft" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse Non-uniform Discret Fourier Transform.</p>
<p>Compute the irregularly sampled interferogram from a regularly
sampled spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.fft.indft.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.indft.params.a">¶</a> &#8211; regularly sampled spectrum.</li>
<li><span class="target" id="orb.utils.fft.indft.params.x"></span><strong>x</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.indft.params.x">¶</a> &#8211; positions of the interferogram samples. If x =
range(size(a)), this function is equivalent to an idft or a
ifft. Note that the ifft is of course much faster to
compute. This vector may have any length.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.interf_mean_energy">
<code class="descclassname">orb.utils.fft.</code><code class="descname">interf_mean_energy</code><span class="sig-paren">(</span><em>interf</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.interf_mean_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean energy of an interferogram by step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.fft.interf_mean_energy.params.interf"></span><strong>interf</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.interf_mean_energy.params.interf">¶</a> &#8211; an interferogram</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The mean of the interferogram is substracted to
compute only the modulation energy. This is the modulation
energy which must be conserved in the resulting spectrum. Note
that the interferogram transformation function (see
<code class="xref py py-meth docutils literal"><span class="pre">utils.transform_interferogram()</span></code>) remove the mean of the
interferogram before computing its FFT.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">NaNs are set to 0.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.learner95_window">
<code class="descclassname">orb.utils.fft.</code><code class="descname">learner95_window</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.learner95_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the apodization function described in Learner et al.,
J. Opt. Soc. Am. A, 12, (1995).</p>
<p>This function is closely related to the minimum four-term
Blackman-Harris window.</p>
<p>Returned window is symmetrical.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.fft.learner95_window.params.n"></span><strong>n</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.learner95_window.params.n">¶</a> &#8211; Number of points.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.next_power_of_two">
<code class="descclassname">orb.utils.fft.</code><code class="descname">next_power_of_two</code><span class="sig-paren">(</span><em>n</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.next_power_of_two" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the next power of two greater than n.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.fft.next_power_of_two.params.n"></span><strong>n</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.next_power_of_two.params.n">¶</a> &#8211; The number from which the next power of two has to be
computed. Can be an array of numbers.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.norton_beer_window">
<code class="descclassname">orb.utils.fft.</code><code class="descname">norton_beer_window</code><span class="sig-paren">(</span><em>fwhm='1.6'</em>, <em>n=1000</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.norton_beer_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an extended Norton-Beer window function (see <a class="reference internal" href="#nay2007" id="id2">[NAY2007]</a>).</p>
<p>Returned window is symmetrical.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.fft.norton_beer_window.params.fwhm"></span><strong>fwhm</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.norton_beer_window.params.fwhm">¶</a> &#8211; FWHM relative to the sinc function. Must be: 1.1,
1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9 or 2.0. (default &#8216;1.6&#8217;)</li>
<li><span class="target" id="orb.utils.fft.norton_beer_window.params.n"></span><strong>n</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.norton_beer_window.params.n">¶</a> &#8211; Number of points (default 1000)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Coefficients of the extended Norton-Beer functions
apodizing functions <a class="reference internal" href="#nay2007" id="id3">[NAY2007]</a> :</p>
<table border="1" class="last docutils">
<colgroup>
<col width="8%" />
<col width="15%" />
<col width="17%" />
<col width="15%" />
<col width="15%" />
<col width="15%" />
<col width="15%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>FWHM</td>
<td>C0</td>
<td>C1</td>
<td>C2</td>
<td>C4</td>
<td>C6</td>
<td>C8</td>
</tr>
<tr class="row-even"><td>1.1</td>
<td>0.701551</td>
<td>-0.639244</td>
<td>0.937693</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>1.2</td>
<td>0.396430</td>
<td>-0.150902</td>
<td>0.754472</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-even"><td>1.3</td>
<td>0.237413</td>
<td>-0.065285</td>
<td>0.827872</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>1.4</td>
<td>0.153945</td>
<td>-0.141765</td>
<td>0.987820</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-even"><td>1.5</td>
<td>0.077112</td>
<td>0.000000</td>
<td>0.703371</td>
<td>0.219517</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>1.6</td>
<td>0.039234</td>
<td>0.000000</td>
<td>0.630268</td>
<td>0.234934</td>
<td>0.095563</td>
<td>0.000000</td>
</tr>
<tr class="row-even"><td>1.7</td>
<td>0.020078</td>
<td>0.000000</td>
<td>0.480667</td>
<td>0.386409</td>
<td>0.112845</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>1.8</td>
<td>0.010172</td>
<td>0.000000</td>
<td>0.344429</td>
<td>0.451817</td>
<td>0.193580</td>
<td>0.000000</td>
</tr>
<tr class="row-even"><td>1.9</td>
<td>0.004773</td>
<td>0.000000</td>
<td>0.232473</td>
<td>0.464562</td>
<td>0.298191</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>2.0</td>
<td>0.002267</td>
<td>0.000000</td>
<td>0.140412</td>
<td>0.487172</td>
<td>0.256200</td>
<td>0.113948</td>
</tr>
</tbody>
</table>
</div>
<table class="docutils citation" frame="void" id="nay2007" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[NAY2007]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id3">2</a>)</em> Naylor, D. A., &amp; Tahic, M. K. (2007). Apodizing
functions for Fourier transform spectroscopy. Journal of the
Optical Society of America A.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.optimize_phase">
<code class="descclassname">orb.utils.fft.</code><code class="descname">optimize_phase</code><span class="sig-paren">(</span><em>interf, step, order, zpd_shift, calib, nm_laser, guess=[0.0001, 0.0001], return_coeffs=False, fixed_params=[0, 0], weights=None, high_order_phase=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.optimize_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an optimized phase vector based on the minimization of
the imaginary part.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.fft.optimize_phase.params.interf"></span><strong>interf</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.optimize_phase.params.interf">¶</a> &#8211; Interferogram</li>
<li><span class="target" id="orb.utils.fft.optimize_phase.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.optimize_phase.params.step">¶</a> &#8211; Step size (in nm)</li>
<li><span class="target" id="orb.utils.fft.optimize_phase.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.optimize_phase.params.order">¶</a> &#8211; Alisasing order</li>
<li><span class="target" id="orb.utils.fft.optimize_phase.params.zpd_shift"></span><strong>zpd_shift</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.optimize_phase.params.zpd_shift">¶</a> &#8211; ZPD shift</li>
<li><span class="target" id="orb.utils.fft.optimize_phase.params.calib"></span><strong>calib</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.optimize_phase.params.calib">¶</a> &#8211; Calibration laser observed wavelength</li>
<li><span class="target" id="orb.utils.fft.optimize_phase.params.nm_laser"></span><strong>nm_laser</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.optimize_phase.params.nm_laser">¶</a> &#8211; Calibration laser real wavelength</li>
<li><span class="target" id="orb.utils.fft.optimize_phase.params.guess"></span><strong>guess</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.optimize_phase.params.guess">¶</a> &#8211; (Optional) First guess. The number of values defines the order
of the polynomial used used to fit (default [0,0]).</li>
<li><span class="target" id="orb.utils.fft.optimize_phase.params.return_coeffs"></span><strong>return_coeffs</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.optimize_phase.params.return_coeffs">¶</a> &#8211; (Optional) If True, coeffs and residual are
returned instead of the phase vector (default False).</li>
<li><span class="target" id="orb.utils.fft.optimize_phase.params.fixed_params"></span><strong>fixed_params</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.optimize_phase.params.fixed_params">¶</a> &#8211; (Optional) Define free and fixed parameters
(1 for fixed, 0 for free, default [0,0])</li>
<li><span class="target" id="orb.utils.fft.optimize_phase.params.weights"></span><strong>weights</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.optimize_phase.params.weights">¶</a> &#8211; (Optional) spectrum weighting (a vector with
values ranging from 0 to 1, 1 being the maximu weight)</li>
<li><span class="target" id="orb.utils.fft.optimize_phase.params.high_order_phase"></span><strong>high_order_phase</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.optimize_phase.params.high_order_phase">¶</a> &#8211; (Optional) High order phase to be
subtracted during the optimization process. Can be a path to a
phase file . Note that if it is not a phase file name it must be
a scipy.interpolate.UnivariateSpline instance to accelerate the
process (as returned by
<a class="reference internal" href="#orb.utils.fft.read_phase_file" title="orb.utils.fft.read_phase_file"><code class="xref py py-meth docutils literal"><span class="pre">orb.utils.fft.read_phase_file()</span></code></a>).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.phase">
<code class="descclassname">orb.utils.fft.</code><code class="descname">phase</code><span class="sig-paren">(</span><em>a</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the phase of a complex number</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.raw_fft">
<code class="descclassname">orb.utils.fft.</code><code class="descname">raw_fft</code><span class="sig-paren">(</span><em>x</em>, <em>apod=None</em>, <em>inverse=False</em>, <em>return_complex=False</em>, <em>return_phase=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.raw_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the raw FFT of a vector.</p>
<p>Return the absolute value of the complex vector by default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.fft.raw_fft.params.x"></span><strong>x</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.raw_fft.params.x">¶</a> &#8211; Interferogram.</li>
<li><span class="target" id="orb.utils.fft.raw_fft.params.apod"></span><strong>apod</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.raw_fft.params.apod">¶</a> &#8211; (Optional) Apodization function used. See
<code class="xref py py-meth docutils literal"><span class="pre">utils.norton_beer_window()</span></code> (default None)</li>
<li><span class="target" id="orb.utils.fft.raw_fft.params.inverse"></span><strong>inverse</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.raw_fft.params.inverse">¶</a> &#8211; (Optional) If True compute the inverse FFT
(default False).</li>
<li><span class="target" id="orb.utils.fft.raw_fft.params.return_complex"></span><strong>return_complex</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.raw_fft.params.return_complex">¶</a> &#8211; (Optional) If True, the complex vector is
returned (default False).</li>
<li><span class="target" id="orb.utils.fft.raw_fft.params.return_phase"></span><strong>return_phase</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.raw_fft.params.return_phase">¶</a> &#8211; (Optional) If True, the phase is
returned.(default False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.read_phase_file">
<code class="descclassname">orb.utils.fft.</code><code class="descname">read_phase_file</code><span class="sig-paren">(</span><em>file_path</em>, <em>return_spline=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.read_phase_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a phase file and return its content.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="orb.utils.fft.read_phase_file.params.file_path"></span><strong>file_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.read_phase_file.params.file_path">¶</a> &#8211; Path to the phase file</li>
<li><span class="target" id="orb.utils.fft.read_phase_file.params.return_spline"></span><strong>return_spline</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.read_phase_file.params.return_spline">¶</a> &#8211; If True a cubic spline
(scipy.interpolate.UnivariateSpline instance) is returned
instead of a tuple.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a tuple (Phase axis [cm-1], Phase [radians]) or a
scipy.interpolate.UnivariateSpline instance if return_spline is
True.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.real">
<code class="descclassname">orb.utils.fft.</code><code class="descname">real</code><span class="sig-paren">(</span><em>amp</em>, <em>pha</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.real" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real part from amplitude and phase</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.spectrum_mean_energy">
<code class="descclassname">orb.utils.fft.</code><code class="descname">spectrum_mean_energy</code><span class="sig-paren">(</span><em>spectrum</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.spectrum_mean_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean energy of a spectrum by channel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.fft.spectrum_mean_energy.params.spectrum"></span><strong>spectrum</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.spectrum_mean_energy.params.spectrum">¶</a> &#8211; a 1D spectrum</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.transform_interferogram">
<code class="descclassname">orb.utils.fft.</code><code class="descname">transform_interferogram</code><span class="sig-paren">(</span><em>interf</em>, <em>nm_laser</em>, <em>calibration_coeff</em>, <em>step</em>, <em>order</em>, <em>window_type</em>, <em>zpd_shift</em>, <em>phase_correction=True</em>, <em>wave_calibration=True</em>, <em>return_phase=False</em>, <em>ext_phase=None</em>, <em>balanced=True</em>, <em>bad_frames_vector=None</em>, <em>smoothing_deg=2</em>, <em>return_complex=False</em>, <em>final_step_nb=None</em>, <em>wavenumber=False</em>, <em>low_order_correction=False</em>, <em>high_order_phase=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.transform_interferogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform an interferogram into a spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.fft.transform_interferogram.params.interf"></span><strong>interf</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_interferogram.params.interf">¶</a> &#8211; Interferogram to transform.</li>
<li><span class="target" id="orb.utils.fft.transform_interferogram.params.nm_laser"></span><strong>nm_laser</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_interferogram.params.nm_laser">¶</a> &#8211; Wavelength of the laser used for calibration.</li>
<li><span class="target" id="orb.utils.fft.transform_interferogram.params.calibration_coeff"></span><strong>calibration_coeff</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_interferogram.params.calibration_coeff">¶</a> &#8211; Wavelength of the laser emission line
corresponding to the computed interferogram.</li>
<li><span class="target" id="orb.utils.fft.transform_interferogram.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_interferogram.params.step">¶</a> &#8211; Step size of the moving mirror in nm.</li>
<li><span class="target" id="orb.utils.fft.transform_interferogram.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_interferogram.params.order">¶</a> &#8211; Folding order (if 0 the result cannot be projected
on an axis in nm, i.e. wavenumber option is automatically set to
True).</li>
<li><span class="target" id="orb.utils.fft.transform_interferogram.params.window_type"></span><strong>window_type</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_interferogram.params.window_type">¶</a> &#8211; Name of the apodization function.</li>
<li><span class="target" id="orb.utils.fft.transform_interferogram.params.zpd_shift"></span><strong>zpd_shift</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_interferogram.params.zpd_shift">¶</a> &#8211; Shift of the interferogram to center the ZPD.</li>
<li><span class="target" id="orb.utils.fft.transform_interferogram.params.bad_frames_vector"></span><strong>bad_frames_vector</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_interferogram.params.bad_frames_vector">¶</a> &#8211; (Optional) Mask-like vector containing
ones for bad frames. Bad frames are replaced by zeros using a
special function that smoothes transition between good parts and
zeros (default None). This vector must be uncorrected for ZPD
shift</li>
<li><span class="target" id="orb.utils.fft.transform_interferogram.params.phase_correction"></span><strong>phase_correction</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_interferogram.params.phase_correction">¶</a> &#8211; (Optional) If False, no phase correction
will be done and the resulting spectrum will be the absolute
value of the complex spectrum. Else the ext_phase vector will be
used for phase correction. If ext_phase is set to None,
ext_phase will be replaced by a vector of 0 (default True).</li>
<li><span class="target" id="orb.utils.fft.transform_interferogram.params.wave_calibration"></span><strong>wave_calibration</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_interferogram.params.wave_calibration">¶</a> &#8211; (Optional) If True wavenumber/wavelength
calibration is done (default True).</li>
<li><span class="target" id="orb.utils.fft.transform_interferogram.params.ext_phase"></span><strong>ext_phase</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_interferogram.params.ext_phase">¶</a> &#8211; (Optional) External phase vector. If given this
phase vector is used instead of a low-resolution one. It must be
as long as the interferogram.</li>
<li><span class="target" id="orb.utils.fft.transform_interferogram.params.return_phase"></span><strong>return_phase</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_interferogram.params.return_phase">¶</a> &#8211; (Optional) If True, compute only the phase of
the interferogram and return it. If polyfit_deg is &gt;= 0, return
the coefficients of the fitted phase (default False). Note that
this option is not compatible with ext_phase. You must set
ext_phase to None to set return_phase to True.</li>
<li><span class="target" id="orb.utils.fft.transform_interferogram.params.smoothing_deg"></span><strong>smoothing_deg</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_interferogram.params.smoothing_deg">¶</a> &#8211; (Optional) Degree of zeros smoothing. A
higher degree means a smoother transition from zeros parts (bad
frames) to non-zero parts (good frames) of the
interferogram. Good parts on the other side of the ZPD in
symmetry with zeros parts are multiplied by 2. The same
transition is used to multiply interferogram points by zero and
2 (default 2). This operation is not done if smoothing_deg is
set to 0.</li>
<li><span class="target" id="orb.utils.fft.transform_interferogram.params.balanced"></span><strong>balanced</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_interferogram.params.balanced">¶</a> &#8211; (Optional) If False, the interferogram is
considered as unbalanced. It is flipped before its
transformation to get a positive spectrum. Note
that a merged interferogram is balanced (default True).</li>
<li><span class="target" id="orb.utils.fft.transform_interferogram.params.return_complex"></span><strong>return_complex</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_interferogram.params.return_complex">¶</a> &#8211; (Optional) If True and if phase is
corrected the returned spectrum will be complex. In False only
the real part is returned (default False)</li>
<li><span class="target" id="orb.utils.fft.transform_interferogram.params.final_step_nb"></span><strong>final_step_nb</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_interferogram.params.final_step_nb">¶</a> &#8211; (Optional) Number of samples of the
resulting spectrum. If None, the number of samples of the
spectrum will be the same as the interferogram (default None).</li>
<li><span class="target" id="orb.utils.fft.transform_interferogram.params.wavenumber"></span><strong>wavenumber</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_interferogram.params.wavenumber">¶</a> &#8211; (Optional) If True, the returned spectrum is
projected onto its original wavenumber axis (emission lines and
especially unapodized sinc emission lines are thus symetric
which is not the case if the spectrum is projected onto a, more
convenient, regular wavelength axis) (default False).</li>
<li><span class="target" id="orb.utils.fft.transform_interferogram.params.low_order_correction"></span><strong>low_order_correction</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_interferogram.params.low_order_correction">¶</a> &#8211; (Optional) If True substract a low
order polynomial to remove low frequency noise. Useful for
unperfectly corrected interferograms (default False).</li>
<li><span class="target" id="orb.utils.fft.transform_interferogram.params.high_order_phase"></span><strong>high_order_phase</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_interferogram.params.high_order_phase">¶</a> &#8211; (Optional) High order phase to be added
to the phase computed via a low order polynomial (generally 1
order). Note that it must be a
scipy.interpolate.UnivariateSpline instance to accelerate the
process.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Interferogram can be complex</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Only NANs or INFs are interpreted as bad values</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.transform_spectrum">
<code class="descclassname">orb.utils.fft.</code><code class="descname">transform_spectrum</code><span class="sig-paren">(</span><em>spectrum</em>, <em>nm_laser</em>, <em>calibration_coeff</em>, <em>step</em>, <em>order</em>, <em>window_type</em>, <em>zpd_shift</em>, <em>ext_phase=None</em>, <em>return_complex=False</em>, <em>wavenumber=False</em>, <em>final_step_nb=None</em>, <em>sampling_vector=None</em>, <em>zero_padding=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.transform_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform a spectrum into an interferogram.</p>
<p>This function is the inverse of <code class="xref py py-meth docutils literal"><span class="pre">utils.transform_interferogram()</span></code>.</p>
<p>So that to get the initial interferogram, the same options used in
transform interferogram must be passed to this function. The
spectrum must also be the complex form (use return_complex option
in <code class="xref py py-meth docutils literal"><span class="pre">utils.transform_interferogram()</span></code>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="orb.utils.fft.transform_spectrum.params.spectrum"></span><strong>spectrum</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_spectrum.params.spectrum">¶</a> &#8211; Spectrum to transform</li>
<li><span class="target" id="orb.utils.fft.transform_spectrum.params.nm_laser"></span><strong>nm_laser</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_spectrum.params.nm_laser">¶</a> &#8211; Wavelength of the laser used for calibration.</li>
<li><span class="target" id="orb.utils.fft.transform_spectrum.params.calibration_coeff"></span><strong>calibration_coeff</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_spectrum.params.calibration_coeff">¶</a> &#8211; Wavelength of the laser emission line
corresponding to the computed interferogram.</li>
<li><span class="target" id="orb.utils.fft.transform_spectrum.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_spectrum.params.step">¶</a> &#8211; Step size of the moving mirror in nm.</li>
<li><span class="target" id="orb.utils.fft.transform_spectrum.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_spectrum.params.order">¶</a> &#8211; Folding order (can be 0 but the input must be in
wavenumber).</li>
<li><span class="target" id="orb.utils.fft.transform_spectrum.params.window_type"></span><strong>window_type</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_spectrum.params.window_type">¶</a> &#8211; Name of the apodization function.</li>
<li><span class="target" id="orb.utils.fft.transform_spectrum.params.zpd_shift"></span><strong>zpd_shift</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_spectrum.params.zpd_shift">¶</a> &#8211; Shift of the interferogram to decenter the ZPD.</li>
<li><span class="target" id="orb.utils.fft.transform_spectrum.params.ext_phase"></span><strong>ext_phase</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_spectrum.params.ext_phase">¶</a> &#8211; (Optional) External phase vector. If given this
phase vector is used in place of the original phase of the
spectrum. Useful to add a phase to an interferogram. Note that
this phase is intended to be used to inverse transform an
already transformed interferogram. The computed phase correction
can thus be used directly. As the phase vector given by
<code class="xref py py-meth docutils literal"><span class="pre">utils.transform_interferogram()</span></code> is not reversed for
even orders, it is reversed here in this function.</li>
<li><span class="target" id="orb.utils.fft.transform_spectrum.params.return_complex"></span><strong>return_complex</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_spectrum.params.return_complex">¶</a> &#8211; (Optional) If True return a complex
interferogram. Else return the real part of it (default False).</li>
<li><span class="target" id="orb.utils.fft.transform_spectrum.params.wavenumber"></span><strong>wavenumber</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_spectrum.params.wavenumber">¶</a> &#8211; (Optional) If True the spectrum axis is in
cm-1. In this case, and if no wavelength correction has to be
applied (calibration_coeff == nm_laser) there will be no
interpolation of the original spectrum (better precision)
(default False).</li>
<li><span class="target" id="orb.utils.fft.transform_spectrum.params.final_step_nb"></span><strong>final_step_nb</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.transform_spectrum.params.final_step_nb">¶</a> &#8211; (Optional) Final size of the
interferogram. Must be less than the size of the original
spectrum. If None the final size of the interferogram is the
same as the size of the original spectrum (default None).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Sampling_vector:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first">(Optional) If the samples of the interferogram
are not uniformly distributed, a vector giving the positions of
the samples can be passed. In this case an inverse NDFT is
computed which may be really slow for long vectors. A uniformly
sampled vector would be range(final_step_nb). The size of the
vector must be equal to final_step_nb (default None).</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Zero_padding:</th><td class="field-body"><p class="first last">(Optional) If True and if final_step_nb is &gt;
spectrum step number, ouput is zero padded. Can be used to
compare a high resolution interferogram to a low resolution
interferogram.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Interferogram can be complex</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.fft.variable_me">
<code class="descclassname">orb.utils.fft.</code><code class="descname">variable_me</code><span class="sig-paren">(</span><em>n</em>, <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.fft.variable_me" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sinusoidal function representing a variable
modulation efficiency.</p>
<p>This function is used to correct for fringes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.fft.variable_me.params.params"></span><strong>params</strong><a class="paramlink headerlink reference internal" href="#orb.utils.fft.variable_me.params.params">¶</a> &#8211; A tuple of floats [frequency, amplitude,
phase]. The frequency gives the number of repetition of a sinus
over the vector. The amplitude must be between 0. (returns a
vector of 1) and 1. (returns a sinus going from 0 to 1). Phase
can be a single float or a vector of size n</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.filters">
<span id="filters"></span><h2><a class="toc-backref" href="#id8">Filters</a><a class="headerlink" href="#module-orb.utils.filters" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.filters.compute_weights">
<code class="descclassname">orb.utils.filters.</code><code class="descname">compute_weights</code><span class="sig-paren">(</span><em>calib</em>, <em>nm_laser</em>, <em>step_nb</em>, <em>step</em>, <em>order</em>, <em>range_border_coeff</em>, <em>filter_min_cm1</em>, <em>filter_max_cm1</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.filters.compute_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute weights for a fit based on a spectrum with a given
filter bandpass</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.filters.compute_weights.params.calib"></span><strong>calib</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.compute_weights.params.calib">¶</a> &#8211; Calibration laser observed wavelength</li>
<li><span class="target" id="orb.utils.filters.compute_weights.params.nm_laser"></span><strong>nm_laser</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.compute_weights.params.nm_laser">¶</a> &#8211; Calibration laser theoretical wavelength</li>
<li><span class="target" id="orb.utils.filters.compute_weights.params.step_nb"></span><strong>step_nb</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.compute_weights.params.step_nb">¶</a> &#8211; Vector length</li>
<li><span class="target" id="orb.utils.filters.compute_weights.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.compute_weights.params.step">¶</a> &#8211; Step size (in nm)</li>
<li><span class="target" id="orb.utils.filters.compute_weights.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.compute_weights.params.order">¶</a> &#8211; Folding order</li>
<li><span class="target" id="orb.utils.filters.compute_weights.params.range_border_coeff"></span><strong>range_border_coeff</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.compute_weights.params.range_border_coeff">¶</a> &#8211; Percentage of the vector size
considered as bad borders near the filter edges (must be between
0.2 and 0.).</li>
<li><span class="target" id="orb.utils.filters.compute_weights.params.filter_min_cm1"></span><strong>filter_min_cm1</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.compute_weights.params.filter_min_cm1">¶</a> &#8211; Minimum wavenumber of the filter in cm-1</li>
<li><span class="target" id="orb.utils.filters.compute_weights.params.filter_max_cm1"></span><strong>filter_max_cm1</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.compute_weights.params.filter_max_cm1">¶</a> &#8211; Maximum wavenumber of the filter in cm-1</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.filters.get_filter_bandpass">
<code class="descclassname">orb.utils.filters.</code><code class="descname">get_filter_bandpass</code><span class="sig-paren">(</span><em>filter_file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.filters.get_filter_bandpass" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the filter bandpass in nm as a tuple (nm_min, nm_max)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.filters.get_filter_bandpass.params.get_filter_bandpass"></span><strong>get_filter_bandpass</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.get_filter_bandpass.params.get_filter_bandpass">¶</a> &#8211; Path to the filter file.</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">utils.read_filter_file()</span></code></p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.filters.get_filter_edges_pix">
<code class="descclassname">orb.utils.filters.</code><code class="descname">get_filter_edges_pix</code><span class="sig-paren">(</span><em>filter_file_path</em>, <em>correction_factor</em>, <em>step</em>, <em>order</em>, <em>n</em>, <em>filter_min=None</em>, <em>filter_max=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.filters.get_filter_edges_pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the position in pixels of the edges of a filter
corrected for the off-axis effect.</p>
<p>Note that the axis is assumed to be in wavenumber.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.filters.get_filter_edges_pix.params.filter_file_path"></span><strong>filter_file_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.get_filter_edges_pix.params.filter_file_path">¶</a> &#8211; Path to the filter file. If None,
filter_min and filter_max must be specified.</li>
<li><span class="target" id="orb.utils.filters.get_filter_edges_pix.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.get_filter_edges_pix.params.step">¶</a> &#8211; Step size of the moving mirror in nm.</li>
<li><span class="target" id="orb.utils.filters.get_filter_edges_pix.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.get_filter_edges_pix.params.order">¶</a> &#8211; Folding order.</li>
<li><span class="target" id="orb.utils.filters.get_filter_edges_pix.params.correction_factor"></span><strong>correction_factor</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.get_filter_edges_pix.params.correction_factor">¶</a> &#8211; Correction factor
(i.e. calibration_map_value / laser_wavelength)</li>
<li><span class="target" id="orb.utils.filters.get_filter_edges_pix.params.n"></span><strong>n</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.get_filter_edges_pix.params.n">¶</a> &#8211; Number of points of the interpolation axis.</li>
<li><span class="target" id="orb.utils.filters.get_filter_edges_pix.params.filter_min"></span><strong>filter_min</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.get_filter_edges_pix.params.filter_min">¶</a> &#8211; (Optional) Edge min of the filter in nm
(default None).</li>
<li><span class="target" id="orb.utils.filters.get_filter_edges_pix.params.filter_max"></span><strong>filter_max</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.get_filter_edges_pix.params.filter_max">¶</a> &#8211; (Optional) Edge max of the filter in nm
(default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">utils.read_filter_file()</span></code></p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.filters.get_filter_function">
<code class="descclassname">orb.utils.filters.</code><code class="descname">get_filter_function</code><span class="sig-paren">(</span><em>filter_file_path</em>, <em>step</em>, <em>order</em>, <em>n</em>, <em>wavenumber=False</em>, <em>silent=False</em>, <em>corr=1</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.filters.get_filter_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a filter file and return its function interpolated over
the desired number of points. Return also the edges position over
its axis in pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="orb.utils.filters.get_filter_function.params.filter_file_path"></span><strong>filter_file_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.get_filter_function.params.filter_file_path">¶</a> &#8211; Path to the filter file.</li>
<li><span class="target" id="orb.utils.filters.get_filter_function.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.get_filter_function.params.step">¶</a> &#8211; Step size of the moving mirror in nm.</li>
<li><span class="target" id="orb.utils.filters.get_filter_function.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.get_filter_function.params.order">¶</a> &#8211; Folding order.</li>
<li><span class="target" id="orb.utils.filters.get_filter_function.params.n"></span><strong>n</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.get_filter_function.params.n">¶</a> &#8211; Number of points of the interpolation axis.</li>
<li><span class="target" id="orb.utils.filters.get_filter_function.params.wavenumber"></span><strong>wavenumber</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.get_filter_function.params.wavenumber">¶</a> &#8211; (Optional) If True the function is interpolated
and returned along a wavenumber axis. If False it is returned
along a wavelength axis (default False).</li>
<li><span class="target" id="orb.utils.filters.get_filter_function.params.silent"></span><strong>silent</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.get_filter_function.params.silent">¶</a> &#8211; (Optional) If True, no message is displayed
(default False).</li>
<li><span class="target" id="orb.utils.filters.get_filter_function.params.corr"></span><strong>corr</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.get_filter_function.params.corr">¶</a> &#8211; (Optional) Correction coefficient related to the
incident angle (default 1).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(interpolated filter function, min edge, max edge). Min
and max edges are given in pixels over the interpolation axis.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">utils.read_filter_file()</span></code></p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.filters.get_modulation_efficiency">
<code class="descclassname">orb.utils.filters.</code><code class="descname">get_modulation_efficiency</code><span class="sig-paren">(</span><em>filter_file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.filters.get_modulation_efficiency" title="Permalink to this definition">¶</a></dt>
<dd><p>Return modulation efficiency if it exists and 1. instead</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.filters.get_modulation_efficiency.params.filter_file_path"></span><strong>filter_file_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.get_modulation_efficiency.params.filter_file_path">¶</a> &#8211; Path to the filter file.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.filters.get_phase_fit_order">
<code class="descclassname">orb.utils.filters.</code><code class="descname">get_phase_fit_order</code><span class="sig-paren">(</span><em>filter_file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.filters.get_phase_fit_order" title="Permalink to this definition">¶</a></dt>
<dd><p>Return phase fit order if it exists and None instead.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.filters.get_phase_fit_order.params.filter_file_path"></span><strong>filter_file_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.get_phase_fit_order.params.filter_file_path">¶</a> &#8211; Path to the filter file.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.filters.read_filter_file">
<code class="descclassname">orb.utils.filters.</code><code class="descname">read_filter_file</code><span class="sig-paren">(</span><em>filter_file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.filters.read_filter_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a file containing the filter transmission function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.filters.read_filter_file.params.filter_file_path"></span><strong>filter_file_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.filters.read_filter_file.params.filter_file_path">¶</a> &#8211; Path to the filter file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">(list of filter wavelength, list of corresponding
transmission coefficients, minimum edge of the filter, maximum
edge of the filter) (Both min and max edges can be None if they
were not recorded in the file)</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The filter file used must have two colums separated by a
space character. The first column contains the wavelength axis
in nm. The second column contains the transmission
coefficients. Comments are preceded with a #.  Filter edges can
be specified using the keywords : FILTER_MIN and FILTER_MAX:</p>
<div class="last highlight-python"><div class="highlight"><pre>## ORBS filter file 
# Author: Thomas Martin &lt;thomas.martin.1@ulaval.ca&gt;
# Filter name : SpIOMM_R
# Wavelength in nm | Transmission percentage
# FILTER_MIN 648
# FILTER_MAX 678
1000 0.001201585284
999.7999878 0.009733387269
999.5999756 -0.0004460749624
999.4000244 0.01378122438
999.2000122 0.002538740868
</pre></div>
</div>
</div>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.image">
<span id="image"></span><h2><a class="toc-backref" href="#id9">Image</a><a class="headerlink" href="#module-orb.utils.image" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.image.check_frames">
<code class="descclassname">orb.utils.image.</code><code class="descname">check_frames</code><span class="sig-paren">(</span><em>frames</em>, <em>sigma_reject=2.5</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.check_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Check and reject deviating frames based on their median level.</p>
<p>Frames with a too deviant median level are discarded. This
function is used by <code class="xref py py-meth docutils literal"><span class="pre">utils.create_master_frame()</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.image.check_frames.params.frames"></span><strong>frames</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.check_frames.params.frames">¶</a> &#8211; Set of frames to check</li>
<li><span class="target" id="orb.utils.image.check_frames.params.sigma_reject"></span><strong>sigma_reject</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.check_frames.params.sigma_reject">¶</a> &#8211; (Optional) Rejection coefficient (default 2.5)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.compute_binning">
<code class="descclassname">orb.utils.image.</code><code class="descname">compute_binning</code><span class="sig-paren">(</span><em>image_shape</em>, <em>detector_shape</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.compute_binning" title="Permalink to this definition">¶</a></dt>
<dd><p>Return binning along both axis given the image shape and the
detector shape.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.image.compute_binning.params.image_size"></span><strong>image_size</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.compute_binning.params.image_size">¶</a> &#8211; Tuple [x,y] giving the image shape</li>
<li><span class="target" id="orb.utils.image.compute_binning.params.detector_shape"></span><strong>detector_shape</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.compute_binning.params.detector_shape">¶</a> &#8211; Tuple [x,y] giving the detector shape
(i.e. maximum numbers of pixels along the x and y axis.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.correct_hot_pixels">
<code class="descclassname">orb.utils.image.</code><code class="descname">correct_hot_pixels</code><span class="sig-paren">(</span><em>im</em>, <em>hp_map</em>, <em>box_size=3</em>, <em>std_filter_coeff=1.5</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.correct_hot_pixels" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct hot pixels in an image given a map of their position.</p>
<p>The algorithm used replaces a hot pixel value by the median of the
pixels in a box around it. Pixels values which are not too much
different from the values around are not modified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.image.correct_hot_pixels.params.im"></span><strong>im</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.correct_hot_pixels.params.im">¶</a> &#8211; Image to correct</li>
<li><span class="target" id="orb.utils.image.correct_hot_pixels.params.hp_map"></span><strong>hp_map</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.correct_hot_pixels.params.hp_map">¶</a> &#8211; Hot pixels map (1 for hot pixels, 0 for normal
pixel)</li>
<li><span class="target" id="orb.utils.image.correct_hot_pixels.params.box_size"></span><strong>box_size</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.correct_hot_pixels.params.box_size">¶</a> &#8211; (Optional) Size of the correction box (default
3).</li>
<li><span class="target" id="orb.utils.image.correct_hot_pixels.params.std_filter_coeff"></span><strong>std_filter_coeff</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.correct_hot_pixels.params.std_filter_coeff">¶</a> &#8211; (Optional) Coefficient on the std used to
check if the value of a hot pixel must be changed (default 1.5).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.correct_map2d">
<code class="descclassname">orb.utils.image.</code><code class="descname">correct_map2d</code><span class="sig-paren">(</span><em>map2d</em>, <em>bad_value=nan</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.correct_map2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct a map of values by interpolation along columns.</p>
<p>The bad value must be specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.image.correct_map2d.params.map2d"></span><strong>map2d</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.correct_map2d.params.map2d">¶</a> &#8211; The map to correct</li>
<li><span class="target" id="orb.utils.image.correct_map2d.params.bad_value"></span><strong>bad_value</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.correct_map2d.params.bad_value">¶</a> &#8211; (Optional) Value considered as bad (default
np.nan).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.create_master_frame">
<code class="descclassname">orb.utils.image.</code><code class="descname">create_master_frame</code><span class="sig-paren">(</span><em>frames</em>, <em>combine='average'</em>, <em>reject='avsigclip'</em>, <em>sigma=3.0</em>, <em>silent=False</em>, <em>check=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.create_master_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a master frame from a set a frames.</p>
<p>This method has been inspired by the <strong>IRAF</strong> function
combine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.image.create_master_frame.params.frames"></span><strong>frames</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.create_master_frame.params.frames">¶</a> &#8211; Frames to combine.</li>
<li><span class="target" id="orb.utils.image.create_master_frame.params.reject"></span><strong>reject</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.create_master_frame.params.reject">¶</a> &#8211; (Optional) Rejection operation. Can be &#8216;sigclip&#8217;,
&#8216;minmax&#8217;, &#8216;avsigclip&#8217; (default &#8216;avsigclip&#8217;)</li>
<li><span class="target" id="orb.utils.image.create_master_frame.params.combine"></span><strong>combine</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.create_master_frame.params.combine">¶</a> &#8211; (Optional) Combining operation. Can be
&#8216;average&#8217; or &#8216;median&#8217; (default &#8216;average&#8217;)</li>
<li><span class="target" id="orb.utils.image.create_master_frame.params.sigma"></span><strong>sigma</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.create_master_frame.params.sigma">¶</a> &#8211; (Optional) Sigma factor for pixel rejection
(default 3.).</li>
<li><span class="target" id="orb.utils.image.create_master_frame.params.silent"></span><strong>silent</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.create_master_frame.params.silent">¶</a> &#8211; (Optional) If True no information message are
displayed.</li>
<li><span class="target" id="orb.utils.image.create_master_frame.params.check"></span><strong>check</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.create_master_frame.params.check">¶</a> &#8211; (Optional) If True deviating frames are rejected
before combination (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Rejection operations:</p>
<ul class="last simple">
<li><strong>sigclip</strong>: A Sigma Clipping algorithm is applied for
each pixel. Min and max values are rejected to estimate
the mean and the standard deviation at each pixel. Then
all values over (median + sigma * std) or below (median -
sigma * std) are rejected. Those steps are repeated (this
time not excluding the extreme values) while no other
value is rejected or the minimum number of values to keep
is reached. Work best with at least 10 frames.</li>
<li><strong>avsigclip</strong>: Average Sigma Clipping algorithm is the
same as Sigma Clipping algorithm but the standard
deviation at each pixel is estimated using an averaged
value of the std over the lines. This work best than sigma
clipping for a small number of frames. This algorithm is a
little more time consuming than the others. Works best with
at least 5 frames.</li>
<li><strong>minmax</strong>: Minimum and maximum values at each pixel are
rejected.</li>
</ul>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">No rejection operation can be performed with less
than 3 frames.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.fit_calibration_laser_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">fit_calibration_laser_map</code><span class="sig-paren">(</span><em>calib_laser_map</em>, <em>calib_laser_nm</em>, <em>pixel_size=15.0</em>, <em>binning=4</em>, <em>mirror_distance_guess=240000.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_calibration_laser_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a calibration laser map.</p>
<p>Fit a classic optical model first and uses Zernike polynomials to
fit the residual.</p>
<p>The model is based on optical parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.image.fit_calibration_laser_map.params.calib_laser_map"></span><strong>calib_laser_map</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.fit_calibration_laser_map.params.calib_laser_map">¶</a> &#8211; Reference calibration laser map.</li>
<li><span class="target" id="orb.utils.image.fit_calibration_laser_map.params.calib_laser_nm"></span><strong>calib_laser_nm</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.fit_calibration_laser_map.params.calib_laser_nm">¶</a> &#8211; Wavelength of the calibration laser in nm.</li>
<li><span class="target" id="orb.utils.image.fit_calibration_laser_map.params.pixel_size"></span><strong>pixel_size</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.fit_calibration_laser_map.params.pixel_size">¶</a> &#8211; (Optional) Size of the CCD pixels in um
(default 15).</li>
<li><span class="target" id="orb.utils.image.fit_calibration_laser_map.params.binning"></span><strong>binning</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.fit_calibration_laser_map.params.binning">¶</a> &#8211; (Optional) Maps are binned to accelerate the
process. Set the binning factor (default 4).</li>
<li><span class="target" id="orb.utils.image.fit_calibration_laser_map.params.mirror_distance_guess"></span><strong>mirror_distance_guess</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.fit_calibration_laser_map.params.mirror_distance_guess">¶</a> &#8211; (Optional) Guess on the mirror
distance in um (default 2.2e5).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Zernike polynomial fit routine has been written by Tim
van Werkhoven (<a class="reference external" href="mailto:werkhoven&#37;&#52;&#48;strw&#46;leidenuniv&#46;nl">werkhoven<span>&#64;</span>strw<span>&#46;</span>leidenuniv<span>&#46;</span>nl</a>) as a part of
libtim. It can be found in ORB module in ./ext/zern.py.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.fit_highorder_phase_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">fit_highorder_phase_map</code><span class="sig-paren">(</span><em>phase_map</em>, <em>err_map</em>, <em>nmodes=10</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_highorder_phase_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Robust fit phase maps of order &gt; 1</p>
<p>First fit pass is made with a polynomial of order 1.</p>
<p>Second pass is a Zernike fit of the residual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="orb.utils.image.fit_highorder_phase_map.params.phase_map"></span><strong>phase_map</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.fit_highorder_phase_map.params.phase_map">¶</a> &#8211; Phase map to fit</li>
<li><span class="target" id="orb.utils.image.fit_highorder_phase_map.params.err_map"></span><strong>err_map</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.fit_highorder_phase_map.params.err_map">¶</a> &#8211; Error map of phase map values</li>
<li><span class="target" id="orb.utils.image.fit_highorder_phase_map.params.nmodes"></span><strong>nmodes</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.fit_highorder_phase_map.params.nmodes">¶</a> &#8211; (Optional) Number of Zernike modes (default 10).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple: (Fitted map, residual map)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.fit_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">fit_map</code><span class="sig-paren">(</span><em>data_map</em>, <em>err_map</em>, <em>smooth_deg</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit map with low order polynomials</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="orb.utils.image.fit_map.params.data_map"></span><strong>data_map</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.fit_map.params.data_map">¶</a> &#8211; data map</li>
<li><span class="target" id="orb.utils.image.fit_map.params.err_map"></span><strong>err_map</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.fit_map.params.err_map">¶</a> &#8211; error map</li>
<li><span class="target" id="orb.utils.image.fit_map.params.smooth_deg"></span><strong>smooth_deg</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.fit_map.params.smooth_deg">¶</a> &#8211; Degree of fit smoothing (beware of high
smoothing degrees)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a tuple: (fitted data map, residual map, fit RMS error)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.fit_map_zernike">
<code class="descclassname">orb.utils.image.</code><code class="descname">fit_map_zernike</code><span class="sig-paren">(</span><em>data_map</em>, <em>weights_map</em>, <em>nmodes</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_map_zernike" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a map with Zernike polynomials.</p>
<p>Bad values must be set to NaN (not 0.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="orb.utils.image.fit_map_zernike.params.data_map"></span><strong>data_map</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.fit_map_zernike.params.data_map">¶</a> &#8211; Data map to fit</li>
<li><span class="target" id="orb.utils.image.fit_map_zernike.params.weights_map"></span><strong>weights_map</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.fit_map_zernike.params.weights_map">¶</a> &#8211; weights map (high weight value stands for high
precision data)</li>
<li><span class="target" id="orb.utils.image.fit_map_zernike.params.nmodes"></span><strong>nmodes</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.fit_map_zernike.params.nmodes">¶</a> &#8211; Number of zernike modes to use for fitting.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(fitted data map, error map, fit error)</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Zernike polynomial fit routine has been written by Tim
van Werkhoven (<a class="reference external" href="mailto:werkhoven&#37;&#52;&#48;strw&#46;leidenuniv&#46;nl">werkhoven<span>&#64;</span>strw<span>&#46;</span>leidenuniv<span>&#46;</span>nl</a>) as a part of
libtim. It can be found in ORB module in ./ext/zern.py.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.fit_sitelle_phase_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">fit_sitelle_phase_map</code><span class="sig-paren">(</span><em>phase_map</em>, <em>phase_map_err</em>, <em>calib_laser_map</em>, <em>calib_laser_nm</em>, <em>pixel_size=15.0</em>, <em>binning=4</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.fit_sitelle_phase_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a SITELLE phase map (order 0 map of the phase) using a
model based on a simulated calibration laser map..</p>
<p>A real calibration laser map is needed first to get a first guess
on the parameters of the fit. Then the whole phase map is modeled
to fit the real phase map.</p>
<p>The modeled calibration laser map obtained from the fit is also
returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="orb.utils.image.fit_sitelle_phase_map.params.phase_map"></span><strong>phase_map</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.fit_sitelle_phase_map.params.phase_map">¶</a> &#8211; Phase map to fit.</li>
<li><span class="target" id="orb.utils.image.fit_sitelle_phase_map.params.phase_map_err"></span><strong>phase_map_err</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.fit_sitelle_phase_map.params.phase_map_err">¶</a> &#8211; Error on the phase map values.</li>
<li><span class="target" id="orb.utils.image.fit_sitelle_phase_map.params.calib_laser_map"></span><strong>calib_laser_map</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.fit_sitelle_phase_map.params.calib_laser_map">¶</a> &#8211; Reference calibration laser map.</li>
<li><span class="target" id="orb.utils.image.fit_sitelle_phase_map.params.calib_laser_nm"></span><strong>calib_laser_nm</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.fit_sitelle_phase_map.params.calib_laser_nm">¶</a> &#8211; Wavelength of the calibration laser in nm.</li>
<li><span class="target" id="orb.utils.image.fit_sitelle_phase_map.params.pixel_size"></span><strong>pixel_size</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.fit_sitelle_phase_map.params.pixel_size">¶</a> &#8211; (Optional) Size of the CCD pixels in um
(default 15).</li>
<li><span class="target" id="orb.utils.image.fit_sitelle_phase_map.params.binning"></span><strong>binning</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.fit_sitelle_phase_map.params.binning">¶</a> &#8211; (Optional) Maps are binned to accelerate the
process. Set the binning factor (default 4).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a tuple (fitted phase map, error map, fit error, new
calibration laser map)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.get_box_coords">
<code class="descclassname">orb.utils.image.</code><code class="descname">get_box_coords</code><span class="sig-paren">(</span><em>ix</em>, <em>iy</em>, <em>box_size</em>, <em>x_lim_min</em>, <em>x_lim_max</em>, <em>y_lim_min</em>, <em>y_lim_max</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.get_box_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coordinates of a box given the center of the box,
its size and the limits of the range along x and y axes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="orb.utils.image.get_box_coords.params.ix"></span><strong>ix</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.get_box_coords.params.ix">¶</a> &#8211; center of the box along x axis</li>
<li><span class="target" id="orb.utils.image.get_box_coords.params.iy"></span><strong>iy</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.get_box_coords.params.iy">¶</a> &#8211; center of the box along y axis</li>
<li><span class="target" id="orb.utils.image.get_box_coords.params.box_size"></span><strong>box_size</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.get_box_coords.params.box_size">¶</a> &#8211; Size of the box. The final size of the box will
generally be the same if box_size is odd. Note that the final
size of the box cannot be guaranteed.</li>
<li><span class="target" id="orb.utils.image.get_box_coords.params.x_lim_min"></span><strong>x_lim_min</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.get_box_coords.params.x_lim_min">¶</a> &#8211; Minimum limit of the range along x.</li>
<li><span class="target" id="orb.utils.image.get_box_coords.params.x_lim_max"></span><strong>x_lim_max</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.get_box_coords.params.x_lim_max">¶</a> &#8211; Maximum limit of the range along x.</li>
<li><span class="target" id="orb.utils.image.get_box_coords.params.y_lim_min"></span><strong>y_lim_min</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.get_box_coords.params.y_lim_min">¶</a> &#8211; Minimum limit of the range along y.</li>
<li><span class="target" id="orb.utils.image.get_box_coords.params.y_lim_max"></span><strong>y_lim_max</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.get_box_coords.params.y_lim_max">¶</a> &#8211; Maximum limit of the range along y.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">x_min, x_max, y_min, y_max</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.high_pass_diff_image_filter">
<code class="descclassname">orb.utils.image.</code><code class="descname">high_pass_diff_image_filter</code><span class="sig-paren">(</span><em>im</em>, <em>deg=1</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.high_pass_diff_image_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a high pass filtered image using the method of low pass
diffrence filtering given by Mighell (1999).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.image.high_pass_diff_image_filter.params.im"></span><strong>im</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.high_pass_diff_image_filter.params.im">¶</a> &#8211; Image to filter</li>
<li><span class="target" id="orb.utils.image.high_pass_diff_image_filter.params.deg"></span><strong>deg</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.high_pass_diff_image_filter.params.deg">¶</a> &#8211; (Optional) Radius of the kernel of the low pass
filter. Must be &gt; 0 (default 1).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.high_pass_image_filter">
<code class="descclassname">orb.utils.image.</code><code class="descname">high_pass_image_filter</code><span class="sig-paren">(</span><em>im</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.high_pass_image_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a high pass filtered image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.image.high_pass_image_filter.params.im"></span><strong>im</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.high_pass_image_filter.params.im">¶</a> &#8211; Image to filter</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.interpolate_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">interpolate_map</code><span class="sig-paren">(</span><em>m</em>, <em>dimx</em>, <em>dimy</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.interpolate_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate 2D data map.</p>
<p>This function is robust to Nans.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The interpolation process is much longer if Nans are
present in the map.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.image.interpolate_map.params.m"></span><strong>m</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.interpolate_map.params.m">¶</a> &#8211; Map</li>
<li><span class="target" id="orb.utils.image.interpolate_map.params.dimx"></span><strong>dimx</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.interpolate_map.params.dimx">¶</a> &#8211; X dimension of the result</li>
<li><span class="target" id="orb.utils.image.interpolate_map.params.dimy"></span><strong>dimy</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.interpolate_map.params.dimy">¶</a> &#8211; Y dimension of the result</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.low_pass_image_filter">
<code class="descclassname">orb.utils.image.</code><code class="descname">low_pass_image_filter</code><span class="sig-paren">(</span><em>im</em>, <em>deg</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.low_pass_image_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a low pass filtered image using a gaussian kernel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.image.low_pass_image_filter.params.im"></span><strong>im</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.low_pass_image_filter.params.im">¶</a> &#8211; Image to filter</li>
<li><span class="target" id="orb.utils.image.low_pass_image_filter.params.deg"></span><strong>deg</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.low_pass_image_filter.params.deg">¶</a> &#8211; Radius of the kernel. Must be &gt; 0.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.nanbin_image">
<code class="descclassname">orb.utils.image.</code><code class="descname">nanbin_image</code><span class="sig-paren">(</span><em>im</em>, <em>binning</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.nanbin_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Mean image binning robust to NaNs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.image.nanbin_image.params.im"></span><strong>im</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.nanbin_image.params.im">¶</a> &#8211; Image to bin</li>
<li><span class="target" id="orb.utils.image.nanbin_image.params.binning"></span><strong>binning</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.nanbin_image.params.binning">¶</a> &#8211; Binning factor (must be an integer)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.polar_map2d">
<code class="descclassname">orb.utils.image.</code><code class="descname">polar_map2d</code><span class="sig-paren">(</span><em>f</em>, <em>n</em>, <em>corner=False</em>, <em>circle=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.polar_map2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Map a function over a square matrix in polar coordinates. The
origin is placed at the center of the map by default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.image.polar_map2d.params.f"></span><strong>f</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.polar_map2d.params.f">¶</a> &#8211; The function to map.</li>
<li><span class="target" id="orb.utils.image.polar_map2d.params.n"></span><strong>n</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.polar_map2d.params.n">¶</a> &#8211; Matrix size. Can be a couple of integers (nx, ny).</li>
<li><span class="target" id="orb.utils.image.polar_map2d.params.corner"></span><strong>corner</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.polar_map2d.params.corner">¶</a> &#8211; (Optional) If True, the origin of the coordinates
becomes the corner (0,0) of the map (default False)</li>
<li><span class="target" id="orb.utils.image.polar_map2d.params.circle"></span><strong>circle</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.polar_map2d.params.circle">¶</a> &#8211; (Optional) If False and if the matrix is not
squared, the coordinates are those of an ellipsis of the same
shape as the matrix (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.pp_create_master_frame">
<code class="descclassname">orb.utils.image.</code><code class="descname">pp_create_master_frame</code><span class="sig-paren">(</span><em>frames</em>, <em>combine='average'</em>, <em>reject='avsigclip'</em>, <em>sigma=3.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.pp_create_master_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a parallelized version of <code class="xref py py-meth docutils literal"><span class="pre">utils.create_master_frame()</span></code>.</p>
<p>Use it only for big data set because it can be much slower for a
small data set (&lt; 500 x 500 x 10).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.image.pp_create_master_frame.params.frames"></span><strong>frames</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.pp_create_master_frame.params.frames">¶</a> &#8211; Frames to combine.</li>
<li><span class="target" id="orb.utils.image.pp_create_master_frame.params.reject"></span><strong>reject</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.pp_create_master_frame.params.reject">¶</a> &#8211; (Optional) Rejection operation. Can be &#8216;sigclip&#8217;,
&#8216;minmax&#8217;, &#8216;avsigclip&#8217; (default &#8216;avsigclip&#8217;)</li>
<li><span class="target" id="orb.utils.image.pp_create_master_frame.params.combine"></span><strong>combine</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.pp_create_master_frame.params.combine">¶</a> &#8211; (Optional) Combining operation. Can be
&#8216;average&#8217; or &#8216;median&#8217; (default &#8216;average&#8217;)</li>
<li><span class="target" id="orb.utils.image.pp_create_master_frame.params.sigma"></span><strong>sigma</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.pp_create_master_frame.params.sigma">¶</a> &#8211; (Optional) Sigma factor for pixel rejection
(default 3.).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><code class="xref py py-meth docutils literal"><span class="pre">utils.create_master_frame()</span></code></p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.shift_frame">
<code class="descclassname">orb.utils.image.</code><code class="descname">shift_frame</code><span class="sig-paren">(</span><em>frame</em>, <em>dx</em>, <em>dy</em>, <em>x_min</em>, <em>x_max</em>, <em>y_min</em>, <em>y_max</em>, <em>order</em>, <em>fill_value=nan</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.shift_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shifted frame wit the same dimensions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.image.shift_frame.params.frame"></span><strong>frame</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.shift_frame.params.frame">¶</a> &#8211; Two dimensions array to be shifted</li>
<li><span class="target" id="orb.utils.image.shift_frame.params.dx"></span><strong>dx</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.shift_frame.params.dx">¶</a> &#8211; Shift value along the axis 0</li>
<li><span class="target" id="orb.utils.image.shift_frame.params.dy"></span><strong>dy</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.shift_frame.params.dy">¶</a> &#8211; Shift value along the axis 1</li>
<li><span class="target" id="orb.utils.image.shift_frame.params.x_max, y_min, y_max"></span><strong>x_max, y_min, y_max</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.shift_frame.params.x_max, y_min, y_max">¶</a> (<em>x_min,</em>) &#8211; Boundaries of the region to be
shifted.</li>
<li><span class="target" id="orb.utils.image.shift_frame.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.shift_frame.params.order">¶</a> &#8211; interpolation order.</li>
<li><span class="target" id="orb.utils.image.shift_frame.params.(Optional)"></span><strong>(Optional)</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.shift_frame.params.(Optional)">¶</a> (<em>fill_value</em>) &#8211; Value of the extrapolated points
(default np.nan).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To avoid spline interpolation defects around
stars use order 1 (linear interpolation).</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.simulate_calibration_laser_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">simulate_calibration_laser_map</code><span class="sig-paren">(</span><em>nx</em>, <em>ny</em>, <em>pixel_size</em>, <em>calib_laser_wl</em>, <em>mirror_distance</em>, <em>theta_c</em>, <em>phi_x</em>, <em>phi_y</em>, <em>phi_r</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.simulate_calibration_laser_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Simulate a calibration laser map from optical and mechanical parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.image.simulate_calibration_laser_map.params.nx"></span><strong>nx</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.simulate_calibration_laser_map.params.nx">¶</a> &#8211; Number of pixels along X</li>
<li><span class="target" id="orb.utils.image.simulate_calibration_laser_map.params.ny"></span><strong>ny</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.simulate_calibration_laser_map.params.ny">¶</a> &#8211; Number of pixels along Y</li>
<li><span class="target" id="orb.utils.image.simulate_calibration_laser_map.params.pixel_size"></span><strong>pixel_size</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.simulate_calibration_laser_map.params.pixel_size">¶</a> &#8211; Size of a pixel in microns</li>
<li><span class="target" id="orb.utils.image.simulate_calibration_laser_map.params.calib_laser_wl"></span><strong>calib_laser_wl</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.simulate_calibration_laser_map.params.calib_laser_wl">¶</a> &#8211; Calibration laser wavelength in nm</li>
<li><span class="target" id="orb.utils.image.simulate_calibration_laser_map.params.mirror_distance"></span><strong>mirror_distance</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.simulate_calibration_laser_map.params.mirror_distance">¶</a> &#8211; Distance to the mirror in microns on the
optical axis.</li>
<li><span class="target" id="orb.utils.image.simulate_calibration_laser_map.params.theta_c"></span><strong>theta_c</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.simulate_calibration_laser_map.params.theta_c">¶</a> &#8211; Angle from the optical axis to the mirror
center in degrees</li>
<li><span class="target" id="orb.utils.image.simulate_calibration_laser_map.params.phi_x"></span><strong>phi_x</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.simulate_calibration_laser_map.params.phi_x">¶</a> &#8211; Tilt of the mirror along X in degrees</li>
<li><span class="target" id="orb.utils.image.simulate_calibration_laser_map.params.phi_y"></span><strong>phi_y</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.simulate_calibration_laser_map.params.phi_y">¶</a> &#8211; Tilt of the mirror along Y in degrees</li>
<li><span class="target" id="orb.utils.image.simulate_calibration_laser_map.params.phi_r"></span><strong>phi_r</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.simulate_calibration_laser_map.params.phi_r">¶</a> &#8211; angle from the center of the frame to the optical
axis along X axis in degrees (equivalent to a rotation of the
camera)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.tilt_calibration_laser_map">
<code class="descclassname">orb.utils.image.</code><code class="descname">tilt_calibration_laser_map</code><span class="sig-paren">(</span><em>cmap</em>, <em>calib_laser_nm</em>, <em>phi_x</em>, <em>phi_y</em>, <em>phi_r</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.tilt_calibration_laser_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Tilt and rotate a calibration laser map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.image.tilt_calibration_laser_map.params.cmap"></span><strong>cmap</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.tilt_calibration_laser_map.params.cmap">¶</a> &#8211; calibration laser map.</li>
<li><span class="target" id="orb.utils.image.tilt_calibration_laser_map.params.calib_laser_nm"></span><strong>calib_laser_nm</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.tilt_calibration_laser_map.params.calib_laser_nm">¶</a> &#8211; Calibration laser wavelength in nm.</li>
<li><span class="target" id="orb.utils.image.tilt_calibration_laser_map.params.phi_x"></span><strong>phi_x</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.tilt_calibration_laser_map.params.phi_x">¶</a> &#8211; tilt angle along X axis (degrees).</li>
<li><span class="target" id="orb.utils.image.tilt_calibration_laser_map.params.phi_y"></span><strong>phi_y</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.tilt_calibration_laser_map.params.phi_y">¶</a> &#8211; tilt angle along Y axis (degrees).</li>
<li><span class="target" id="orb.utils.image.tilt_calibration_laser_map.params.phi_r"></span><strong>phi_r</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.tilt_calibration_laser_map.params.phi_r">¶</a> &#8211; Rotation angle (degrees).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.image.transform_frame">
<code class="descclassname">orb.utils.image.</code><code class="descname">transform_frame</code><span class="sig-paren">(</span><em>frame</em>, <em>x_min</em>, <em>x_max</em>, <em>y_min</em>, <em>y_max</em>, <em>d</em>, <em>rc</em>, <em>zoom_factor</em>, <em>interp_order</em>, <em>mask=None</em>, <em>fill_value=nan</em>, <em>sip_A=None</em>, <em>sip_B=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.image.transform_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform one frame or a part of it using transformation
coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.image.transform_frame.params.frame"></span><strong>frame</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.transform_frame.params.frame">¶</a> &#8211; Frame to transform</li>
<li><span class="target" id="orb.utils.image.transform_frame.params.x_min"></span><strong>x_min</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.transform_frame.params.x_min">¶</a> &#8211; Lower x boundary of the transformed section (can be
a tuple in order to get multiple sections)</li>
<li><span class="target" id="orb.utils.image.transform_frame.params.x_max"></span><strong>x_max</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.transform_frame.params.x_max">¶</a> &#8211; Upper x boundary of the transformed section (can be
a tuple in order to get multiple sections)</li>
<li><span class="target" id="orb.utils.image.transform_frame.params.y_min"></span><strong>y_min</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.transform_frame.params.y_min">¶</a> &#8211; Lower y boundary of the transformed section (can be
a tuple in order to get multiple sections)</li>
<li><span class="target" id="orb.utils.image.transform_frame.params.y_max"></span><strong>y_max</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.transform_frame.params.y_max">¶</a> &#8211; Upper y boundary of the transformed section (can be
a tuple in order to get multiple sections)</li>
<li><span class="target" id="orb.utils.image.transform_frame.params.d"></span><strong>d</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.transform_frame.params.d">¶</a> &#8211; Transformation coefficients [dx, dy, dr, da, db]</li>
<li><span class="target" id="orb.utils.image.transform_frame.params.rc"></span><strong>rc</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.transform_frame.params.rc">¶</a> &#8211; Rotation center of the frame [rc_x, rc_y]</li>
<li><span class="target" id="orb.utils.image.transform_frame.params.zoom_factor"></span><strong>zoom_factor</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.transform_frame.params.zoom_factor">¶</a> &#8211; Zoom on the image. Can be a couple (zx, zy).</li>
<li><span class="target" id="orb.utils.image.transform_frame.params.interp_order"></span><strong>interp_order</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.transform_frame.params.interp_order">¶</a> &#8211; Interpolation order</li>
<li><span class="target" id="orb.utils.image.transform_frame.params.mask"></span><strong>mask</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.transform_frame.params.mask">¶</a> &#8211; (Optional) If a mask frame is passed it is
transformed also (default None).</li>
<li><span class="target" id="orb.utils.image.transform_frame.params.fill_value"></span><strong>fill_value</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.transform_frame.params.fill_value">¶</a> &#8211; (Optional) Fill value for extrapolated points
(default np.nan).</li>
<li><span class="target" id="orb.utils.image.transform_frame.params.sip_A"></span><strong>sip_A</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.transform_frame.params.sip_A">¶</a> &#8211; (Optional) pywcs.WCS() instance containing SIP parameters of
the output image (default None).</li>
<li><span class="target" id="orb.utils.image.transform_frame.params.sip_B"></span><strong>sip_B</strong><a class="paramlink headerlink reference internal" href="#orb.utils.image.transform_frame.params.sip_B">¶</a> &#8211; (Optional) pywcs.WCS() instance containing SIP parameters of
the input image (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.io">
<span id="io"></span><h2><a class="toc-backref" href="#id10">IO</a><a class="headerlink" href="#module-orb.utils.io" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.io.bin_image">
<code class="descclassname">orb.utils.io.</code><code class="descname">bin_image</code><span class="sig-paren">(</span><em>a</em>, <em>binning</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.bin_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mean binned image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.io.bin_image.params.image"></span><strong>image</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.bin_image.params.image">¶</a> &#8211; 2d array to bin.</li>
<li><span class="target" id="orb.utils.io.bin_image.params.binning"></span><strong>binning</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.bin_image.params.binning">¶</a> &#8211; binning (must be an integer &gt;= 1).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Only the complete sets of rows or columns are binned
so that depending on the bin size and the image size the
last columns or rows can be ignored. This ensures that the
binning surface is the same for every pixel in the binned
array.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.get_hdu_data_index">
<code class="descclassname">orb.utils.io.</code><code class="descname">get_hdu_data_index</code><span class="sig-paren">(</span><em>hdul</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.get_hdu_data_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the first header data unit (HDU) containing data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.io.get_hdu_data_index.params.hdul"></span><strong>hdul</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.get_hdu_data_index.params.hdul">¶</a> &#8211; A pyfits.HDU instance</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.get_sitelle_slice">
<code class="descclassname">orb.utils.io.</code><code class="descname">get_sitelle_slice</code><span class="sig-paren">(</span><em>slice_str</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.get_sitelle_slice" title="Permalink to this definition">¶</a></dt>
<dd><p>Strip a string containing SITELLE like slice coordinates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.io.get_sitelle_slice.params.slice_str"></span><strong>slice_str</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.get_sitelle_slice.params.slice_str">¶</a> &#8211; Slice string.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.read_fits">
<code class="descclassname">orb.utils.io.</code><code class="descname">read_fits</code><span class="sig-paren">(</span><em>fits_path</em>, <em>no_error=False</em>, <em>nan_filter=False</em>, <em>return_header=False</em>, <em>return_hdu_only=False</em>, <em>return_mask=False</em>, <em>silent=False</em>, <em>delete_after=False</em>, <em>data_index=0</em>, <em>image_mode='classic'</em>, <em>chip_index=None</em>, <em>binning=None</em>, <em>fix_header=True</em>, <em>memmap=False</em>, <em>dtype=&lt;type 'float'&gt;</em>, <em>mask_path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.read_fits" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a FITS data file and returns its data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.io.read_fits.params.fits_path"></span><strong>fits_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_fits.params.fits_path">¶</a> &#8211; Path to the file, can be either
relative or absolut.</li>
<li><span class="target" id="orb.utils.io.read_fits.params.no_error"></span><strong>no_error</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_fits.params.no_error">¶</a> &#8211; (Optional) If True this function will only
display a warning message if the file does not exist (so it
does not raise an exception) (default False)</li>
<li><span class="target" id="orb.utils.io.read_fits.params.nan_filter"></span><strong>nan_filter</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_fits.params.nan_filter">¶</a> &#8211; (Optional) If True replace NaN by zeros
(default False)</li>
<li><span class="target" id="orb.utils.io.read_fits.params.return_header"></span><strong>return_header</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_fits.params.return_header">¶</a> &#8211; (Optional) If True return a tuple (data,
header) (default False).</li>
<li><span class="target" id="orb.utils.io.read_fits.params.return_hdu_only"></span><strong>return_hdu_only</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_fits.params.return_hdu_only">¶</a> &#8211; (Optional) If True return FITS header
data unit only. No data will be returned (default False).</li>
<li><span class="target" id="orb.utils.io.read_fits.params.return_mask"></span><strong>return_mask</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_fits.params.return_mask">¶</a> &#8211; (Optional) If True return only the mask
corresponding to the data file (default False).</li>
<li><span class="target" id="orb.utils.io.read_fits.params.silent"></span><strong>silent</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_fits.params.silent">¶</a> &#8211; (Optional) If True no message is displayed
except if an error is raised (default False).</li>
<li><span class="target" id="orb.utils.io.read_fits.params.delete_after"></span><strong>delete_after</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_fits.params.delete_after">¶</a> &#8211; (Optional) If True delete file after
reading (default False).</li>
<li><span class="target" id="orb.utils.io.read_fits.params.data_index"></span><strong>data_index</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_fits.params.data_index">¶</a> &#8211; (Optional) Index of data in the header data
unit (Default 0).</li>
<li><span class="target" id="orb.utils.io.read_fits.params.image_mode"></span><strong>image_mode</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_fits.params.image_mode">¶</a> &#8211; (Optional) Can be &#8216;sitelle&#8217;, &#8216;spiomm&#8217; or
&#8216;classic&#8217;. In &#8216;sitelle&#8217; mode, the parameter
chip_index must also be set to 0 or 1. In this mode only
one of both SITELLE quadrants is returned. In &#8216;classic&#8217; mode
the whole frame is returned (default &#8216;classic&#8217;).</li>
<li><span class="target" id="orb.utils.io.read_fits.params.chip_index"></span><strong>chip_index</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_fits.params.chip_index">¶</a> &#8211; (Optional) Index of the chip of the
SITELLE image. Used only if image_mode is set to &#8216;sitelle&#8217;
In this case, must be 1 or 2. Else must be None (default
None).</li>
<li><span class="target" id="orb.utils.io.read_fits.params.binning"></span><strong>binning</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_fits.params.binning">¶</a> &#8211; (Optional) If not None, returned data is
binned by this amount (must be an integer &gt;= 1)</li>
<li><span class="target" id="orb.utils.io.read_fits.params.fix_header"></span><strong>fix_header</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_fits.params.fix_header">¶</a> &#8211; (Optional) If True, fits header is
fixed to avoid errors due to header inconsistencies
(e.g. WCS errors) (default True).</li>
<li><span class="target" id="orb.utils.io.read_fits.params.memmap"></span><strong>memmap</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_fits.params.memmap">¶</a> &#8211; (Optional) If True, use the memory mapping
option of pyfits. This is useful to avoid loading a full cube
in memory when opening a large data cube (default False).</li>
<li><span class="target" id="orb.utils.io.read_fits.params.dtype"></span><strong>dtype</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_fits.params.dtype">¶</a> &#8211; (Optional) Data is converted to
the given dtype (e.g. np.float32, default float).</li>
<li><span class="target" id="orb.utils.io.read_fits.params.mask_path"></span><strong>mask_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_fits.params.mask_path">¶</a> &#8211; (Optional) Path to the corresponding mask image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please refer to
<a class="reference external" href="http://www.stsci.edu/institute/software_hardware/pyfits/">http://www.stsci.edu/institute/software_hardware/pyfits/</a> for
more information on PyFITS module. And
<a class="reference external" href="http://fits.gsfc.nasa.gov/">http://fits.gsfc.nasa.gov/</a> for more information on FITS
files.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.read_sitelle_chip">
<code class="descclassname">orb.utils.io.</code><code class="descname">read_sitelle_chip</code><span class="sig-paren">(</span><em>hdu</em>, <em>chip_index</em>, <em>substract_bias=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.read_sitelle_chip" title="Permalink to this definition">¶</a></dt>
<dd><p>Return chip data of a SITELLE FITS image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.io.read_sitelle_chip.params.hdu"></span><strong>hdu</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_sitelle_chip.params.hdu">¶</a> &#8211; pyfits.HDU Instance of the SITELLE image</li>
<li><span class="target" id="orb.utils.io.read_sitelle_chip.params.chip_index"></span><strong>chip_index</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_sitelle_chip.params.chip_index">¶</a> &#8211; Index of the chip to read. Must be 1 or 2.</li>
<li><span class="target" id="orb.utils.io.read_sitelle_chip.params.substract_bias"></span><strong>substract_bias</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_sitelle_chip.params.substract_bias">¶</a> &#8211; If True bias is automatically
substracted by using the overscan area (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.read_spiomm_data">
<code class="descclassname">orb.utils.io.</code><code class="descname">read_spiomm_data</code><span class="sig-paren">(</span><em>hdu</em>, <em>image_path</em>, <em>substract_bias=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.read_spiomm_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Return data of an SpIOMM FITS image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.io.read_spiomm_data.params.hdu"></span><strong>hdu</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_spiomm_data.params.hdu">¶</a> &#8211; pyfits.HDU Instance of the SpIOMM image</li>
<li><span class="target" id="orb.utils.io.read_spiomm_data.params.image_path"></span><strong>image_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_spiomm_data.params.image_path">¶</a> &#8211; Image path</li>
<li><span class="target" id="orb.utils.io.read_spiomm_data.params.substract_bias"></span><strong>substract_bias</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.read_spiomm_data.params.substract_bias">¶</a> &#8211; If True bias is automatically
substracted by using the associated bias frame as an
overscan frame. Mean bias level is thus computed along the y
axis of the bias frame (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.io.write_fits">
<code class="descclassname">orb.utils.io.</code><code class="descname">write_fits</code><span class="sig-paren">(</span><em>fits_path</em>, <em>fits_data</em>, <em>fits_header=None</em>, <em>silent=False</em>, <em>overwrite=False</em>, <em>mask=None</em>, <em>replace=False</em>, <em>record_stats=False</em>, <em>mask_path=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.io.write_fits" title="Permalink to this definition">¶</a></dt>
<dd><p>Write data in FITS format. If the file doesn&#8217;t exist create
it with its directories.</p>
<p>If the file already exists add a number to its name before the
extension (unless &#8216;overwrite&#8217; option is set to True).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.io.write_fits.params.fits_path"></span><strong>fits_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.write_fits.params.fits_path">¶</a> &#8211; Path to the file, can be either
relative or absolut.</li>
<li><span class="target" id="orb.utils.io.write_fits.params.fits_data"></span><strong>fits_data</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.write_fits.params.fits_data">¶</a> &#8211; Data to be written in the file.</li>
<li><span class="target" id="orb.utils.io.write_fits.params.fits_header"></span><strong>fits_header</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.write_fits.params.fits_header">¶</a> &#8211; (Optional) Optional keywords to update or
create. It can be a pyfits.Header() instance or a list of
tuples [(KEYWORD_1, VALUE_1, COMMENT_1), (KEYWORD_2,
VALUE_2, COMMENT_2), ...]. Standard keywords like SIMPLE,
BITPIX, NAXIS, EXTEND does not have to be passed.</li>
<li><span class="target" id="orb.utils.io.write_fits.params.silent"></span><strong>silent</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.write_fits.params.silent">¶</a> &#8211; (Optional) If True turn this function won&#8217;t
display any message (default False)</li>
<li><span class="target" id="orb.utils.io.write_fits.params.overwrite"></span><strong>overwrite</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.write_fits.params.overwrite">¶</a> &#8211; (Optional) If True overwrite the output file
if it exists (default False).</li>
<li><span class="target" id="orb.utils.io.write_fits.params.mask"></span><strong>mask</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.write_fits.params.mask">¶</a> &#8211; (Optional) It not None must be an array with the
same size as the given data but filled with ones and
zeros. Bad values (NaN or Inf) are converted to 1 and the
array is converted to 8 bit unsigned integers (uint8). This
array will be written to the disk with the same path
terminated by &#8216;_mask&#8217;. The header of the mask FITS file will
be the same as the original data (default None).</li>
<li><span class="target" id="orb.utils.io.write_fits.params.replace"></span><strong>replace</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.write_fits.params.replace">¶</a> &#8211; (Optional) If True and if the file already
exist, new data replace old data in the existing file. NaN
values do not replace old values. Other values replace old
values. New array MUST have the same size as the existing
array. Note that if replace is True, overwrite is
automatically set to True.</li>
<li><span class="target" id="orb.utils.io.write_fits.params.record_stats"></span><strong>record_stats</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.write_fits.params.record_stats">¶</a> &#8211; (Optional) If True, record mean and
median of data. Useful if they often have to be computed
(default False).</li>
<li><span class="target" id="orb.utils.io.write_fits.params.mask_path"></span><strong>mask_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.io.write_fits.params.mask_path">¶</a> &#8211; (Optional) Path to the corresponding mask image.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">float64 data is converted to float32 data to avoid
too big files with unnecessary precision</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please refer to
<a class="reference external" href="http://www.stsci.edu/institute/software_hardware/pyfits/">http://www.stsci.edu/institute/software_hardware/pyfits/</a> for
more information on PyFITS module and
<a class="reference external" href="http://fits.gsfc.nasa.gov/">http://fits.gsfc.nasa.gov/</a> for more information on FITS
files.</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.misc">
<span id="miscellaneous"></span><h2><a class="toc-backref" href="#id11">Miscellaneous</a><a class="headerlink" href="#module-orb.utils.misc" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.misc.compute_obs_params">
<code class="descclassname">orb.utils.misc.</code><code class="descname">compute_obs_params</code><span class="sig-paren">(</span><em>nm_min_filter</em>, <em>nm_max_filter</em>, <em>theta_min=5.01</em>, <em>theta_max=11.28</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.compute_obs_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute observation parameters (order, step size) given the
filter bandpass.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="orb.utils.misc.compute_obs_params.params.nm_min_filter"></span><strong>nm_min_filter</strong><a class="paramlink headerlink reference internal" href="#orb.utils.misc.compute_obs_params.params.nm_min_filter">¶</a> &#8211; Min wavelength of the filter in nm.</li>
<li><span class="target" id="orb.utils.misc.compute_obs_params.params.nm_max_filter"></span><strong>nm_max_filter</strong><a class="paramlink headerlink reference internal" href="#orb.utils.misc.compute_obs_params.params.nm_max_filter">¶</a> &#8211; Max wavelength of the filter in nm.</li>
<li><span class="target" id="orb.utils.misc.compute_obs_params.params.theta_min"></span><strong>theta_min</strong><a class="paramlink headerlink reference internal" href="#orb.utils.misc.compute_obs_params.params.theta_min">¶</a> &#8211; (Optional) Min angle of the detector (default
5.01).</li>
<li><span class="target" id="orb.utils.misc.compute_obs_params.params.theta_max"></span><strong>theta_max</strong><a class="paramlink headerlink reference internal" href="#orb.utils.misc.compute_obs_params.params.theta_max">¶</a> &#8211; (Optional) Max angle of the detector (default
11.28).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple (order, step size, max wavelength)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.correct_bad_frames_vector">
<code class="descclassname">orb.utils.misc.</code><code class="descname">correct_bad_frames_vector</code><span class="sig-paren">(</span><em>bad_frames_vector</em>, <em>dimz</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.correct_bad_frames_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove bad indexes of the bad frame vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.misc.correct_bad_frames_vector.params.bad_frames_vector"></span><strong>bad_frames_vector</strong><a class="paramlink headerlink reference internal" href="#orb.utils.misc.correct_bad_frames_vector.params.bad_frames_vector">¶</a> &#8211; The vector of indexes to correct</li>
<li><span class="target" id="orb.utils.misc.correct_bad_frames_vector.params.dimz"></span><strong>dimz</strong><a class="paramlink headerlink reference internal" href="#orb.utils.misc.correct_bad_frames_vector.params.dimz">¶</a> &#8211; Dimension of the cube along the 3rd axis.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.get_axis_from_hdr">
<code class="descclassname">orb.utils.misc.</code><code class="descname">get_axis_from_hdr</code><span class="sig-paren">(</span><em>hdr</em>, <em>axis_index=1</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.get_axis_from_hdr" title="Permalink to this definition">¶</a></dt>
<dd><p>Return axis from a classic FITS header</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.misc.get_axis_from_hdr.params.hdr"></span><strong>hdr</strong><a class="paramlink headerlink reference internal" href="#orb.utils.misc.get_axis_from_hdr.params.hdr">¶</a> &#8211; FITS header</li>
<li><span class="target" id="orb.utils.misc.get_axis_from_hdr.params.axis_index"></span><strong>axis_index</strong><a class="paramlink headerlink reference internal" href="#orb.utils.misc.get_axis_from_hdr.params.axis_index">¶</a> &#8211; (Optional) Index of the axis to retrieve
(default 1)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.get_mask_from_ds9_region_file">
<code class="descclassname">orb.utils.misc.</code><code class="descname">get_mask_from_ds9_region_file</code><span class="sig-paren">(</span><em>reg_path</em>, <em>x_range=None</em>, <em>y_range=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.get_mask_from_ds9_region_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the elements inside &#8216;box&#8217;, &#8216;circle&#8217; and
&#8216;polygon&#8217; regions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.misc.get_mask_from_ds9_region_file.params.reg_path"></span><strong>reg_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.misc.get_mask_from_ds9_region_file.params.reg_path">¶</a> &#8211; Path to a ds9 region file</li>
<li><span class="target" id="orb.utils.misc.get_mask_from_ds9_region_file.params.x_range"></span><strong>x_range</strong><a class="paramlink headerlink reference internal" href="#orb.utils.misc.get_mask_from_ds9_region_file.params.x_range">¶</a> &#8211; (Optional) Range of x image coordinates
considered as valid. Pixels outside this range are
rejected. If None, no validation is done (default None).</li>
<li><span class="target" id="orb.utils.misc.get_mask_from_ds9_region_file.params.y_range"></span><strong>y_range</strong><a class="paramlink headerlink reference internal" href="#orb.utils.misc.get_mask_from_ds9_region_file.params.y_range">¶</a> &#8211; (Optional) Range of y image coordinates
considered as valid. Pixels outside this range are
rejected. If None, no validation is done (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned array can be used like a list of
indices returned by e.g. numpy.nonzero().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Coordinates can be image coordinates (x,y) or sky
coordinates in degrees (ra, dec)</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.get_mask_from_ds9_region_line">
<code class="descclassname">orb.utils.misc.</code><code class="descname">get_mask_from_ds9_region_line</code><span class="sig-paren">(</span><em>reg_line</em>, <em>x_range=None</em>, <em>y_range=None</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.get_mask_from_ds9_region_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Read one line of a ds9 region file and return the list of
pixels in the region.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.misc.get_mask_from_ds9_region_line.params.reg_line"></span><strong>reg_line</strong><a class="paramlink headerlink reference internal" href="#orb.utils.misc.get_mask_from_ds9_region_line.params.reg_line">¶</a> &#8211; Line of the ds9 region file</li>
<li><span class="target" id="orb.utils.misc.get_mask_from_ds9_region_line.params.x_range"></span><strong>x_range</strong><a class="paramlink headerlink reference internal" href="#orb.utils.misc.get_mask_from_ds9_region_line.params.x_range">¶</a> &#8211; (Optional) Range of x image coordinates
considered as valid. Pixels outside this range are
rejected. If None, no validation is done (default None).</li>
<li><span class="target" id="orb.utils.misc.get_mask_from_ds9_region_line.params.y_range"></span><strong>y_range</strong><a class="paramlink headerlink reference internal" href="#orb.utils.misc.get_mask_from_ds9_region_line.params.y_range">¶</a> &#8211; (Optional) Range of y image coordinates
considered as valid. Pixels outside this range are
rejected. If None, no validation is done (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned array can be used like a list of
indices returned by e.g. numpy.nonzero().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Coordinates can be image coordinates (x,y) or sky
coordinates in degrees (ra, dec)</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.misc.restore_error_settings">
<code class="descclassname">orb.utils.misc.</code><code class="descname">restore_error_settings</code><span class="sig-paren">(</span><em>old_settings</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.misc.restore_error_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore old floating point error settings of numpy.</p>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.parallel">
<span id="parallel"></span><h2><a class="toc-backref" href="#id12">Parallel</a><a class="headerlink" href="#module-orb.utils.parallel" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.parallel.close_pp_server">
<code class="descclassname">orb.utils.parallel.</code><code class="descname">close_pp_server</code><span class="sig-paren">(</span><em>js</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.close_pp_server" title="Permalink to this definition">¶</a></dt>
<dd><p>Destroy the parallel python job server to avoid too much
opened files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.parallel.close_pp_server.params.js"></span><strong>js</strong><a class="paramlink headerlink reference internal" href="#orb.utils.parallel.close_pp_server.params.js">¶</a> &#8211; job server.</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please refer to <a class="reference external" href="http://www.parallelpython.com/">http://www.parallelpython.com/</a> for
sources and information on Parallel Python software.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.parallel.init_pp_server">
<code class="descclassname">orb.utils.parallel.</code><code class="descname">init_pp_server</code><span class="sig-paren">(</span><em>ncpus=0</em>, <em>silent=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.parallel.init_pp_server" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize a server for parallel processing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.parallel.init_pp_server.params.ncpus"></span><strong>ncpus</strong><a class="paramlink headerlink reference internal" href="#orb.utils.parallel.init_pp_server.params.ncpus">¶</a> &#8211; (Optional) Number of cpus to use. 0 means use all
available cpus (default 0)</li>
<li><span class="target" id="orb.utils.parallel.init_pp_server.params.silent"></span><strong>silent</strong><a class="paramlink headerlink reference internal" href="#orb.utils.parallel.init_pp_server.params.silent">¶</a> &#8211; (Optional) If silent no message is printed
(Default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please refer to <a class="reference external" href="http://www.parallelpython.com/">http://www.parallelpython.com/</a> for
sources and information on Parallel Python software</p>
</div>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.photometry">
<span id="photometry"></span><h2><a class="toc-backref" href="#id13">Photometry</a><a class="headerlink" href="#module-orb.utils.photometry" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.photometry.ABmag2flambda">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">ABmag2flambda</code><span class="sig-paren">(</span><em>ABmag</em>, <em>lam</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.ABmag2flambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert AB magnitude to flux in erg/cm2/s/A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.photometry.ABmag2flambda.params.ABmag"></span><strong>ABmag</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.ABmag2flambda.params.ABmag">¶</a> &#8211; A magnitude in the AB magnitude system</li>
<li><span class="target" id="orb.utils.photometry.ABmag2flambda.params.lam"></span><strong>lam</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.ABmag2flambda.params.lam">¶</a> &#8211; Wavelength in angstrom</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.ABmag2fnu">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">ABmag2fnu</code><span class="sig-paren">(</span><em>ABmag</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.ABmag2fnu" title="Permalink to this definition">¶</a></dt>
<dd><p>Return flux in erg/cm2/s/Hz from AB magnitude (Oke, ApJS, 27,
21, 1974)</p>
<p>ABmag = -2.5 * log10(f_nu) - 48.60
f_nu = 10^(-0.4 * (ABmag + 48.60))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.photometry.ABmag2fnu.params.ABmag"></span><strong>ABmag</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.ABmag2fnu.params.ABmag">¶</a> &#8211; A magnitude in the AB magnitude system</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Definition of the zero-point can change and be
e.g. 48.59 for Oke standard stars (Hamuy et al., PASP, 104, 533,
1992). This is the case for Spectrophotometric Standards given
on the ESO website (<a class="reference external" href="https://www.eso.org/sci/observing/tools/standards/spectra/okestandards.html">https://www.eso.org/sci/observing/tools/standards/spectra/okestandards.html</a>). Here the HST definition is used.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_equivalent_bandwidth">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_equivalent_bandwidth</code><span class="sig-paren">(</span><em>nm_axis</em>, <em>filter_transmission</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_equivalent_bandwidth" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the equivalent bandwidth of a given filter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.photometry.compute_equivalent_bandwidth.params.nm_axis"></span><strong>nm_axis</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_equivalent_bandwidth.params.nm_axis">¶</a> &#8211; Filter transmission axis in nm.</li>
<li><span class="target" id="orb.utils.photometry.compute_equivalent_bandwidth.params.filter_transmission"></span><strong>filter_transmission</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_equivalent_bandwidth.params.filter_transmission">¶</a> &#8211; Filter transmission curve</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_mean_photon_energy">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_mean_photon_energy</code><span class="sig-paren">(</span><em>nm_axis</em>, <em>filter_transmission</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_mean_photon_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mean energy of the photons passing thourgh a given
filter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.photometry.compute_mean_photon_energy.params.nm_axis"></span><strong>nm_axis</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_mean_photon_energy.params.nm_axis">¶</a> &#8211; Filter transmission axis in nm.</li>
<li><span class="target" id="orb.utils.photometry.compute_mean_photon_energy.params.filter_transmission"></span><strong>filter_transmission</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_mean_photon_energy.params.filter_transmission">¶</a> &#8211; Filter transmission curve</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_mean_star_flux">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_mean_star_flux</code><span class="sig-paren">(</span><em>star_spectrum</em>, <em>filter_transmission</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_mean_star_flux" title="Permalink to this definition">¶</a></dt>
<dd><p>Return mean star flux given a spectrum and the filter. Both
files must be given along the same wavelength/wavenumber axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.photometry.compute_mean_star_flux.params.star_spectrum"></span><strong>star_spectrum</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_mean_star_flux.params.star_spectrum">¶</a> &#8211; Spectrum of the star</li>
<li><span class="target" id="orb.utils.photometry.compute_mean_star_flux.params.filter_transmission"></span><strong>filter_transmission</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_mean_star_flux.params.filter_transmission">¶</a> &#8211; Filter transmission curve</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_optimal_texp">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_optimal_texp</code><span class="sig-paren">(</span><em>star_flux</em>, <em>seeing</em>, <em>plate_scale</em>, <em>saturation=30000</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_optimal_texp" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the optimal exposure time given the total flux of the
star in ADU/s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.photometry.compute_optimal_texp.params.star_flux"></span><strong>star_flux</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_optimal_texp.params.star_flux">¶</a> &#8211; Total star flux in ADU/s</li>
<li><span class="target" id="orb.utils.photometry.compute_optimal_texp.params.seeing"></span><strong>seeing</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_optimal_texp.params.seeing">¶</a> &#8211; Star FWHM in arcsec</li>
<li><span class="target" id="orb.utils.photometry.compute_optimal_texp.params.plate_scale"></span><strong>plate_scale</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_optimal_texp.params.plate_scale">¶</a> &#8211; Size of 1 pixel in arcsec.</li>
<li><span class="target" id="orb.utils.photometry.compute_optimal_texp.params.saturation"></span><strong>saturation</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_optimal_texp.params.saturation">¶</a> &#8211; (Optional) Saturation value (default 30000).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_photon_energy">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_photon_energy</code><span class="sig-paren">(</span><em>nm_axis</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_photon_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the photon energy computed for all the wavelength along
a given wavelength axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.photometry.compute_photon_energy.params.nm_axis"></span><strong>nm_axis</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_photon_energy.params.nm_axis">¶</a> &#8211; Wavelength axis in nm</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_star_central_pixel_value">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_star_central_pixel_value</code><span class="sig-paren">(</span><em>seeing</em>, <em>plate_scale</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_star_central_pixel_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the relative value of the pixel containing the greatest
proportion of the flux (central pixel) of Gaussian star.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.photometry.compute_star_central_pixel_value.params.seeing"></span><strong>seeing</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_star_central_pixel_value.params.seeing">¶</a> &#8211; Star FWHM in arcsec</li>
<li><span class="target" id="orb.utils.photometry.compute_star_central_pixel_value.params.plate_scale"></span><strong>plate_scale</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_star_central_pixel_value.params.plate_scale">¶</a> &#8211; Size of the pixels in arcsec.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.compute_star_flux_in_frame">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">compute_star_flux_in_frame</code><span class="sig-paren">(</span><em>nm_axis</em>, <em>star_flux</em>, <em>filter_trans</em>, <em>optics_trans</em>, <em>atm_trans</em>, <em>mirror_trans</em>, <em>qe</em>, <em>mirror_surface</em>, <em>ccd_gain</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.compute_star_flux_in_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the estimation of the flux of a star in counts/s in one image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.photometry.compute_star_flux_in_frame.params.nm_axis"></span><strong>nm_axis</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_star_flux_in_frame.params.nm_axis">¶</a> &#8211; Wavelentgh axis in nm</li>
<li><span class="target" id="orb.utils.photometry.compute_star_flux_in_frame.params.star_flux"></span><strong>star_flux</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_star_flux_in_frame.params.star_flux">¶</a> &#8211; Star flux curve in ergs/cm2/s/A</li>
<li><span class="target" id="orb.utils.photometry.compute_star_flux_in_frame.params.filter_trans"></span><strong>filter_trans</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_star_flux_in_frame.params.filter_trans">¶</a> &#8211; Transmission curve of the filter</li>
<li><span class="target" id="orb.utils.photometry.compute_star_flux_in_frame.params.optics_trans"></span><strong>optics_trans</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_star_flux_in_frame.params.optics_trans">¶</a> &#8211; Transmission of the optics</li>
<li><span class="target" id="orb.utils.photometry.compute_star_flux_in_frame.params.atm_trans"></span><strong>atm_trans</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_star_flux_in_frame.params.atm_trans">¶</a> &#8211; Transmission of the atmosphere</li>
<li><span class="target" id="orb.utils.photometry.compute_star_flux_in_frame.params.qe"></span><strong>qe</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_star_flux_in_frame.params.qe">¶</a> &#8211; Quantum Efficiency curve of the detector</li>
<li><span class="target" id="orb.utils.photometry.compute_star_flux_in_frame.params.mirror_surface"></span><strong>mirror_surface</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_star_flux_in_frame.params.mirror_surface">¶</a> &#8211; Surface of the primary mirror in cm2</li>
<li><span class="target" id="orb.utils.photometry.compute_star_flux_in_frame.params.ccd_gain"></span><strong>ccd_gain</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.compute_star_flux_in_frame.params.ccd_gain">¶</a> &#8211; Gain of the detector.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.fit_std_spectrum">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">fit_std_spectrum</code><span class="sig-paren">(</span><em>real_spectrum</em>, <em>std_spectrum</em>, <em>polydeg=2</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.fit_std_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a real spectrum multiplied by a polynomial over a standard
spectrum.</p>
<p>Return the polynomial which can be used directly as a calibration
curve.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.photometry.fit_std_spectrum.params.real_spectrum"></span><strong>real_spectrum</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.fit_std_spectrum.params.real_spectrum">¶</a> &#8211; Observed spectrum</li>
<li><span class="target" id="orb.utils.photometry.fit_std_spectrum.params.std_spectrum"></span><strong>std_spectrum</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.fit_std_spectrum.params.std_spectrum">¶</a> &#8211; Standard spectrum</li>
<li><span class="target" id="orb.utils.photometry.fit_std_spectrum.params.polydeg"></span><strong>polydeg</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.fit_std_spectrum.params.polydeg">¶</a> &#8211; Degree of the polynomial</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.flambda2ABmag">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">flambda2ABmag</code><span class="sig-paren">(</span><em>flambda</em>, <em>lam</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.flambda2ABmag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return AB magnitude from flux in erg/cm2/s/A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.photometry.flambda2ABmag.params.flambda"></span><strong>flambda</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.flambda2ABmag.params.flambda">¶</a> &#8211; Flux in erg/cm2/s/A. Can be an array.</li>
<li><span class="target" id="orb.utils.photometry.flambda2ABmag.params.lambda"></span><strong>lambda</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.flambda2ABmag.params.lambda">¶</a> &#8211; Wavelength in A of the Flux. If flambda is an array
lambda must have the same shape.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.fnu2flambda">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">fnu2flambda</code><span class="sig-paren">(</span><em>fnu</em>, <em>nu</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.fnu2flambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a flux in erg/cm2/s/Hz to a flux in erg/cm2/s/A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.photometry.fnu2flambda.params.fnu"></span><strong>fnu</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.fnu2flambda.params.fnu">¶</a> &#8211; Flux in erg/cm2/s/Hz</li>
<li><span class="target" id="orb.utils.photometry.fnu2flambda.params.nu"></span><strong>nu</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.fnu2flambda.params.nu">¶</a> &#8211; frequency in Hz</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.get_atmospheric_extinction">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">get_atmospheric_extinction</code><span class="sig-paren">(</span><em>file_path</em>, <em>step</em>, <em>order</em>, <em>step_nb</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.get_atmospheric_extinction" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the atmospheric extinction curve in mag/airmass in the
range defined by the observation parameters along a reference nm
axis (on the interferometer optical axis).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.photometry.get_atmospheric_extinction.params.file_path"></span><strong>file_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_atmospheric_extinction.params.file_path">¶</a> &#8211; Path to the file</li>
<li><span class="target" id="orb.utils.photometry.get_atmospheric_extinction.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_atmospheric_extinction.params.step">¶</a> &#8211; Step size in nm</li>
<li><span class="target" id="orb.utils.photometry.get_atmospheric_extinction.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_atmospheric_extinction.params.order">¶</a> &#8211; Folding order</li>
<li><span class="target" id="orb.utils.photometry.get_atmospheric_extinction.params.step_nb"></span><strong>step_nb</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_atmospheric_extinction.params.step_nb">¶</a> &#8211; Number of step along the nm axis.</li>
<li><span class="target" id="orb.utils.photometry.get_atmospheric_extinction.params.corr"></span><strong>corr</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_atmospheric_extinction.params.corr">¶</a> &#8211; (Optional) Correction coefficient related to the
incident angle (default 1).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.get_atmospheric_transmission">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">get_atmospheric_transmission</code><span class="sig-paren">(</span><em>file_path</em>, <em>step</em>, <em>order</em>, <em>step_nb</em>, <em>airmass=1</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.get_atmospheric_transmission" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the atmospheric transmission curve at a given airmass
in the range defined by the observation parameters along a
reference nm axis (on the interferometer optical axis).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.photometry.get_atmospheric_transmission.params.file_path"></span><strong>file_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_atmospheric_transmission.params.file_path">¶</a> &#8211; Path to the file</li>
<li><span class="target" id="orb.utils.photometry.get_atmospheric_transmission.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_atmospheric_transmission.params.step">¶</a> &#8211; Step size in nm</li>
<li><span class="target" id="orb.utils.photometry.get_atmospheric_transmission.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_atmospheric_transmission.params.order">¶</a> &#8211; Folding order</li>
<li><span class="target" id="orb.utils.photometry.get_atmospheric_transmission.params.step_nb"></span><strong>step_nb</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_atmospheric_transmission.params.step_nb">¶</a> &#8211; Number of step along the nm axis.</li>
<li><span class="target" id="orb.utils.photometry.get_atmospheric_transmission.params.airmass"></span><strong>airmass</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_atmospheric_transmission.params.airmass">¶</a> &#8211; (Optional) Airmass (default 1)</li>
<li><span class="target" id="orb.utils.photometry.get_atmospheric_transmission.params.corr"></span><strong>corr</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_atmospheric_transmission.params.corr">¶</a> &#8211; (Optional) Correction coefficient related to the
incident angle (default 1).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.get_mirror_transmission">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">get_mirror_transmission</code><span class="sig-paren">(</span><em>file_path</em>, <em>step</em>, <em>order</em>, <em>step_nb</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.get_mirror_transmission" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mirror transmission curve in mag/airmass in the
range defined by the observation parameters along a reference nm
axis (on the interferometer optical axis).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.photometry.get_mirror_transmission.params.file_path"></span><strong>file_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_mirror_transmission.params.file_path">¶</a> &#8211; Path to the file</li>
<li><span class="target" id="orb.utils.photometry.get_mirror_transmission.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_mirror_transmission.params.step">¶</a> &#8211; Step size in nm</li>
<li><span class="target" id="orb.utils.photometry.get_mirror_transmission.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_mirror_transmission.params.order">¶</a> &#8211; Folding order</li>
<li><span class="target" id="orb.utils.photometry.get_mirror_transmission.params.step_nb"></span><strong>step_nb</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_mirror_transmission.params.step_nb">¶</a> &#8211; Number of step along the nm axis.</li>
<li><span class="target" id="orb.utils.photometry.get_mirror_transmission.params.corr"></span><strong>corr</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_mirror_transmission.params.corr">¶</a> &#8211; (Optional) Correction coefficient related to the
incident angle (default 1).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.get_optics_transmission">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">get_optics_transmission</code><span class="sig-paren">(</span><em>file_path</em>, <em>step</em>, <em>order</em>, <em>step_nb</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.get_optics_transmission" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the optics transmission curve in mag/airmass in the
range defined by the observation parameters along a reference nm
axis (on the interferometer optical axis).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.photometry.get_optics_transmission.params.file_path"></span><strong>file_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_optics_transmission.params.file_path">¶</a> &#8211; Path to the file</li>
<li><span class="target" id="orb.utils.photometry.get_optics_transmission.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_optics_transmission.params.step">¶</a> &#8211; Step size in nm</li>
<li><span class="target" id="orb.utils.photometry.get_optics_transmission.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_optics_transmission.params.order">¶</a> &#8211; Folding order</li>
<li><span class="target" id="orb.utils.photometry.get_optics_transmission.params.step_nb"></span><strong>step_nb</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_optics_transmission.params.step_nb">¶</a> &#8211; Number of step along the nm axis.</li>
<li><span class="target" id="orb.utils.photometry.get_optics_transmission.params.corr"></span><strong>corr</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_optics_transmission.params.corr">¶</a> &#8211; (Optional) Correction coefficient related to the
incident angle (default 1).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.get_quantum_efficiency">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">get_quantum_efficiency</code><span class="sig-paren">(</span><em>file_path</em>, <em>step</em>, <em>order</em>, <em>step_nb</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.get_quantum_efficiency" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the quantum efficiency curve in the range defined by the
observation parameters along a reference nm axis (on the
interferometer optical axis).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.photometry.get_quantum_efficiency.params.file_path"></span><strong>file_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_quantum_efficiency.params.file_path">¶</a> &#8211; Path to the file</li>
<li><span class="target" id="orb.utils.photometry.get_quantum_efficiency.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_quantum_efficiency.params.step">¶</a> &#8211; Step size in nm</li>
<li><span class="target" id="orb.utils.photometry.get_quantum_efficiency.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_quantum_efficiency.params.order">¶</a> &#8211; Folding order</li>
<li><span class="target" id="orb.utils.photometry.get_quantum_efficiency.params.step_nb"></span><strong>step_nb</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_quantum_efficiency.params.step_nb">¶</a> &#8211; Number of step along the nm axis.</li>
<li><span class="target" id="orb.utils.photometry.get_quantum_efficiency.params.corr"></span><strong>corr</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.get_quantum_efficiency.params.corr">¶</a> &#8211; (Optional) Correction coefficient related to the
incident angle (default 1).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.lambda2nu">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">lambda2nu</code><span class="sig-paren">(</span><em>lam</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.lambda2nu" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert lambda in Ang to nu in Hz</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.photometry.lambda2nu.params.lam"></span><strong>lam</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.lambda2nu.params.lam">¶</a> &#8211; Wavelength in angstrom</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.read_atmospheric_extinction_file">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">read_atmospheric_extinction_file</code><span class="sig-paren">(</span><em>file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.read_atmospheric_extinction_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read atmospheric extinction file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.photometry.read_atmospheric_extinction_file.params.file_path"></span><strong>file_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.read_atmospheric_extinction_file.params.file_path">¶</a> &#8211; Path to the atmospheric extinction file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a tuple (axis [in nm], atmospheric extinction in
[mag/airmass])</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.read_mirror_transmission_file">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">read_mirror_transmission_file</code><span class="sig-paren">(</span><em>file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.read_mirror_transmission_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read mirror transmission file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.photometry.read_mirror_transmission_file.params.file_path"></span><strong>file_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.read_mirror_transmission_file.params.file_path">¶</a> &#8211; Path to the file</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a tuple (axis [in nm], Mirror transmission (from 0 to 1))</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.read_optics_file">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">read_optics_file</code><span class="sig-paren">(</span><em>optics_file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.read_optics_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a file containing the optics transmission function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.photometry.read_optics_file.params.optics_file_path"></span><strong>optics_file_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.read_optics_file.params.optics_file_path">¶</a> &#8211; Path to the optics file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">(wavelength, transmission coefficients)</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The optics file used must have two colums separated by a
space character. The first column contains the wavelength axis
in nm. The second column contains the transmission
coefficients. Comments are preceded with a #.</p>
<blockquote class="last">
<div>## ORBS optics file 
# Author: Thomas Martin &lt;<a class="reference external" href="mailto:thomas&#46;martin&#46;1&#37;&#52;&#48;ulaval&#46;ca">thomas<span>&#46;</span>martin<span>&#46;</span>1<span>&#64;</span>ulaval<span>&#46;</span>ca</a>&gt;
# Filter name : SpIOMM_R
# Wavelength in nm | Transmission percentage
1000 0.001201585284
999.7999878 0.009733387269
999.5999756 -0.0004460749624
999.4000244 0.01378122438
999.2000122 0.002538740868</div></blockquote>
</div>
</dd></dl>

<dl class="function">
<dt id="orb.utils.photometry.read_quantum_efficiency_file">
<code class="descclassname">orb.utils.photometry.</code><code class="descname">read_quantum_efficiency_file</code><span class="sig-paren">(</span><em>file_path</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.photometry.read_quantum_efficiency_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read quantum efficiency file</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.photometry.read_quantum_efficiency_file.params.file_path"></span><strong>file_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.photometry.read_quantum_efficiency_file.params.file_path">¶</a> &#8211; Path to the file</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a tuple (axis [in nm], quantum efficiency (from 0 to 1))</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.pyneb">
<span id="pyneb"></span><h2><a class="toc-backref" href="#id14">Pyneb</a><a class="headerlink" href="#module-orb.utils.pyneb" title="Permalink to this headline">¶</a></h2>
<p>Utils functions derived from pyNeb.</p>
<p>pyNeb must be installed</p>
<dl class="function">
<dt id="orb.utils.pyneb.create_balmer_table">
<code class="descclassname">orb.utils.pyneb.</code><code class="descname">create_balmer_table</code><span class="sig-paren">(</span><em>tems</em>, <em>dens</em>, <em>table_path='balmer_table.fits'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.pyneb.create_balmer_table" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a table for fast balmer ratio computation.</p>
<p>This table is used directly by <code class="xref py py-meth docutils literal"><span class="pre">pnutils.get_Balmer_ratio()</span></code>.</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.pyneb.get_Balmer_ratio">
<code class="descclassname">orb.utils.pyneb.</code><code class="descname">get_Balmer_ratio</code><span class="sig-paren">(</span><em>tem</em>, <em>den</em>, <em>nu=3</em>, <em>try_fast=True</em>, <em>table_name='balmer_table.fits'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.pyneb.get_Balmer_ratio" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the Balmer ratio of H_nu over Hbeta (nu=4). Return
Halpha/Hbeta ratio by default (if nu is 3).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.pyneb.get_Balmer_ratio.params.tem"></span><strong>tem</strong><a class="paramlink headerlink reference internal" href="#orb.utils.pyneb.get_Balmer_ratio.params.tem">¶</a> &#8211; Temperature in K</li>
<li><span class="target" id="orb.utils.pyneb.get_Balmer_ratio.params.dem"></span><strong>dem</strong><a class="paramlink headerlink reference internal" href="#orb.utils.pyneb.get_Balmer_ratio.params.dem">¶</a> &#8211; density in cm-3</li>
<li><span class="target" id="orb.utils.pyneb.get_Balmer_ratio.params.nu"></span><strong>nu</strong><a class="paramlink headerlink reference internal" href="#orb.utils.pyneb.get_Balmer_ratio.params.nu">¶</a> &#8211; (Optional) Transition number, must be &gt;= 3. nu=3 is
Halpha, nu=4 is Hbeta ... (default 3)</li>
<li><span class="target" id="orb.utils.pyneb.get_Balmer_ratio.params.try_fast"></span><strong>try_fast</strong><a class="paramlink headerlink reference internal" href="#orb.utils.pyneb.get_Balmer_ratio.params.try_fast">¶</a> &#8211; (Optional) If True, use a table to get the ratio
instead of computing it. If the value is not in the table or if
the table does not exist the computation use PyNeb function. The
table can be created with <code class="xref py py-meth docutils literal"><span class="pre">pnutils.create_balmer_table()</span></code>.</li>
<li><span class="target" id="orb.utils.pyneb.get_Balmer_ratio.params.table_path"></span><strong>table_path</strong><a class="paramlink headerlink reference internal" href="#orb.utils.pyneb.get_Balmer_ratio.params.table_path">¶</a> &#8211; (Optional) Name of the table file. Must be in
ORB data folder.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.pyneb.get_cHbeta">
<code class="descclassname">orb.utils.pyneb.</code><code class="descname">get_cHbeta</code><span class="sig-paren">(</span><em>ha</em>, <em>hb</em>, <em>tem=10000.0</em>, <em>den=1000.0</em>, <em>ext_law='CCM 89'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.pyneb.get_cHbeta" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the extinction coefficient c(Hbeta) from Halpha / Hbeta
flux.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.pyneb.get_cHbeta.params.ha"></span><strong>ha</strong><a class="paramlink headerlink reference internal" href="#orb.utils.pyneb.get_cHbeta.params.ha">¶</a> &#8211; Flux of Halpha (can be an arbitrary unit as long as it
is the same used for hb)</li>
<li><span class="target" id="orb.utils.pyneb.get_cHbeta.params.hb"></span><strong>hb</strong><a class="paramlink headerlink reference internal" href="#orb.utils.pyneb.get_cHbeta.params.hb">¶</a> &#8211; Flux of Hbeta (can be an arbitrary unit as long as it
is the same used for ha)</li>
<li><span class="target" id="orb.utils.pyneb.get_cHbeta.params.tem"></span><strong>tem</strong><a class="paramlink headerlink reference internal" href="#orb.utils.pyneb.get_cHbeta.params.tem">¶</a> &#8211; (Optional) Temperature in K (default 1e4).</li>
<li><span class="target" id="orb.utils.pyneb.get_cHbeta.params.den"></span><strong>den</strong><a class="paramlink headerlink reference internal" href="#orb.utils.pyneb.get_cHbeta.params.den">¶</a> &#8211; (Optional) Density in cm-3 (default 1e3).</li>
<li><span class="target" id="orb.utils.pyneb.get_cHbeta.params.ext_law"></span><strong>ext_law</strong><a class="paramlink headerlink reference internal" href="#orb.utils.pyneb.get_cHbeta.params.ext_law">¶</a> &#8211; (Optional) Extinction law recongnized by Pyneb
(default &#8216;CCM 89&#8217;).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.spectrum">
<span id="spectrum"></span><h2><a class="toc-backref" href="#id15">Spectrum</a><a class="headerlink" href="#module-orb.utils.spectrum" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.spectrum.cm12nm">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">cm12nm</code><span class="sig-paren">(</span><em>cm1</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.cm12nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavenumber in cm-1 to a wavelength in nm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.spectrum.cm12nm.params.cm1"></span><strong>cm1</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.cm12nm.params.cm1">¶</a> &#8211; wavenumber in cm-1</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.cm12pix">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">cm12pix</code><span class="sig-paren">(</span><em>cm1_axis</em>, <em>cm1</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.cm12pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavenumber in cm-1 to a pixel position given an axis
in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.spectrum.cm12pix.params.cm1_axis"></span><strong>cm1_axis</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.cm12pix.params.cm1_axis">¶</a> &#8211; Axis in cm-1</li>
<li><span class="target" id="orb.utils.spectrum.cm12pix.params.cm1"></span><strong>cm1</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.cm12pix.params.cm1">¶</a> &#8211; Wavenumber in cm-1</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.compute_line_fwhm">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">compute_line_fwhm</code><span class="sig-paren">(</span><em>step_nb</em>, <em>step</em>, <em>order</em>, <em>apod_coeff=1.0</em>, <em>corr=1.0</em>, <em>wavenumber=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_line_fwhm" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expected FWHM (in nm or in cm-1) of a line given the
observation parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.spectrum.compute_line_fwhm.params.step_nb"></span><strong>step_nb</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.compute_line_fwhm.params.step_nb">¶</a> &#8211; Number of steps from the zpd to the longest side
of the interferogram.</li>
<li><span class="target" id="orb.utils.spectrum.compute_line_fwhm.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.compute_line_fwhm.params.step">¶</a> &#8211; Step size in nm</li>
<li><span class="target" id="orb.utils.spectrum.compute_line_fwhm.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.compute_line_fwhm.params.order">¶</a> &#8211; Folding order</li>
<li><span class="target" id="orb.utils.spectrum.compute_line_fwhm.params.apod_coeff"></span><strong>apod_coeff</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.compute_line_fwhm.params.apod_coeff">¶</a> &#8211; (Optional) Apodization coefficient. 1. stands
for no apodization and gives the FWHM of the central lobe of the
sinc (default 1.)</li>
<li><span class="target" id="orb.utils.spectrum.compute_line_fwhm.params.corr"></span><strong>corr</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.compute_line_fwhm.params.corr">¶</a> &#8211; (Optional) Coefficient of correction (default 1.)</li>
<li><span class="target" id="orb.utils.spectrum.compute_line_fwhm.params.wavenumber"></span><strong>wavenumber</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.compute_line_fwhm.params.wavenumber">¶</a> &#8211; (Optional) If True the result is returned in cm-1,
else it is returned in nm.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.compute_line_fwhm_pix">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">compute_line_fwhm_pix</code><span class="sig-paren">(</span><em>step_nb</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_line_fwhm_pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the expected FWHM of an unapodized sinc line in pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.spectrum.compute_line_fwhm_pix.params.step_nb"></span><strong>step_nb</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.compute_line_fwhm_pix.params.step_nb">¶</a> &#8211; Number of steps from the zpd to the longest side
of the interferogram.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.compute_mean_shift">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">compute_mean_shift</code><span class="sig-paren">(</span><em>velocity</em>, <em>step_nb</em>, <em>step</em>, <em>order</em>, <em>wavenumber=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_mean_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean shift at the central wavelength of the band
defined by step and order parameters given its velocity in nm or
in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.spectrum.compute_mean_shift.params.velocity"></span><strong>velocity</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.compute_mean_shift.params.velocity">¶</a> &#8211; Line velocity in km.s-1</li>
<li><span class="target" id="orb.utils.spectrum.compute_mean_shift.params.step_nb"></span><strong>step_nb</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.compute_mean_shift.params.step_nb">¶</a> &#8211; Number of steps</li>
<li><span class="target" id="orb.utils.spectrum.compute_mean_shift.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.compute_mean_shift.params.step">¶</a> &#8211; Step size in nm</li>
<li><span class="target" id="orb.utils.spectrum.compute_mean_shift.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.compute_mean_shift.params.order">¶</a> &#8211; Folding order</li>
<li><span class="target" id="orb.utils.spectrum.compute_mean_shift.params.wavenumber"></span><strong>wavenumber</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.compute_mean_shift.params.wavenumber">¶</a> &#8211; (Optional) If True the result is returned in cm-1,
else it is returned in nm.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.compute_radial_velocity">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">compute_radial_velocity</code><span class="sig-paren">(</span><em>line</em>, <em>rest_line</em>, <em>wavenumber=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.compute_radial_velocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Return radial velocity in km.s-1</p>
<p>V [km.s-1] = c [km.s-1]* (Lambda - Lambda_0) / Lambda_0</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.spectrum.compute_radial_velocity.params.line"></span><strong>line</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.compute_radial_velocity.params.line">¶</a> &#8211; Emission line wavelength/wavenumber (can be a numpy
array)</li>
<li><span class="target" id="orb.utils.spectrum.compute_radial_velocity.params.rest_line"></span><strong>rest_line</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.compute_radial_velocity.params.rest_line">¶</a> &#8211; Rest-frame wavelength/wavenumber (can be a numpy
array but must have the same size as line)</li>
<li><span class="target" id="orb.utils.spectrum.compute_radial_velocity.params.wavenumber"></span><strong>wavenumber</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.compute_radial_velocity.params.wavenumber">¶</a> &#8211; (Optional) If True the result is returned in cm-1,
else it is returned in nm.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.create_cm1_axis">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">create_cm1_axis</code><span class="sig-paren">(</span><em>n</em>, <em>step</em>, <em>order</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.create_cm1_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a regular wavenumber axis in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.spectrum.create_cm1_axis.params.n"></span><strong>n</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.create_cm1_axis.params.n">¶</a> &#8211; Number of steps on the axis</li>
<li><span class="target" id="orb.utils.spectrum.create_cm1_axis.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.create_cm1_axis.params.step">¶</a> &#8211; Step size in nm</li>
<li><span class="target" id="orb.utils.spectrum.create_cm1_axis.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.create_cm1_axis.params.order">¶</a> &#8211; Folding order</li>
<li><span class="target" id="orb.utils.spectrum.create_cm1_axis.params.corr"></span><strong>corr</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.create_cm1_axis.params.corr">¶</a> &#8211; (Optional) Coefficient of correction (default 1.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.create_nm_axis">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">create_nm_axis</code><span class="sig-paren">(</span><em>n</em>, <em>step</em>, <em>order</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.create_nm_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a regular wavelength axis in nm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.spectrum.create_nm_axis.params.n"></span><strong>n</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.create_nm_axis.params.n">¶</a> &#8211; Number of steps on the axis</li>
<li><span class="target" id="orb.utils.spectrum.create_nm_axis.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.create_nm_axis.params.step">¶</a> &#8211; Step size in nm</li>
<li><span class="target" id="orb.utils.spectrum.create_nm_axis.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.create_nm_axis.params.order">¶</a> &#8211; Folding order (cannot be 0)</li>
<li><span class="target" id="orb.utils.spectrum.create_nm_axis.params.corr"></span><strong>corr</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.create_nm_axis.params.corr">¶</a> &#8211; (Optional) Coefficient of correction (default 1.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.create_nm_axis_ireg">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">create_nm_axis_ireg</code><span class="sig-paren">(</span><em>n</em>, <em>step</em>, <em>order</em>, <em>corr=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.create_nm_axis_ireg" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an irregular wavelength axis from the regular wavenumber
axis in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.spectrum.create_nm_axis_ireg.params.n"></span><strong>n</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.create_nm_axis_ireg.params.n">¶</a> &#8211; Number of steps on the axis</li>
<li><span class="target" id="orb.utils.spectrum.create_nm_axis_ireg.params.step"></span><strong>step</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.create_nm_axis_ireg.params.step">¶</a> &#8211; Step size in nm</li>
<li><span class="target" id="orb.utils.spectrum.create_nm_axis_ireg.params.order"></span><strong>order</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.create_nm_axis_ireg.params.order">¶</a> &#8211; Folding order (must be &gt; 0)</li>
<li><span class="target" id="orb.utils.spectrum.create_nm_axis_ireg.params.corr"></span><strong>corr</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.create_nm_axis_ireg.params.corr">¶</a> &#8211; (Optional) Coefficient of correction (default 1.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.fwhm_cm12nm">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">fwhm_cm12nm</code><span class="sig-paren">(</span><em>fwhm_cm1</em>, <em>cm1</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.fwhm_cm12nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a FWHM in cm-1 to a FWHM in nm.</p>
<p>The central wavelength in cm-1 of the line must also be given</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.spectrum.fwhm_cm12nm.params.fwhm_cm1"></span><strong>fwhm_cm1</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.fwhm_cm12nm.params.fwhm_cm1">¶</a> &#8211; FWHM in cm-1</li>
<li><span class="target" id="orb.utils.spectrum.fwhm_cm12nm.params.cm1"></span><strong>cm1</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.fwhm_cm12nm.params.cm1">¶</a> &#8211; Wavelength in cm-1 where the FWHM is evaluated</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.fwhm_nm2cm1">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">fwhm_nm2cm1</code><span class="sig-paren">(</span><em>fwhm_nm</em>, <em>nm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.fwhm_nm2cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a FWHM in nm to a FWHM in cm-1.</p>
<p>The central wavelength in nm of the line must also be given</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.spectrum.fwhm_nm2cm1.params.fwhm_nm"></span><strong>fwhm_nm</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.fwhm_nm2cm1.params.fwhm_nm">¶</a> &#8211; FWHM in nm</li>
<li><span class="target" id="orb.utils.spectrum.fwhm_nm2cm1.params.nm"></span><strong>nm</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.fwhm_nm2cm1.params.nm">¶</a> &#8211; Wavelength in nm where the FWHM is evaluated</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.gaussian1d">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">gaussian1d</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.gaussian1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D gaussian given a set of parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.spectrum.gaussian1d.params.x"></span><strong>x</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.gaussian1d.params.x">¶</a> &#8211; Array giving the positions where the gaussian is evaluated</li>
<li><span class="target" id="orb.utils.spectrum.gaussian1d.params.h"></span><strong>h</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.gaussian1d.params.h">¶</a> &#8211; Height</li>
<li><span class="target" id="orb.utils.spectrum.gaussian1d.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.gaussian1d.params.a">¶</a> &#8211; Amplitude</li>
<li><span class="target" id="orb.utils.spectrum.gaussian1d.params.dx"></span><strong>dx</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.gaussian1d.params.dx">¶</a> &#8211; Position of the center</li>
<li><span class="target" id="orb.utils.spectrum.gaussian1d.params.w"></span><strong>w</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.gaussian1d.params.w">¶</a> &#8211; FWHM, <span class="math">\(\text{FWHM} = \text{Width} \times 2 \sqrt{2 \ln 2}\)</span></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.line_shift">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">line_shift</code><span class="sig-paren">(</span><em>velocity</em>, <em>line</em>, <em>wavenumber=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.line_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the line shift given its velocity in nm or in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.spectrum.line_shift.params.velocity"></span><strong>velocity</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.line_shift.params.velocity">¶</a> &#8211; Line velocity in km.s-1</li>
<li><span class="target" id="orb.utils.spectrum.line_shift.params.line"></span><strong>line</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.line_shift.params.line">¶</a> &#8211; Wavelength/wavenumber of the line. Must be in cm-1 if
wavenumber is True, must be in nm otherwise.</li>
<li><span class="target" id="orb.utils.spectrum.line_shift.params.wavenumber"></span><strong>wavenumber</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.line_shift.params.wavenumber">¶</a> &#8211; (Optional) If True the result is returned in cm-1,
else it is returned in nm.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.lorentzian1d">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">lorentzian1d</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.lorentzian1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D lorentzian
:param _sphinx_paramlinks_orb.utils.spectrum.lorentzian1d.x: Array giving the positions where the function is evaluated
:param _sphinx_paramlinks_orb.utils.spectrum.lorentzian1d.h: Height
:param _sphinx_paramlinks_orb.utils.spectrum.lorentzian1d.a: Amplitude
:param _sphinx_paramlinks_orb.utils.spectrum.lorentzian1d.dx: Position of the center
:param _sphinx_paramlinks_orb.utils.spectrum.lorentzian1d.w: FWHM</p>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.nm2cm1">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">nm2cm1</code><span class="sig-paren">(</span><em>nm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.nm2cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavelength in nm to a wavenumber in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><span class="target" id="orb.utils.spectrum.nm2cm1.params.nm"></span><strong>nm</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.nm2cm1.params.nm">¶</a> &#8211; wavelength in nm</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.nm2pix">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">nm2pix</code><span class="sig-paren">(</span><em>nm_axis</em>, <em>nm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.nm2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavelength in nm to a pixel position given an axis
in nm</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Slow because of interpolation : using
orb.cutils.fast_w2pix is much faster.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.spectrum.nm2pix.params.nm_axis"></span><strong>nm_axis</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.nm2pix.params.nm_axis">¶</a> &#8211; Axis in nm</li>
<li><span class="target" id="orb.utils.spectrum.nm2pix.params.nm"></span><strong>nm</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.nm2pix.params.nm">¶</a> &#8211; Wavelength in nm</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.pix2cm1">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">pix2cm1</code><span class="sig-paren">(</span><em>cm1_axis</em>, <em>pix</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.pix2cm1" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavenumber in cm-1 to a pixel position given an axis
in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.spectrum.pix2cm1.params.cm1_axis"></span><strong>cm1_axis</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.pix2cm1.params.cm1_axis">¶</a> &#8211; Axis in cm-1</li>
<li><span class="target" id="orb.utils.spectrum.pix2cm1.params.pix"></span><strong>pix</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.pix2cm1.params.pix">¶</a> &#8211; Pixel position</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.pix2nm">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">pix2nm</code><span class="sig-paren">(</span><em>nm_axis</em>, <em>pix</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.pix2nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a pixel position to a wavelength in nm given an axis
in nm</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Slow because of interpolation : using
orb.cutils.fast_pix2w is much faster.</p>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.spectrum.pix2nm.params.nm_axis"></span><strong>nm_axis</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.pix2nm.params.nm_axis">¶</a> &#8211; Axis in nm</li>
<li><span class="target" id="orb.utils.spectrum.pix2nm.params.pix"></span><strong>pix</strong><a class="paramlink headerlink reference internal" href="#orb.utils.spectrum.pix2nm.params.pix">¶</a> &#8211; Pixel position</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.spectrum.sinc1d">
<code class="descclassname">orb.utils.spectrum.</code><code class="descname">sinc1d</code><span class="sig-paren">(</span><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.spectrum.sinc1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D sinc 
:param _sphinx_paramlinks_orb.utils.spectrum.sinc1d.x: Array giving the positions where the function is evaluated
:param _sphinx_paramlinks_orb.utils.spectrum.sinc1d.h: Height
:param _sphinx_paramlinks_orb.utils.spectrum.sinc1d.a: Amplitude
:param _sphinx_paramlinks_orb.utils.spectrum.sinc1d.dx: Position of the center
:param _sphinx_paramlinks_orb.utils.spectrum.sinc1d.w: FWHM</p>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.stats">
<span id="stats"></span><h2><a class="toc-backref" href="#id16">Stats</a><a class="headerlink" href="#module-orb.utils.stats" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.stats.robust_mean">
<code class="descclassname">orb.utils.stats.</code><code class="descname">robust_mean</code><span class="sig-paren">(</span><em>a</em>, <em>weights=None</em>, <em>warn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.robust_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean of a distribution even with NaN values</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.stats.robust_mean.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#orb.utils.stats.robust_mean.params.a">¶</a> &#8211; A distribution of values</li>
<li><span class="target" id="orb.utils.stats.robust_mean.params.weights"></span><strong>weights</strong><a class="paramlink headerlink reference internal" href="#orb.utils.stats.robust_mean.params.weights">¶</a> &#8211; Weights of each value of a (Must have the same
length as a). If None, weights are all considered equal to 1
(default None).</li>
<li><span class="target" id="orb.utils.stats.robust_mean.params.warn"></span><strong>warn</strong><a class="paramlink headerlink reference internal" href="#orb.utils.stats.robust_mean.params.warn">¶</a> &#8211; If True, warnings are raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.stats.robust_median">
<code class="descclassname">orb.utils.stats.</code><code class="descname">robust_median</code><span class="sig-paren">(</span><em>a</em>, <em>warn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.robust_median" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median of a distribution (skip NaN values).</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.stats.robust_median.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#orb.utils.stats.robust_median.params.a">¶</a> &#8211; A distribution of values</li>
<li><span class="target" id="orb.utils.stats.robust_median.params.warn"></span><strong>warn</strong><a class="paramlink headerlink reference internal" href="#orb.utils.stats.robust_median.params.warn">¶</a> &#8211; If True, warnings are raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.stats.robust_std">
<code class="descclassname">orb.utils.stats.</code><code class="descname">robust_std</code><span class="sig-paren">(</span><em>a</em>, <em>warn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.robust_std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the std of a distribution even with NaN values</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.stats.robust_std.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#orb.utils.stats.robust_std.params.a">¶</a> &#8211; A distribution of values</li>
<li><span class="target" id="orb.utils.stats.robust_std.params.warn"></span><strong>warn</strong><a class="paramlink headerlink reference internal" href="#orb.utils.stats.robust_std.params.warn">¶</a> &#8211; If True, warnings are raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.stats.robust_sum">
<code class="descclassname">orb.utils.stats.</code><code class="descname">robust_sum</code><span class="sig-paren">(</span><em>a</em>, <em>warn=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.robust_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sum of a distribution (skip NaN values)</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.stats.robust_sum.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#orb.utils.stats.robust_sum.params.a">¶</a> &#8211; A distribution of values</li>
<li><span class="target" id="orb.utils.stats.robust_sum.params.warn"></span><strong>warn</strong><a class="paramlink headerlink reference internal" href="#orb.utils.stats.robust_sum.params.warn">¶</a> &#8211; If True, warnings are raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.stats.sigmacut">
<code class="descclassname">orb.utils.stats.</code><code class="descname">sigmacut</code><span class="sig-paren">(</span><em>x</em>, <em>sigma=3.0</em>, <em>min_values=3</em>, <em>central_value=None</em>, <em>warn=False</em>, <em>return_index_list=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.stats.sigmacut" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a distribution after a sigma cut rejection
of the too deviant values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.stats.sigmacut.params.x"></span><strong>x</strong><a class="paramlink headerlink reference internal" href="#orb.utils.stats.sigmacut.params.x">¶</a> &#8211; The distribution to cut</li>
<li><span class="target" id="orb.utils.stats.sigmacut.params.sigma"></span><strong>sigma</strong><a class="paramlink headerlink reference internal" href="#orb.utils.stats.sigmacut.params.sigma">¶</a> &#8211; (Optional) Number of sigma above which values are
considered as deviant (default 3.)</li>
<li><span class="target" id="orb.utils.stats.sigmacut.params.min_values"></span><strong>min_values</strong><a class="paramlink headerlink reference internal" href="#orb.utils.stats.sigmacut.params.min_values">¶</a> &#8211; (Optional) Minimum number of values to return
(default 3)</li>
<li><span class="target" id="orb.utils.stats.sigmacut.params.central_value"></span><strong>central_value</strong><a class="paramlink headerlink reference internal" href="#orb.utils.stats.sigmacut.params.central_value">¶</a> &#8211; (Optional) If not none, this value is used as
the central value of the cut. Else the median of the
distribution is used as the central value (default None)</li>
<li><span class="target" id="orb.utils.stats.sigmacut.params.warn"></span><strong>warn</strong><a class="paramlink headerlink reference internal" href="#orb.utils.stats.sigmacut.params.warn">¶</a> &#8211; (Optional) If False no warning message is printed
(default False).</li>
<li><span class="target" id="orb.utils.stats.sigmacut.params.return_index_list"></span><strong>return_index_list</strong><a class="paramlink headerlink reference internal" href="#orb.utils.stats.sigmacut.params.return_index_list">¶</a> &#8211; (Optional) If True the list of the non
rejected values is returned also (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.vector">
<span id="vector"></span><h2><a class="toc-backref" href="#id17">Vector</a><a class="headerlink" href="#module-orb.utils.vector" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.vector.correct_vector">
<code class="descclassname">orb.utils.vector.</code><code class="descname">correct_vector</code><span class="sig-paren">(</span><em>vector</em>, <em>bad_value=nan</em>, <em>deg=3</em>, <em>polyfit=False</em>, <em>smoothing=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.correct_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct a given vector for non valid values by interpolation or
polynomial fit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.vector.correct_vector.params.vector"></span><strong>vector</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.correct_vector.params.vector">¶</a> &#8211; The vector to be corrected.</li>
<li><span class="target" id="orb.utils.vector.correct_vector.params.bad_value"></span><strong>bad_value</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.correct_vector.params.bad_value">¶</a> &#8211; (Optional) Bad value to correct (default np.nan)</li>
<li><span class="target" id="orb.utils.vector.correct_vector.params.deg"></span><strong>deg</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.correct_vector.params.deg">¶</a> &#8211; (Optional) Spline degree or polyfit degree (default 3)</li>
<li><span class="target" id="orb.utils.vector.correct_vector.params.polyfit"></span><strong>polyfit</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.correct_vector.params.polyfit">¶</a> &#8211; (Optional) If True non valid values are guessed
using a polynomial fit to the data instead of an spline
interpolation (default False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.vector.fft_filter">
<code class="descclassname">orb.utils.vector.</code><code class="descname">fft_filter</code><span class="sig-paren">(</span><em>a</em>, <em>cutoff_coeff</em>, <em>width_coeff=0.2</em>, <em>filter_type='high_pass'</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.fft_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple lowpass or highpass FFT filter (high pass or low pass)</p>
<p>Filter shape is a gaussian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.vector.fft_filter.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.fft_filter.params.a">¶</a> &#8211; Vector to filter</li>
<li><span class="target" id="orb.utils.vector.fft_filter.params.cutoff_coeff"></span><strong>cutoff_coeff</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.fft_filter.params.cutoff_coeff">¶</a> &#8211; Coefficient defining the position of the cut
frequency (Cut frequency = cut_coeff * vector length)</li>
<li><span class="target" id="orb.utils.vector.fft_filter.params.width_coeff"></span><strong>width_coeff</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.fft_filter.params.width_coeff">¶</a> &#8211; (Optional) Coefficient defining the width of
the smoothed part of the filter (width = width_coeff * vector
length) (default 0.2)</li>
<li><span class="target" id="orb.utils.vector.fft_filter.params.filter_type"></span><strong>filter_type</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.fft_filter.params.filter_type">¶</a> &#8211; (Optional) Type of filter to use. Can be
&#8216;high_pass&#8217; or &#8216;low_pass&#8217;.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.vector.interpolate_axis">
<code class="descclassname">orb.utils.vector.</code><code class="descname">interpolate_axis</code><span class="sig-paren">(</span><em>a</em>, <em>new_axis</em>, <em>deg</em>, <em>old_axis=None</em>, <em>fill_value=nan</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.interpolate_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate a vector along a new axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.vector.interpolate_axis.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.interpolate_axis.params.a">¶</a> &#8211; vector to interpolate</li>
<li><span class="target" id="orb.utils.vector.interpolate_axis.params.new_axis"></span><strong>new_axis</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.interpolate_axis.params.new_axis">¶</a> &#8211; Interpolation axis</li>
<li><span class="target" id="orb.utils.vector.interpolate_axis.params.deg"></span><strong>deg</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.interpolate_axis.params.deg">¶</a> &#8211; Interpolation degree</li>
<li><span class="target" id="orb.utils.vector.interpolate_axis.params.old_axis"></span><strong>old_axis</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.interpolate_axis.params.old_axis">¶</a> &#8211; (Optional) Original vector axis. If None,
a regular range axis is assumed (default None).</li>
<li><span class="target" id="orb.utils.vector.interpolate_axis.params.fill_value"></span><strong>fill_value</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.interpolate_axis.params.fill_value">¶</a> &#8211; (Optional) extrapolated points are filled with
this value (default np.nan)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.vector.interpolate_size">
<code class="descclassname">orb.utils.vector.</code><code class="descname">interpolate_size</code><span class="sig-paren">(</span><em>a</em>, <em>size</em>, <em>deg</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.interpolate_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Change size of a vector by interpolation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.vector.interpolate_size.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.interpolate_size.params.a">¶</a> &#8211; vector to interpolate</li>
<li><span class="target" id="orb.utils.vector.interpolate_size.params.size"></span><strong>size</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.interpolate_size.params.size">¶</a> &#8211; New size of the vector</li>
<li><span class="target" id="orb.utils.vector.interpolate_size.params.deg"></span><strong>deg</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.interpolate_size.params.deg">¶</a> &#8211; Interpolation degree</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.vector.polyfit1d">
<code class="descclassname">orb.utils.vector.</code><code class="descname">polyfit1d</code><span class="sig-paren">(</span><em>a</em>, <em>deg</em>, <em>w=None</em>, <em>return_coeffs=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.polyfit1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a polynomial to a 1D vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.vector.polyfit1d.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.polyfit1d.params.a">¶</a> &#8211; Vector to fit</li>
<li><span class="target" id="orb.utils.vector.polyfit1d.params.deg"></span><strong>deg</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.polyfit1d.params.deg">¶</a> &#8211; Fit degree</li>
<li><span class="target" id="orb.utils.vector.polyfit1d.params.return_coeffs"></span><strong>return_coeffs</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.polyfit1d.params.return_coeffs">¶</a> &#8211; (Optional) If True return fit coefficients
as returned by numpy.polynomial.polynomial.polyfit() (default
False).</li>
<li><span class="target" id="orb.utils.vector.polyfit1d.params.w"></span><strong>w</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.polyfit1d.params.w">¶</a> &#8211; (Optional) If not None, weights to apply to the
fit. Must have the same shape as the vector to fit (default
None)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.vector.smooth">
<code class="descclassname">orb.utils.vector.</code><code class="descname">smooth</code><span class="sig-paren">(</span><em>a</em>, <em>deg=2</em>, <em>kind='gaussian'</em>, <em>keep_sides=True</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.vector.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth a given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="orb.utils.vector.smooth.params.a"></span><strong>a</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.smooth.params.a">¶</a> &#8211; Vector to smooth</li>
<li><span class="target" id="orb.utils.vector.smooth.params.deg"></span><strong>deg</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.smooth.params.deg">¶</a> &#8211; (Optional) Smoothing degree (or kernel
radius) Must be an integer (default 2).</li>
<li><span class="target" id="orb.utils.vector.smooth.params.kind"></span><strong>kind</strong><a class="paramlink headerlink reference internal" href="#orb.utils.vector.smooth.params.kind">¶</a> &#8211; Kind of smoothing function. &#8216;median&#8217; or &#8216;mean&#8217; are
self-explanatory. &#8216;gaussian&#8217; uses a gaussian function for a
weighted average. &#8216;gaussian_conv&#8217; and &#8216;cos_conv&#8217; make use of
convolution with a gaussian kernel or a cosine
kernel. Convolution is much faster but less rigorous on the
edges of the vector (default &#8216;gaussian&#8217;).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Params keep_sides:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">If True, the vector is seen as keeping its
side values above its real boudaries (If False, the values
outside the vector are 0. and this creates an undesirable border
effect when convolving).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-orb.utils.web">
<span id="web"></span><h2><a class="toc-backref" href="#id18">Web</a><a class="headerlink" href="#module-orb.utils.web" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="orb.utils.web.query_sesame">
<code class="descclassname">orb.utils.web.</code><code class="descname">query_sesame</code><span class="sig-paren">(</span><em>object_name</em>, <em>verbose=True</em>, <em>degree=False</em>, <em>pm=False</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.web.query_sesame" title="Permalink to this definition">¶</a></dt>
<dd><p>Query the SESAME Database to get RA/DEC given the name of an
object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><span class="target" id="orb.utils.web.query_sesame.params.object_name"></span><strong>object_name</strong><a class="paramlink headerlink reference internal" href="#orb.utils.web.query_sesame.params.object_name">¶</a> &#8211; Name of the object</li>
<li><span class="target" id="orb.utils.web.query_sesame.params.verbose"></span><strong>verbose</strong><a class="paramlink headerlink reference internal" href="#orb.utils.web.query_sesame.params.verbose">¶</a> &#8211; (Optional) If True print messages (default True)</li>
<li><span class="target" id="orb.utils.web.query_sesame.params.degree"></span><strong>degree</strong><a class="paramlink headerlink reference internal" href="#orb.utils.web.query_sesame.params.degree">¶</a> &#8211; (Optional) If True return RA DEC in degrees
(default False)</li>
<li><span class="target" id="orb.utils.web.query_sesame.params.pm"></span><strong>pm</strong><a class="paramlink headerlink reference internal" href="#orb.utils.web.query_sesame.params.pm">¶</a> &#8211; (Optional) If True proper motion is also returned
(default False)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">[RA, DEC]</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="orb.utils.web.query_vizier">
<code class="descclassname">orb.utils.web.</code><code class="descname">query_vizier</code><span class="sig-paren">(</span><em>radius</em>, <em>target_ra</em>, <em>target_dec</em>, <em>catalog='USNO-B1.0'</em>, <em>max_stars=100</em><span class="sig-paren">)</span><a class="headerlink" href="#orb.utils.web.query_vizier" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a list of star coordinates around an object in a
given radius based on a query to VizieR Services
(<a class="reference external" href="http://vizier.u-strasbg.fr/viz-bin/VizieR">http://vizier.u-strasbg.fr/viz-bin/VizieR</a>)</p>
<p>Note that the idea of this method has been picked from an IDL
function: QUERYVIZIER
(<a class="reference external" href="http://idlastro.gsfc.nasa.gov/ftp/pro/sockets/queryvizier.pro">http://idlastro.gsfc.nasa.gov/ftp/pro/sockets/queryvizier.pro</a>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><span class="target" id="orb.utils.web.query_vizier.params.radius"></span><strong>radius</strong><a class="paramlink headerlink reference internal" href="#orb.utils.web.query_vizier.params.radius">¶</a> &#8211; Radius around the target in arc-minutes.</li>
<li><span class="target" id="orb.utils.web.query_vizier.params.target_ra"></span><strong>target_ra</strong><a class="paramlink headerlink reference internal" href="#orb.utils.web.query_vizier.params.target_ra">¶</a> &#8211; Target RA in degrees</li>
<li><span class="target" id="orb.utils.web.query_vizier.params.target_dec"></span><strong>target_dec</strong><a class="paramlink headerlink reference internal" href="#orb.utils.web.query_vizier.params.target_dec">¶</a> &#8211; Target DEC in degrees</li>
<li><span class="target" id="orb.utils.web.query_vizier.params.catalog"></span><strong>catalog</strong><a class="paramlink headerlink reference internal" href="#orb.utils.web.query_vizier.params.catalog">¶</a> &#8211; (Optional) Catalog to ask on the VizieR
database (see notes) (default &#8216;USNO-B1&#8217;)</li>
<li><span class="target" id="orb.utils.web.query_vizier.params.max_stars"></span><strong>max_stars</strong><a class="paramlink headerlink reference internal" href="#orb.utils.web.query_vizier.params.max_stars">¶</a> &#8211; (Optional) Maximum number of row to retrieve
(default 100)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Some catalogs that can be used::
&#8216;V/139&#8217; - Sloan SDSS photometric catalog Release 9 (2012)
&#8216;2MASS-PSC&#8217; - 2MASS point source catalog (2003)
&#8216;GSC2.3&#8217; - Version 2.3.2 of the HST Guide Star Catalog (2006)
&#8216;USNO-B1&#8217; - Verson B1 of the US Naval Observatory catalog (2003)
&#8216;UCAC4&#8217;  - 4th U.S. Naval Observatory CCD Astrograph Catalog (2012)
&#8216;B/DENIS/DENIS&#8217; - 2nd Deep Near Infrared Survey of southern Sky (2005)
&#8216;I/259/TYC2&#8217; - Tycho-2 main catalog (2000)
&#8216;I/311/HIP2&#8217; - Hipparcos main catalog, new reduction (2007)</p>
</div>
</dd></dl>

</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="cutils_module.html" class="btn btn-neutral float-right" title="CUtils module" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="core_module.html" class="btn btn-neutral" title="Core module" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Thomas Martin (thomas.martin.1@ulaval.ca).

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'2.0-DR1-beta',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>