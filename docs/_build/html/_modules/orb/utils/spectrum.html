<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>orb.utils.spectrum &#8212; orb 3.0.1 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '3.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for orb.utils.spectrum</h1><div class="highlight"><pre>
<span></span>#!/usr/bin/python
# *-* coding: utf-8 *-*
# Author: Thomas Martin &lt;thomas.martin.1@ulaval.ca&gt;
# File: spectrum.py

## Copyright (c) 2010-2016 Thomas Martin &lt;thomas.martin.1@ulaval.ca&gt;
## 
## This file is part of ORB
##
## ORB is free software: you can redistribute it and/or modify it
## under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## ORB is distributed in the hope that it will be useful, but WITHOUT
## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
## or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
## License for more details.
##
## You should have received a copy of the GNU General Public License
## along with ORB.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

import numpy as np
import math
from scipy import interpolate, optimize, special
import warnings
import time

import orb.constants
import orb.cutils
import orb.cgvar

import gvar

<div class="viewcode-block" id="create_nm_axis"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.create_nm_axis">[docs]</a>def create_nm_axis(n, step, order, corr=1.):
    &quot;&quot;&quot;Create a regular wavelength axis in nm.

    :param n: Number of steps on the axis
    
    :param step: Step size in nm
    
    :param order: Folding order (cannot be 0)
    
    :param corr: (Optional) Coefficient of correction (default 1.)
    &quot;&quot;&quot;
    
    nm_min = orb.cutils.get_nm_axis_min(int(n), float(step),
                                        int(order), corr=float(corr))
    if (order &gt; 0): 
        nm_max = orb.cutils.get_nm_axis_max(int(n), float(step),
                                            int(order), corr=float(corr))
        return np.linspace(nm_min, nm_max, n, dtype=np.longdouble)
    else:
        raise Exception(&quot;order must be &gt; 0&quot;)</div>
    
<div class="viewcode-block" id="create_cm1_axis"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.create_cm1_axis">[docs]</a>def create_cm1_axis(n, step, order, corr=1.):
    &quot;&quot;&quot;Create a regular wavenumber axis in cm-1.

    :param n: Number of steps on the axis
    
    :param step: Step size in nm
    
    :param order: Folding order
    
    :param corr: (Optional) Coefficient of correction (default 1.)
    &quot;&quot;&quot;
    cm1_min = orb.cutils.get_cm1_axis_min(int(n), float(step),
                                          int(order), corr=float(corr))
    cm1_max = orb.cutils.get_cm1_axis_max(int(n), float(step),
                                          int(order), corr=float(corr))
    return np.linspace(cm1_min, cm1_max, n, dtype=np.longdouble) </div>
    
    
<div class="viewcode-block" id="create_nm_axis_ireg"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.create_nm_axis_ireg">[docs]</a>def create_nm_axis_ireg(n, step, order, corr=1.):
    &quot;&quot;&quot;Create an irregular wavelength axis from the regular wavenumber
    axis in cm-1.

    :param n: Number of steps on the axis
    
    :param step: Step size in nm
    
    :param order: Folding order (must be &gt; 0)
    
    :param corr: (Optional) Coefficient of correction (default 1.)
    &quot;&quot;&quot;
    if order &gt; 0:
        return (1. / create_cm1_axis(n, step, order, corr=corr) * 1e7)
    else:
        raise Exception(&quot;Order must be &gt; 0&quot;)</div>
        
    
<div class="viewcode-block" id="pix2nm"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.pix2nm">[docs]</a>def pix2nm(nm_axis, pix):
     &quot;&quot;&quot;Convert a pixel position to a wavelength in nm given an axis
     in nm

     .. warning:: Slow because of interpolation : using
       fast_pix2w is much faster.

     :param nm_axis: Axis in nm
     
     :param pix: Pixel position
     &quot;&quot;&quot;  
     f = interpolate.interp1d(np.arange(nm_axis.shape[0]), nm_axis,
                              bounds_error=False, fill_value=np.nan)
     return f(pix)</div>
   

<div class="viewcode-block" id="nm2pix"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.nm2pix">[docs]</a>def nm2pix(nm_axis, nm):
     &quot;&quot;&quot;Convert a wavelength in nm to a pixel position given an axis
     in nm

     .. warning:: Slow because of interpolation : using
       fast_w2pix is much faster.

     :param nm_axis: Axis in nm
     
     :param nm: Wavelength in nm
     &quot;&quot;&quot;
     x = np.arange(nm_axis.shape[0])
     inverted = False
     if nm_axis[0] &gt; nm_axis[-1]:
         nm_axis = np.copy(nm_axis[::-1])
         x = x[::-1]
         inverted = True
     f = interpolate.interp1d(nm_axis, x, bounds_error=False, fill_value=np.nan)
     if not inverted:
         return f(nm)
     else:
         return f(nm)[::-1]</div>

<div class="viewcode-block" id="nm2cm1"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.nm2cm1">[docs]</a>def nm2cm1(nm):
    &quot;&quot;&quot;Convert a wavelength in nm to a wavenumber in cm-1.

    :param nm: wavelength in nm
    &quot;&quot;&quot;
    return 1e7 / np.array(nm).astype(float)</div>

<div class="viewcode-block" id="cm12nm"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.cm12nm">[docs]</a>def cm12nm(cm1):
    &quot;&quot;&quot;Convert a wavenumber in cm-1 to a wavelength in nm.

    :param cm1: wavenumber in cm-1
    &quot;&quot;&quot;
    return 1e7 / np.array(cm1).astype(float)</div>

<div class="viewcode-block" id="pix2cm1"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.pix2cm1">[docs]</a>def pix2cm1(cm1_axis, pix):
     &quot;&quot;&quot;Convert a wavenumber in cm-1 to a pixel position given an axis
     in cm-1.

     :param cm1_axis: Axis in cm-1
     
     :param pix: Pixel position
     &quot;&quot;&quot;
     f = interpolate.interp1d(np.arange(cm1_axis.shape[0]), cm1_axis,
                              bounds_error=False, fill_value=np.nan)

     return f(pix)</div>
 
<div class="viewcode-block" id="cm12pix"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.cm12pix">[docs]</a>def cm12pix(cm1_axis, cm1):
     &quot;&quot;&quot;Convert a wavenumber in cm-1 to a pixel position given an axis
     in cm-1.

     :param cm1_axis: Axis in cm-1
     
     :param cm1: Wavenumber in cm-1
     &quot;&quot;&quot;
     f = interpolate.interp1d(cm1_axis, np.arange(cm1_axis.shape[0]),
                              bounds_error=False, fill_value=np.nan)
     return f(cm1)</div>

<div class="viewcode-block" id="fwhm_nm2cm1"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.fwhm_nm2cm1">[docs]</a>def fwhm_nm2cm1(fwhm_nm, nm):
    &quot;&quot;&quot;Convert a FWHM in nm to a FWHM in cm-1.
    
    The central wavelength in nm of the line must also be given

    :param fwhm_nm: FWHM in nm
    
    :param nm: Wavelength in nm where the FWHM is evaluated
    &quot;&quot;&quot;
    return 1e7 * fwhm_nm / nm**2.</div>

<div class="viewcode-block" id="fwhm_cm12nm"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.fwhm_cm12nm">[docs]</a>def fwhm_cm12nm(fwhm_cm1, cm1):
    &quot;&quot;&quot;Convert a FWHM in cm-1 to a FWHM in nm.
    
    The central wavelength in cm-1 of the line must also be given

    :param fwhm_cm1: FWHM in cm-1
    
    :param cm1: Wavelength in cm-1 where the FWHM is evaluated
    &quot;&quot;&quot;
    return 1e7 * fwhm_cm1 / cm1**2.</div>

<div class="viewcode-block" id="line_shift"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.line_shift">[docs]</a>def line_shift(velocity, line, wavenumber=False):
    &quot;&quot;&quot;Return the line shift given its velocity in nm or in cm-1.

    beta = v / c

    gamma = sqrt((1 + beta) / (1 - beta))

    lambda - lambda_0 = lambda_0  * (gamma - 1)

    :param velocity: Line velocity in km.s-1

    :param line: Wavelength/wavenumber of the line. Must be in cm-1 if
      wavenumber is True, must be in nm otherwise.

    :param wavenumber: (Optional) If True the result is returned in cm-1,
      else it is returned in nm.
    &quot;&quot;&quot;
    beta = velocity / orb.constants.LIGHT_VEL_KMS
    gamma = gvar.sqrt((1. + beta) / (1. - beta))
    if wavenumber: 
        shift = line * (1. / gamma - 1.)
    else:
        shift = line * (gamma - 1.)
    return shift</div>

<div class="viewcode-block" id="compute_line_fwhm"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.compute_line_fwhm">[docs]</a>def compute_line_fwhm(step_nb, step, order, apod_coeff=1., corr=1.,
                      wavenumber=False):
    &quot;&quot;&quot;Return the expected FWHM (in nm or in cm-1) of a line given the
    observation parameters.

    :param step_nb: Number of steps from the zpd to the longest side
      of the interferogram.
    
    :param step: Step size in nm
    
    :param order: Folding order
    
    :param apod_coeff: (Optional) Apodization coefficient. 1. stands
      for no apodization and gives the FWHM of the central lobe of the
      sinc (default 1.)

    :param corr: (Optional) Coefficient of correction (default 1.)
    
    :param wavenumber: (Optional) If True the result is returned in cm-1,
      else it is returned in nm.
    &quot;&quot;&quot;
    opd_max = step_nb * step / corr
    if not wavenumber:
        nm_axis = create_nm_axis(step_nb, step, order)
        nm_mean = (nm_axis[-1] + nm_axis[0])/2.
        return (nm_mean**2. * orb.constants.FWHM_SINC_COEFF
                / (2 * opd_max) * apod_coeff)
    else:
        return orb.constants.FWHM_SINC_COEFF / (2 * opd_max) * apod_coeff * 1e7</div>
        
<div class="viewcode-block" id="compute_line_fwhm_pix"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.compute_line_fwhm_pix">[docs]</a>def compute_line_fwhm_pix(oversampling_ratio=1.):
    &quot;&quot;&quot;Return the expected FWHM of an unapodized sinc line in pixels.

    :oversampling_ratio: Ratio of the real number of steps of the
      spectrum vs step_nb (must be &gt; 1.) For a two sided interferogram
      the oversampling ratio is 2.
    &quot;&quot;&quot;
    return orb.constants.FWHM_SINC_COEFF * oversampling_ratio</div>
    
<div class="viewcode-block" id="compute_mean_shift"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.compute_mean_shift">[docs]</a>def compute_mean_shift(velocity, step_nb, step, order, wavenumber=False):
    &quot;&quot;&quot;Return the mean shift at the central wavelength of the band
    defined by step and order parameters given its velocity in nm or
    in cm-1.

    :param velocity: Line velocity in km.s-1
    
    :param step_nb: Number of steps

    :param step: Step size in nm

    :param order: Folding order

    :param wavenumber: (Optional) If True the result is returned in cm-1,
      else it is returned in nm.
    &quot;&quot;&quot;
    if not wavenumber:
        nm_axis = create_nm_axis(step_nb, step, order)
        mean = (nm_axis[-1] + nm_axis[0])/2.
    else:
        cm1_axis = create_cm1_axis(step_nb, step, order)
        mean = (cm1_axis[-1] + cm1_axis[0])/2.
        
    return line_shift(velocity, mean, wavenumber=wavenumber)</div>
        
<div class="viewcode-block" id="compute_step_nb"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.compute_step_nb">[docs]</a>def compute_step_nb(resolution, step, order):
    &quot;&quot;&quot;Return the number of steps on the longest side of the
    interferogram given the resolution and the observation
    parameters.

    :param resolution: Resolution
    
    :param step: Step size (in nm)
    
    :param order: Folding order
    &quot;&quot;&quot;
    cm1_axis = create_cm1_axis(100, step, order)
    mean_sigma = (cm1_axis[-1] + cm1_axis[0])/2.
    return math.ceil(orb.constants.FWHM_SINC_COEFF
            * resolution
            / (2 * mean_sigma * step * 1e-7))</div>

<div class="viewcode-block" id="compute_resolution"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.compute_resolution">[docs]</a>def compute_resolution(step_nb, step, order, corr):
    &quot;&quot;&quot;Return the theoretical resolution of a given scan

    :param step_nb: Number of steps of the longest side of the
      interferogram.
    
    :param step: Step size (in nm)
    
    :param order: Folding order

    :param corr: Correction coefficient for the incident angle.
    &quot;&quot;&quot;
    fwhm_cm1 = compute_line_fwhm(
        step_nb, step, order, wavenumber=True)
    min_cm1 = orb.cutils.get_cm1_axis_min(step_nb, step, order, corr=corr)
    max_cm1 = orb.cutils.get_cm1_axis_max(step_nb, step, order, corr=corr)
    med_cm1 = (min_cm1 + max_cm1) / 2.
    return med_cm1 / fwhm_cm1</div>

<div class="viewcode-block" id="compute_radial_velocity"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.compute_radial_velocity">[docs]</a>def compute_radial_velocity(line, rest_line, wavenumber=False):
    &quot;&quot;&quot;
    Return radial velocity in km.s-1

    V [km.s-1] = c [km.s-1]* (Lambda^2 / Lambda_0^2 - 1) / (Lambda^2 / Lambda_0^2 + 1)

    :param line: Emission line wavelength/wavenumber (can be a numpy
      array)
    
    :param rest_line: Rest-frame wavelength/wavenumber (can be a numpy
      array but must have the same size as line)

    :param wavenumber: (Optional) If True the result is returned in cm-1,
      else it is returned in nm.
    &quot;&quot;&quot;
    if wavenumber:
        ratio = (rest_line / line)**2.
    else:
        ratio = (line / rest_line)**2.
    return orb.constants.LIGHT_VEL_KMS * (ratio - 1) / (ratio + 1)</div>
    

<div class="viewcode-block" id="lorentzian1d"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.lorentzian1d">[docs]</a>def lorentzian1d(x, h, a, dx, fwhm):
    &quot;&quot;&quot;Return a 1D lorentzian
    :param x: Array giving the positions where the function is evaluated
    :param h: Height
    :param a: Amplitude
    :param dx: Position of the center
    :param fwhm: FWHM
    &quot;&quot;&quot;
    return h + (a / (1. + ((x-dx)/(fwhm/2.))**2.))</div>

<div class="viewcode-block" id="gaussian1d"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.gaussian1d">[docs]</a>def gaussian1d(x,h,a,dx,fwhm):
    &quot;&quot;&quot;Return a 1D gaussian given a set of parameters.

    :param x: Array giving the positions where the gaussian is evaluated
    :param h: Height
    :param a: Amplitude
    :param dx: Position of the center
    :param fwhm: FWHM, :math:`\\text{FWHM} = \\text{Width} \\times 2 \\sqrt{2 \\ln 2}`
    &quot;&quot;&quot;
    if not isinstance(x, np.ndarray):
        x = np.array(x)

    w = fwhm / (2. * gvar.sqrt(2. * gvar.log(2.)))
    return  h + a * gvar.exp(-(x - dx)**2. / (2. * w**2.))</div>

<div class="viewcode-block" id="sinc1d"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.sinc1d">[docs]</a>def sinc1d(x, h, a, dx, fwhm):
    &quot;&quot;&quot;Return a 1D sinc 
    :param x: Array giving the positions where the function is evaluated
    :param h: Height
    :param a: Amplitude
    :param dx: Position of the center
    :param fwhm: FWHM
    &quot;&quot;&quot;
    if not isinstance(x, np.ndarray):
        x = np.array(x)
        
    X = ((x - dx) / (fwhm / 1.20671))
    return h + a * orb.cgvar.sinc1d(X)</div>
                        
<div class="viewcode-block" id="sincgauss1d"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.sincgauss1d">[docs]</a>def sincgauss1d(x, h, a, dx, fwhm, sigma):
    &quot;&quot;&quot;Return a 1D sinc convoluted with a gaussian of parameter sigma.

    If sigma == 0 returns a pure sinc.

    :param x: 1D array of float64 giving the positions where the
      sinc is evaluated
    
    :param h: Height
    :param a: Amplitude
    :param dx: Position of the center
    :param fwhm: FWHM of the sinc
    :param sigma: Sigma of the gaussian.
    &quot;&quot;&quot;
    if np.size(sigma) &gt; 1:
        if np.any(sigma != sigma[0]):
            raise Exception(&#39;Only one value of sigma can be passed&#39;)
        else:
            sigma = sigma[0]
            
    if sigma / fwhm &lt; 1e-5:
        return sinc1d(x, h, a, dx, fwhm)

    if sigma / fwhm &gt; 1e3:
        return gaussian1d(x, h, a, dx, sigma)

    if np.isclose(gvar.mean(sigma), 0.):
        return sinc1d(x, h, a, dx, fwhm)

    width = gvar.fabs(fwhm) / orb.constants.FWHM_SINC_COEFF
    width /= math.pi ###
    
    a_ = sigma / math.sqrt(2) / width
    b_ = (x - dx) / math.sqrt(2) / sigma

    return h + a * orb.cgvar.sincgauss1d(a_, b_)</div>



<div class="viewcode-block" id="sinc1d_complex"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.sinc1d_complex">[docs]</a>def sinc1d_complex(x, h, a, dx, fwhm):
    &quot;&quot;&quot;The &quot;complex&quot; version of the sinc (understood as the Fourier
    Transform of a boxcar function from 0 to MPD).

    This is the real sinc function when ones wants to fit both the real
    part and the imaginary part of the spectrum.

    :param x: 1D array of float64 giving the positions where the
      function is evaluated
    
    :param h: Height
    :param a: Amplitude
    :param dx: Position of the center
    :param fwhm: FWHM of the sinc
    &quot;&quot;&quot;
    width = abs(fwhm) / orb.constants.FWHM_SINC_COEFF
    width /= np.pi
    width /= 2.###
    X = (x-dx) / (2*width)

    s1dc = h + a * (np.sin(X) - 1j * (np.cos(X) - 1)) / (X)
    s1dc[X == 0] = h + a * (1 + 0j)
    return s1dc</div>


<div class="viewcode-block" id="sinc1d_phased"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.sinc1d_phased">[docs]</a>def sinc1d_phased(x, h, a, dx, fwhm, alpha):
    &quot;&quot;&quot;The phased version of the sinc function when that can be used to
    fit a spectrum with a non perfect correction of the order 0 of the
    phase.

    :param x: 1D array of float64 giving the positions where the
      function is evaluated
    
    :param h: Height
    :param a: Amplitude
    :param dx: Position of the center
    :param fwhm: FWHM of the sinc
    :param alpha: Mixing coefficient (in radians).
    &quot;&quot;&quot;
    _sinc = sinc1d_complex(x, h, a, dx, fwhm)
    return _sinc.real * np.cos(alpha) + _sinc.imag * np.sin(alpha)</div>

<div class="viewcode-block" id="sincgauss1d_complex_erf"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.sincgauss1d_complex_erf">[docs]</a>def sincgauss1d_complex_erf(x, h, a, dx, fwhm, sigma):
    &quot;&quot;&quot;The &quot;complex&quot; version of the sincgauss (erf formulation).

    This is the real sinc*gauss function when ones wants to fit both the real
    part and the imaginary part of the spectrum.

    :param x: 1D array of float64 giving the positions where the
      function is evaluated
    
    :param h: Height
    :param a: Amplitude
    :param dx: Position of the center
    :param fwhm: FWHM of the sinc
    :param sigma: Sigma of the gaussian.
    &quot;&quot;&quot;
    width = abs(fwhm) / orb.constants.FWHM_SINC_COEFF
    width /= np.pi ###

    a_ = sigma / np.sqrt(2) / width
    b_ = ((x - dx) / np.sqrt(2) / sigma).astype(float)

    erf1 = special.erf(a_ - 1j*b_)
    erf2 = special.erf(1j*b_)
    erf3 = special.erf(a_)
    
    return np.exp(-b_**2.) * (erf1 + erf2) / (erf3)</div>


<div class="viewcode-block" id="sincgauss1d_complex"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.sincgauss1d_complex">[docs]</a>def sincgauss1d_complex(x, h, a, dx, fwhm, sigma):
    &quot;&quot;&quot;The &quot;complex&quot; version of the sincgauss (dawson definition).

    This is the real sinc*gauss function when ones wants to fit both the real
    part and the imaginary part of the spectrum.

    :param x: 1D array of float64 giving the positions where the
      function is evaluated
    
    :param h: Height
    :param a: Amplitude
    :param dx: Position of the center
    :param fwhm: FWHM of the sinc
    :param sigma: Sigma of the gaussian.
    &quot;&quot;&quot;

    width = abs(fwhm) / orb.constants.FWHM_SINC_COEFF
    width /= np.pi ###
   
    a_ = sigma / np.sqrt(2) / width
    b_ = ((x - dx) / np.sqrt(2) / sigma).astype(float)

    dawson1 = special.dawsn(1j * a_ + b_) * np.exp(2j * a_* b_)
    dawson2 = special.dawsn(b_) * np.exp(a_**2)
    dawson3 = special.dawsn(1j * a_)

    return (dawson1 - dawson2) / dawson3</div>


<div class="viewcode-block" id="sincgauss1d_phased"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.sincgauss1d_phased">[docs]</a>def sincgauss1d_phased(x, h, a, dx, fwhm, sigma, alpha):
    &quot;&quot;&quot;The phased version of the sinc*gauss function when that can be
    used to fit a spectrum with a non perfect correction of the order
    0 of the phase.

    :param x: 1D array of float64 giving the positions where the
      function is evaluated
    
    :param h: Height
    :param a: Amplitude
    :param dx: Position of the center
    :param fwhm: FWHM of the sinc
    :param sigma: Sigma of the gaussian.
    :param alpha: Mixing coefficient (in radians).
    &quot;&quot;&quot;
    sc = sincgauss1d_complex(x, h, a, dx, fwhm, sigma)
    return np.cos(alpha) * sc.real + np.sin(alpha) * sc.imag</div>

<div class="viewcode-block" id="gaussian1d_flux"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.gaussian1d_flux">[docs]</a>def gaussian1d_flux(a, fwhm):
    &quot;&quot;&quot;Compute flux of a 1D Gaussian.

    :param a: Amplitude
    :param fwhm: FWHM
    &quot;&quot;&quot;
    width = fwhm / orb.constants.FWHM_COEFF
    return gvar.fabs(a * math.sqrt(2*math.pi) * width)</div>

<div class="viewcode-block" id="sinc1d_flux"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.sinc1d_flux">[docs]</a>def sinc1d_flux(a, fwhm):
    &quot;&quot;&quot;Compute flux of a 1D sinc.

    :param a: Amplitude
    :param fwhm: FWHM
    &quot;&quot;&quot;
    width = fwhm / orb.constants.FWHM_SINC_COEFF
    return gvar.fabs(a * width)</div>

<div class="viewcode-block" id="sincgauss1d_flux"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.sincgauss1d_flux">[docs]</a>def sincgauss1d_flux(a, fwhm, sigma):
    &quot;&quot;&quot;Compute flux of a 1D sinc convoluted with a Gaussian of
    parameter sigma.

    :param a: Amplitude
    :param fwhm: FWHM of the sinc
    :param sigma: Sigma of the gaussian
    :param no_err: (Optional) No error is returned (default False)
    &quot;&quot;&quot;
    width = fwhm / orb.constants.FWHM_SINC_COEFF
    width /= math.pi

    def compute_flux(ia, isig, iwid):
        idia = orb.cgvar.dawsni(isig / (math.sqrt(2) * iwid))
        expa2 = gvar.exp(isig**2./2./iwid**2.)
        if not np.isclose(gvar.mean(idia),0):
            return ia * math.pi / math.sqrt(2.) * isig * expa2 / idia
        else: return gvar.gvar(np.inf, np.inf)


    try:
        _A = sigma / (np.sqrt(2) * width)
        dia = special.dawsn(1j*_A)
        expa2 = np.exp(_A**2.)
    
        return (a * np.pi / np.sqrt(2.) * 1j * sigma * expa2 / dia).real
    except TypeError: pass

    if isinstance(a, np.ndarray):
        result = np.empty_like(a)
        for i in range(np.size(a)):
            result.flat[i] = compute_flux(
                a.flat[i], sigma.flat[i], width.flat[i])
    else: result = compute_flux(a, sigma, width)
    return result</div>

<div class="viewcode-block" id="fast_w2pix"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.fast_w2pix">[docs]</a>def fast_w2pix(w, axis_min, axis_step):
    &quot;&quot;&quot;Fast conversion of wavelength/wavenumber to pixel

    :param w: wavelength/wavenumber
    
    :param axis_min: min axis wavelength/wavenumber
    
    :param axis_step: axis step size in wavelength/wavenumber
    &quot;&quot;&quot;
    return gvar.fabs(w - axis_min) / axis_step</div>

<div class="viewcode-block" id="fast_pix2w"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.fast_pix2w">[docs]</a>def fast_pix2w(pix, axis_min, axis_step):
    &quot;&quot;&quot;Fast conversion of pixel to wavelength/wavenumber

    :param pix: position along axis in pixels
    
    :param axis_min: min axis wavelength/wavenumber
    
    :param axis_step: axis step size in wavelength/wavenumber
    &quot;&quot;&quot;
    return pix * axis_step + axis_min</div>

<div class="viewcode-block" id="thermal_broadening_kms"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.thermal_broadening_kms">[docs]</a>def thermal_broadening_kms(wl, aw, T):
    &quot;&quot;&quot;
    Return the width of the line due to thermal broadening in km/s.

    Equation can be refered to Harwit (Astrophysical concepts) but his
    definition gives the HWHM (Half-Width at Half-Maximum).
    
    :param wl: Wavelength of the line (in nm)
    :param aw: Atomic weight of the emitting atom
    :param T: Temperature in K
    &quot;&quot;&quot;
    E = aw * orb.constants.ATOMIC_MASS * (orb.constants.LIGHT_VEL_KMS * 1e5) **2.
    width = wl * np.sqrt(orb.constants.K_BOLTZMANN * T / E) # nm
    return orb.constants.LIGHT_VEL_KMS *  width / wl # kms</div>

<div class="viewcode-block" id="phase_shift_cm1_axis"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.phase_shift_cm1_axis">[docs]</a>def phase_shift_cm1_axis(step_nb, step, order, nm_laser_obs, nm_laser):
    &quot;&quot;&quot;Compute phase shift on a given cm1 axis

    :param step_nb: Number of steps
    :param step: Step size in nm
    :param order: Folding order
    :param nm_laser_obs: Observed calibration laser wavelength (in nm)
    :param nm_laser: Calibration laser wavelength (in nm)
    &quot;&quot;&quot;
    corr = nm_laser_obs / nm_laser
    cm1_min_corr = orb.cutils.get_cm1_axis_min(int(step_nb), float(step),
                                               int(order), corr=float(corr))
    cm1_min_base = orb.cutils.get_cm1_axis_min(int(step_nb), float(step),
                                               int(order))
    cm1_axis_step =  orb.cutils.get_cm1_axis_step(int(step_nb),
                                                  float(step),
                                                  corr=float(corr))
    delta_cm1 = cm1_min_corr - cm1_min_base
    delta_x = - (delta_cm1 / cm1_axis_step)
    return delta_x</div>

<div class="viewcode-block" id="guess_snr"><a class="viewcode-back" href="../../../orb.utils.html#orb.utils.spectrum.guess_snr">[docs]</a>def guess_snr(calib_spectrum, flambda, exp_time):
    &quot;&quot;&quot;Guess calibrated spectrum snr

    :param calib_spectrum: Calibrated spectrum

    :param flambda: Calibration FLAMBDA

    :param exp_time: Exposure time by step
    &quot;&quot;&quot;
    int_time = calib_spectrum.shape[0] * exp_time # total integration time in s
    spec_counts = calib_spectrum / flambda * int_time
    noise = np.sqrt(np.nansum(np.sqrt(spec_counts**2)))
    signal = np.nanmax(spec_counts) - np.nanmedian(spec_counts)
    return signal / noise</div>
                       
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Thomas Martin (thomas.martin.1@ulaval.ca).
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.5.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.8</a>
      
    </div>

    

    
  </body>
</html>