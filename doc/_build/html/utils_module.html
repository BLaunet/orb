<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Utils module &mdash; Orb 1.1 documentation</title>
    
    <link rel="stylesheet" href="_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="_static/logo.ico"/>
    <link rel="top" title="Orb 1.1 documentation" href="index.html" />
    <link rel="next" title="CUtils module" href="cutils_module.html" />
    <link rel="prev" title="Core module" href="core_module.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="cutils_module.html" title="CUtils module"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="core_module.html" title="Core module"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Orb 1.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/logo.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="core_module.html"
                        title="previous chapter">Core module</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="cutils_module.html"
                        title="next chapter">CUtils module</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/utils_module.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-utils">
<span id="utils-module"></span><h1>Utils module<a class="headerlink" href="#module-utils" title="Permalink to this headline">¶</a></h1>
<p>Utils module contains functions that are used by the processing
classes of ORBS</p>
<dl class="function">
<dt id="utils.ABmag2flambda">
<tt class="descclassname">utils.</tt><tt class="descname">ABmag2flambda</tt><big>(</big><em>ABmag</em>, <em>lam</em><big>)</big><a class="headerlink" href="#utils.ABmag2flambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert AB magnitude to flux in erg/cm2/s/A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ABmag</strong> &#8211; A magnitude in the AB magnitude system</li>
<li><strong>lam</strong> &#8211; Wavelength in angstrom</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.ABmag2fnu">
<tt class="descclassname">utils.</tt><tt class="descname">ABmag2fnu</tt><big>(</big><em>ABmag</em><big>)</big><a class="headerlink" href="#utils.ABmag2fnu" title="Permalink to this definition">¶</a></dt>
<dd><p>Return flux in erg/cm2/s/Hz from AB magnitude (Oke, ApJS, 27,
21, 1974)</p>
<p>ABmag = -2.5 * log10(f_nu) - 48.60
f_nu = 10^(-0.4 * (ABmag + 48.60))</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>ABmag</strong> &#8211; A magnitude in the AB magnitude system</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Definition of the zero-point can change and be
e.g. 48.59 for Oke standard stars (Hamuy et al., PASP, 104, 533,
1992). This is the case for Spectrophotometric Standards given
on the ESO website (<a class="reference external" href="https://www.eso.org/sci/observing/tools/standards/spectra/okestandards.html">https://www.eso.org/sci/observing/tools/standards/spectra/okestandards.html</a>). Here the HST definition is used.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.amplitude">
<tt class="descclassname">utils.</tt><tt class="descname">amplitude</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#utils.amplitude" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the amplitude of a complex number</p>
</dd></dl>

<dl class="function">
<dt id="utils.border_cut_window">
<tt class="descclassname">utils.</tt><tt class="descname">border_cut_window</tt><big>(</big><em>n</em>, <em>coeff=0.2</em><big>)</big><a class="headerlink" href="#utils.border_cut_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a window function with only the edges cut by a nice
gaussian shape function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> &#8211; Window length</li>
<li><strong>coeff</strong> &#8211; Border size in percentage of the total length.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.check_frames">
<tt class="descclassname">utils.</tt><tt class="descname">check_frames</tt><big>(</big><em>frames</em>, <em>sigma_reject=2.0</em><big>)</big><a class="headerlink" href="#utils.check_frames" title="Permalink to this definition">¶</a></dt>
<dd><p>Check and reject deviating frames based on their median level.</p>
<p>Frames with a too deviant median level are discarded. This
function is used by <a class="reference internal" href="#utils.create_master_frame" title="utils.create_master_frame"><tt class="xref py py-meth docutils literal"><span class="pre">utils.create_master_frame()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frames</strong> &#8211; Set of frames to check</li>
<li><strong>sigma_reject</strong> &#8211; (Optional) Rejection coefficient (default 2.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.compute_obs_params">
<tt class="descclassname">utils.</tt><tt class="descname">compute_obs_params</tt><big>(</big><em>nm_min_filter</em>, <em>nm_max_filter</em>, <em>theta_min=5.01</em>, <em>theta_max=11.28</em><big>)</big><a class="headerlink" href="#utils.compute_obs_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute observation parameters (order, step size) given the
filter bandpass.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nm_min_filter</strong> &#8211; Min wavelength of the filter in nm.</li>
<li><strong>nm_max_filter</strong> &#8211; Max wavelength of the filter in nm.</li>
<li><strong>theta_min</strong> &#8211; (Optional) Min angle of the detector (default
5.01).</li>
<li><strong>theta_max</strong> &#8211; (Optional) Max angle of the detector (default
11.28).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple (order, step size, max wavelength)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.correct_bad_frames_vector">
<tt class="descclassname">utils.</tt><tt class="descname">correct_bad_frames_vector</tt><big>(</big><em>bad_frames_vector</em>, <em>dimz</em><big>)</big><a class="headerlink" href="#utils.correct_bad_frames_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove bad indexes of the bad frame vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>bad_frames_vector</strong> &#8211; The vector of indexes to correct</li>
<li><strong>dimz</strong> &#8211; Dimension of the cube along the 3rd axis.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.correct_map2d">
<tt class="descclassname">utils.</tt><tt class="descname">correct_map2d</tt><big>(</big><em>map2d</em>, <em>bad_value=nan</em><big>)</big><a class="headerlink" href="#utils.correct_map2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct a map of values by interpolation along columns.</p>
<p>The bad value must be specified.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>map2d</strong> &#8211; The map to correct</li>
<li><strong>bad_value</strong> &#8211; (Optional) Value considered as bad (default
np.nan).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.correct_vector">
<tt class="descclassname">utils.</tt><tt class="descname">correct_vector</tt><big>(</big><em>vector</em>, <em>bad_value=nan</em>, <em>deg=3</em>, <em>polyfit=False</em><big>)</big><a class="headerlink" href="#utils.correct_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Correct a given vector for non valid values by interpolation or
polynomial fit.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>vector</strong> &#8211; The vector to be corrected.</li>
<li><strong>bad_value</strong> &#8211; (Optional) Bad value to correct (default np.nan)</li>
<li><strong>deg</strong> &#8211; (Optional) Spline degree or polyfit degree (default 3)</li>
<li><strong>polyfit</strong> &#8211; (Optional) If True non valid values are guessed
using a polynomial fit to the data instead of an spline
interpolation (default False)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.count_nonzeros">
<tt class="descclassname">utils.</tt><tt class="descname">count_nonzeros</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#utils.count_nonzeros" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the length of nonzeros parts in a vector as a vector of
the same length with the length of each part at each occurence of
a nonzero number.</p>
<p>e.g. : if a = [0,0,0,1,1,0,1] this function returns: [0,0,0,2,2,0,1]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>a</strong> &#8211; A vector.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.create_cm1_axis">
<tt class="descclassname">utils.</tt><tt class="descname">create_cm1_axis</tt><big>(</big><em>n</em>, <em>step</em>, <em>order</em>, <em>corr=1.0</em><big>)</big><a class="headerlink" href="#utils.create_cm1_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a regular wavenumber axis in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> &#8211; Number of steps on the axis</li>
<li><strong>step</strong> &#8211; Step size in nm</li>
<li><strong>order</strong> &#8211; Folding order</li>
<li><strong>corr</strong> &#8211; (Optional) Coefficient of correction (default 1.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.create_master_frame">
<tt class="descclassname">utils.</tt><tt class="descname">create_master_frame</tt><big>(</big><em>frames</em>, <em>combine='average'</em>, <em>reject='avsigclip'</em>, <em>sigma=3.0</em>, <em>silent=False</em>, <em>check=True</em><big>)</big><a class="headerlink" href="#utils.create_master_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a master frame from a set a frames.</p>
<p>This method has been inspired by the <strong>IRAF</strong> function
combine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frames</strong> &#8211; Frames to combine.</li>
<li><strong>reject</strong> &#8211; (Optional) Rejection operation. Can be &#8216;sigclip&#8217;,
&#8216;minmax&#8217;, &#8216;avsigclip&#8217; (default &#8216;avsigclip&#8217;)</li>
<li><strong>combine</strong> &#8211; (Optional) Combining operation. Can be
&#8216;average&#8217; or &#8216;median&#8217; (default &#8216;average&#8217;)</li>
<li><strong>sigma</strong> &#8211; (Optional) Sigma factor for pixel rejection
(default 3.).</li>
<li><strong>silent</strong> &#8211; (Optional) If True no information message are
displayed.</li>
<li><strong>check</strong> &#8211; (Optional) If True deviating frames are rejected
before combination (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Rejection operations:</p>
<ul class="last simple">
<li><strong>sigclip</strong>: A Sigma Clipping algorithm is applied for
each pixel. Min and max values are rejected to estimate
the mean and the standard deviation at each pixel. Then
all values over (median + sigma * std) or below (median -
sigma * std) are rejected. Those steps are repeated (this
time not excluding the extreme values) while no other
value is rejected or the minimum number of values to keep
is reached. Work best with at least 10 frames.</li>
<li><strong>avsigclip</strong>: Average Sigma Clipping algorithm is the
same as Sigma Clipping algorithm but the standard
deviation at each pixel is estimated using an averaged
value of the std over the lines. This work best than sigma
clipping for a small number of frames. This algorithm is a
little more time consuming than the others. Works best with
at least 5 frames.</li>
<li><strong>minmax</strong>: Minimum and maximum values at each pixel are
rejected.</li>
</ul>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">No rejection operation can be performed with less
than 3 frames.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.create_nm_axis">
<tt class="descclassname">utils.</tt><tt class="descname">create_nm_axis</tt><big>(</big><em>n</em>, <em>step</em>, <em>order</em>, <em>nm_max=None</em><big>)</big><a class="headerlink" href="#utils.create_nm_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a regular wavelength axis in nm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> &#8211; Number of steps on the axis</li>
<li><strong>step</strong> &#8211; Step size in nm</li>
<li><strong>order</strong> &#8211; Folding order</li>
<li><strong>nm_max</strong> &#8211; (Optional) Must be given if order is 0 (default None)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">If the order is equal to zero, nm_max (the maximum
wavelength observed) must be specified because in cannot be
defined using only the the step and order arguments.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.create_nm_axis_ireg">
<tt class="descclassname">utils.</tt><tt class="descname">create_nm_axis_ireg</tt><big>(</big><em>n</em>, <em>step</em>, <em>order</em>, <em>nm_max=None</em>, <em>corr=1.0</em><big>)</big><a class="headerlink" href="#utils.create_nm_axis_ireg" title="Permalink to this definition">¶</a></dt>
<dd><p>Create an irregular wavelength axis from the regular wavenumber
axis in cm-1.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>n</strong> &#8211; Number of steps on the axis</li>
<li><strong>step</strong> &#8211; Step size in nm</li>
<li><strong>order</strong> &#8211; Folding order</li>
<li><strong>nm_max</strong> &#8211; (Optional) Must be given if order is 0 (default None)</li>
<li><strong>corr</strong> &#8211; (Optional) Coefficient of correction (default 1.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.cube_raw_fft">
<tt class="descclassname">utils.</tt><tt class="descname">cube_raw_fft</tt><big>(</big><em>x</em>, <em>apod=None</em><big>)</big><a class="headerlink" href="#utils.cube_raw_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the raw FFT of a cube (the last axis
beeing the interferogram axis)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; Interferogram cube</li>
<li><strong>apod</strong> &#8211; (Optional) Apodization function used. See
<a class="reference internal" href="#utils.norton_beer_window" title="utils.norton_beer_window"><tt class="xref py py-meth docutils literal"><span class="pre">utils.norton_beer_window()</span></tt></a> (default None)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.fft_filter">
<tt class="descclassname">utils.</tt><tt class="descname">fft_filter</tt><big>(</big><em>a</em>, <em>cutoff_coeff</em>, <em>width_coeff=0.2</em>, <em>filter_type='high_pass'</em><big>)</big><a class="headerlink" href="#utils.fft_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple lowpass or highpass FFT filter (high pass or low pass)</p>
<p>Filter shape is a gaussian.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; Vector to filter</li>
<li><strong>cutoff_coeff</strong> &#8211; Coefficient defining the position of the cut
frequency (Cut frequency = cut_coeff * vector length)</li>
<li><strong>width_coeff</strong> &#8211; (Optional) Coefficient defining the width of
the smoothed part of the filter (width = width_coeff * vector
length) (default 0.2)</li>
<li><strong>filter_type</strong> &#8211; (Optional) Type of filter to use. Can be
&#8216;high_pass&#8217; or &#8216;low_pass&#8217;.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.find_zpd">
<tt class="descclassname">utils.</tt><tt class="descname">find_zpd</tt><big>(</big><em>interf</em>, <em>step_number=None</em>, <em>return_zpd_shift=False</em><big>)</big><a class="headerlink" href="#utils.find_zpd" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the index of the ZPD along the z axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>step_number</strong> &#8211; (Optional) If the full number of steps is
greater than the number of frames of the cube. Useful when
the interferograms are non symetric (default None).</li>
<li><strong>return_zpd_shift</strong> &#8211; (Optional) If True return ZPD shift
instead of ZPD index (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.fit_lines_in_vector">
<tt class="descclassname">utils.</tt><tt class="descname">fit_lines_in_vector</tt><big>(</big><em>vector</em>, <em>lines</em>, <em>fwhm_guess=3.5</em>, <em>cont_guess=None</em>, <em>shift_guess=0.0</em>, <em>fix_cont=False</em>, <em>fix_fwhm=False</em>, <em>cov_fwhm=True</em>, <em>cov_pos=True</em>, <em>reguess_positions=False</em>, <em>return_fitted_vector=False</em>, <em>fit_tol=0.001</em>, <em>no_absorption=False</em>, <em>poly_order=0</em>, <em>fmodel='gaussian'</em>, <em>sig_noise=None</em>, <em>interpolation_params=None</em>, <em>signal_range=None</em><big>)</big><a class="headerlink" href="#utils.fit_lines_in_vector" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit multiple gaussian shaped emission lines in a spectrum vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>vector</strong> &#8211; Vector to fit</li>
<li><strong>lines</strong> &#8211; Positions of the lines in channels</li>
<li><strong>fwhm_guess</strong> &#8211; (Optional) Initial guess on the lines FWHM
(default 3.5).</li>
<li><strong>cont_guess</strong> &#8211; (Optional) Initial guess on the continuum
(default None). Must be a tuple of poly_order + 1 values ordered
with the highest orders first.</li>
<li><strong>shift_guess</strong> &#8211; (Optional) Initial guess on the global shift
of the lines (default 0.).</li>
<li><strong>fix_cont</strong> &#8211; (Optional) If True, continuum is fixed to the
initial guess (default False).</li>
<li><strong>fix_fwhm</strong> &#8211; (Optional) If True, FWHM value is fixed to the
initial guess (default False).</li>
<li><strong>cov_fwhm</strong> &#8211; (Optional) If True FWHM is considered to be the
same for all lines and become a covarying parameter (default
True).</li>
<li><strong>cov_pos</strong> &#8211; (Optional) If True the estimated relative
positions of the lines (the lines parameter) are considered to
be exact and only need to be shifted. Positions are thus
covarying. Very useful but the initial estimation of the line
relative positions must be very precise (default False).</li>
<li><strong>reguess_positions</strong> &#8211; (Optional) If True, positions are
guessed again. Useful if the given estimations really are rough
ones. Note that this must not be used with cov_pos set to True
(default False).</li>
<li><strong>return_fitted_vector</strong> &#8211; (Optional) If True Fitted vector is
returned.</li>
<li><strong>fit_tol</strong> &#8211; (Optional) Tolerance on the fit value (default
1e-2).</li>
<li><strong>no_absorption</strong> &#8211; (Optional) If True, no negative amplitude
are returned (default False).</li>
<li><strong>poly_order</strong> &#8211; (Optional) Order of the polynomial used to fit
continuum. Use high orders carefully (default 0).</li>
<li><strong>fmodel</strong> &#8211; (Optional) Fitting model. Can be &#8216;gaussian&#8217;, 
&#8216;sinc&#8217; or &#8216;sinc2&#8217; (default &#8216;gaussian&#8217;).</li>
<li><strong>sig_noise</strong> &#8211; (Optional) Noise standard deviation guess. If
None noise value is guessed but the gaussian FWHM must not
exceed half of the sampling interval (default None).</li>
<li><strong>interpolation_params</strong> &#8211; (Optional) Must be a tuple [step,
order]. Interpolate data before fitting when data has been
previously interpolated from an irregular wavelength axis to a
regular one.</li>
<li><strong>signal_range</strong> &#8211; (Optional) a tuple (x_min, x_max) giving the
lowest and highest channel numbers containing signal.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>a dictionary containing:</p>
<ul class="simple">
<li>lines parameters [key: &#8216;lines-params&#8217;] Lines parameters are
given as an array of shape (lines_nb, 4). The order of the 4
parameters for each lines is [height at the center of the
line, ampitude, position, fwhm].</li>
<li>lines parameters errors [key: &#8216;lines-params-err&#8217;]</li>
<li>residual [key: &#8216;residual&#8217;]</li>
<li>chi-square [key: &#8216;chi-square&#8217;]</li>
<li>reduced chi-square [key: &#8216;reduced-chi-square&#8217;]</li>
<li>SNR [key: &#8216;snr&#8217;]</li>
<li>continuum parameters [key: &#8216;cont-params&#8217;]</li>
<li>and optionally the fitted vector [key: &#8216;fitted-vector&#8217;]
depending on the option return_fitted_vector.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.fnu2flambda">
<tt class="descclassname">utils.</tt><tt class="descname">fnu2flambda</tt><big>(</big><em>fnu</em>, <em>nu</em><big>)</big><a class="headerlink" href="#utils.fnu2flambda" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a flux in erg/cm2/s/Hz to a flux in erg/cm2/s/A</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fnu</strong> &#8211; Flux in erg/cm2/s/Hz</li>
<li><strong>nu</strong> &#8211; frequency in Hz</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.gaussian1d">
<tt class="descclassname">utils.</tt><tt class="descname">gaussian1d</tt><big>(</big><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em><big>)</big><a class="headerlink" href="#utils.gaussian1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D gaussian given a set of parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; Array giving the positions where the gaussian is evaluated</li>
<li><strong>h</strong> &#8211; Height</li>
<li><strong>a</strong> &#8211; Amplitude</li>
<li><strong>dx</strong> &#8211; Position of the center</li>
<li><strong>w</strong> &#8211; FWHM, <span class="math">\(\text{FWHM} = \text{Width} \times 2 \sqrt{2 \ln 2}\)</span></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.get_box_coords">
<tt class="descclassname">utils.</tt><tt class="descname">get_box_coords</tt><big>(</big><em>ix</em>, <em>iy</em>, <em>box_size</em>, <em>x_lim_min</em>, <em>x_lim_max</em>, <em>y_lim_min</em>, <em>y_lim_max</em><big>)</big><a class="headerlink" href="#utils.get_box_coords" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the coordinates of a box given the center of the box,
its size and the limits of the range along x and y axes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ix</strong> &#8211; center of the box along x axis</li>
<li><strong>iy</strong> &#8211; center of the box along y axis</li>
<li><strong>box_size</strong> &#8211; Size of the box. The final size of the box will
generally be the same if box_size is odd. Note that the final
size of the box cannot be guaranteed.</li>
<li><strong>x_lim_min</strong> &#8211; Minimum limit of the range along x.</li>
<li><strong>x_lim_max</strong> &#8211; Maximum limit of the range along x.</li>
<li><strong>y_lim_min</strong> &#8211; Minimum limit of the range along y.</li>
<li><strong>y_lim_max</strong> &#8211; Maximum limit of the range along y.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.get_filter_edges_pix">
<tt class="descclassname">utils.</tt><tt class="descname">get_filter_edges_pix</tt><big>(</big><em>filter_file_path</em>, <em>correction_factor</em>, <em>step</em>, <em>order</em>, <em>n</em>, <em>filter_min=None</em>, <em>filter_max=None</em><big>)</big><a class="headerlink" href="#utils.get_filter_edges_pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the position in pixels of the edges of a filter
corrected for the off-axis effect.</p>
<p>Note that the axis is assumed to be uncalibrated. Spectra are
generally calibrated but phase vectors are not. So this function
is best used with phase vectors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>filter_file_path</strong> &#8211; Path to the filter file. If None,
filter_min and filter_max must be specified.</li>
<li><strong>step</strong> &#8211; Step size of the moving mirror in nm.</li>
<li><strong>order</strong> &#8211; Folding order.</li>
<li><strong>correction_factor</strong> &#8211; Correction factor
(i.e. calibration_map_value / laser_wavelength)</li>
<li><strong>n</strong> &#8211; Number of points of the interpolation axis.</li>
<li><strong>filter_min</strong> &#8211; (Optional) Edge min of the filter in nm
(default None).</li>
<li><strong>filter_max</strong> &#8211; (Optional) Edge max of the filter in nm
(default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#utils.read_filter_file" title="utils.read_filter_file"><tt class="xref py py-meth docutils literal"><span class="pre">utils.read_filter_file()</span></tt></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.get_filter_function">
<tt class="descclassname">utils.</tt><tt class="descname">get_filter_function</tt><big>(</big><em>filter_file_path</em>, <em>step</em>, <em>order</em>, <em>n</em><big>)</big><a class="headerlink" href="#utils.get_filter_function" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a filter file and return its function interpolated over
the desired number of points. Return also the edges position over
its axis in pixels.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filter_file_path</strong> &#8211; Path to the filter file.</li>
<li><strong>step</strong> &#8211; Step size of the moving mirror in nm.</li>
<li><strong>order</strong> &#8211; Folding order.</li>
<li><strong>n</strong> &#8211; Number of points of the interpolation axis.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">(interpolated filter function, min edge, max edge). Min
and max edges are given in pixels over the interpolation axis.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#utils.read_filter_file" title="utils.read_filter_file"><tt class="xref py py-meth docutils literal"><span class="pre">utils.read_filter_file()</span></tt></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.get_lr_phase">
<tt class="descclassname">utils.</tt><tt class="descname">get_lr_phase</tt><big>(</big><em>interf</em>, <em>n_phase=None</em>, <em>return_lr_spectrum=False</em><big>)</big><a class="headerlink" href="#utils.get_lr_phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a low resolution phase from a given interferogram vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>interf</strong> &#8211; Interferogram vector</li>
<li><strong>n_phase</strong> &#8211; (Optional) Number of points for phase
computation. Of course it can be no greater than the number of
points of the interferogram. If None, this is set to 50% of the
interferogram length (Default None).</li>
<li><strong>return_lr_spectrum</strong> &#8211; (Optional) If True return also the low
resolution spectrum from which phase is computed (Default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.get_mask_from_ds9_region_file">
<tt class="descclassname">utils.</tt><tt class="descname">get_mask_from_ds9_region_file</tt><big>(</big><em>reg_path</em>, <em>x_range=None</em>, <em>y_range=None</em><big>)</big><a class="headerlink" href="#utils.get_mask_from_ds9_region_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the indices of the elements inside &#8216;box&#8217;, &#8216;circle&#8217; and
&#8216;polygon&#8217; regions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>reg_path</strong> &#8211; Path to a ds9 region file</li>
<li><strong>x_range</strong> &#8211; (Optional) Range of x image coordinates
considered as valid. Pixels outside this range are
rejected. If None, no validation is done (default None).</li>
<li><strong>y_range</strong> &#8211; (Optional) Range of y image coordinates
considered as valid. Pixels outside this range are
rejected. If None, no validation is done (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned array can be used like a list of
indices returned by e.g. numpy.nonzero().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Coordinates can be image coordinates (x,y) or sky
coordinates in degrees (ra, dec)</p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.get_mask_from_ds9_region_line">
<tt class="descclassname">utils.</tt><tt class="descname">get_mask_from_ds9_region_line</tt><big>(</big><em>reg_line</em>, <em>x_range=None</em>, <em>y_range=None</em><big>)</big><a class="headerlink" href="#utils.get_mask_from_ds9_region_line" title="Permalink to this definition">¶</a></dt>
<dd><p>Read one line of a ds9 region file and return the list of
pixels in the region.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>reg_line</strong> &#8211; Line of the ds9 region file</li>
<li><strong>x_range</strong> &#8211; (Optional) Range of x image coordinates
considered as valid. Pixels outside this range are
rejected. If None, no validation is done (default None).</li>
<li><strong>y_range</strong> &#8211; (Optional) Range of y image coordinates
considered as valid. Pixels outside this range are
rejected. If None, no validation is done (default None).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The returned array can be used like a list of
indices returned by e.g. numpy.nonzero().</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Coordinates can be image coordinates (x,y) or sky
coordinates in degrees (ra, dec)</p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.get_open_fds">
<tt class="descclassname">utils.</tt><tt class="descname">get_open_fds</tt><big>(</big><big>)</big><a class="headerlink" href="#utils.get_open_fds" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the number of open file descriptors</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Only works on UNIX-like OS</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is a useful debugging function that has been taken from: <a class="reference external" href="http://stackoverflow.com/questions/2023608/check-what-files-are-open-in-python">http://stackoverflow.com/questions/2023608/check-what-files-are-open-in-python</a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.high_pass_diff_image_filter">
<tt class="descclassname">utils.</tt><tt class="descname">high_pass_diff_image_filter</tt><big>(</big><em>im</em>, <em>deg=1</em><big>)</big><a class="headerlink" href="#utils.high_pass_diff_image_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a high pass filtered image using the method of low pass
diffrence filtering given by Mighell (1999).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>im</strong> &#8211; Image to filter</li>
<li><strong>deg</strong> &#8211; (Optional) Radius of the kernel of the low pass
filter. Must be &gt; 0 (default 2).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.high_pass_image_filter">
<tt class="descclassname">utils.</tt><tt class="descname">high_pass_image_filter</tt><big>(</big><em>im</em><big>)</big><a class="headerlink" href="#utils.high_pass_image_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a high pass filtered image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>im</strong> &#8211; Image to filter</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.imag">
<tt class="descclassname">utils.</tt><tt class="descname">imag</tt><big>(</big><em>amp</em>, <em>pha</em><big>)</big><a class="headerlink" href="#utils.imag" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the imaginary part from amplitude and phase</p>
</dd></dl>

<dl class="function">
<dt id="utils.interf_mean_energy">
<tt class="descclassname">utils.</tt><tt class="descname">interf_mean_energy</tt><big>(</big><em>interf</em><big>)</big><a class="headerlink" href="#utils.interf_mean_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean energy of an interferogram by step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>interf</strong> &#8211; an interferogram</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The mean of the interferogram is substracted to
compute only the modulation energy. This is the modulation
energy which must be conserved in the resulting spectrum. Note
that the interferogram transformation function (see
<a class="reference internal" href="#utils.transform_interferogram" title="utils.transform_interferogram"><tt class="xref py py-meth docutils literal"><span class="pre">utils.transform_interferogram()</span></tt></a>) remove the mean of the
interferogram before computing its FFT.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">NaNs are set to 0.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.interpolate_axis">
<tt class="descclassname">utils.</tt><tt class="descname">interpolate_axis</tt><big>(</big><em>a</em>, <em>new_axis</em>, <em>deg</em>, <em>old_axis=None</em>, <em>fill_value=0.0</em><big>)</big><a class="headerlink" href="#utils.interpolate_axis" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate a vector along a new axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; vector to interpolate</li>
<li><strong>new_axis</strong> &#8211; Interpolation axis</li>
<li><strong>deg</strong> &#8211; Interpolation degree</li>
<li><strong>old_axis</strong> &#8211; (Optional) Original vector axis. If None,
a regular range axis is assumed (default None).</li>
<li><strong>fill_value</strong> &#8211; (Optional) extrapolated points are filled with
this value (default 0.)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.interpolate_map">
<tt class="descclassname">utils.</tt><tt class="descname">interpolate_map</tt><big>(</big><em>calibration_map</em>, <em>dimx</em>, <em>dimy</em><big>)</big><a class="headerlink" href="#utils.interpolate_map" title="Permalink to this definition">¶</a></dt>
<dd><p>Interpolate 2D data map.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>calibration_map</strong> &#8211; Map</li>
<li><strong>dimx</strong> &#8211; X dimension of the result</li>
<li><strong>dimy</strong> &#8211; Y dimension of the result</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.interpolate_size">
<tt class="descclassname">utils.</tt><tt class="descname">interpolate_size</tt><big>(</big><em>a</em>, <em>size</em>, <em>deg</em><big>)</big><a class="headerlink" href="#utils.interpolate_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Change size of a vector by interpolation</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; vector to interpolate</li>
<li><strong>size</strong> &#8211; New size of the vector</li>
<li><strong>deg</strong> &#8211; Interpolation degree</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.lambda2nu">
<tt class="descclassname">utils.</tt><tt class="descname">lambda2nu</tt><big>(</big><em>lam</em><big>)</big><a class="headerlink" href="#utils.lambda2nu" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert lambda in Ang to nu in Hz</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>lam</strong> &#8211; Wavelength in angstrom</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.learner95_window">
<tt class="descclassname">utils.</tt><tt class="descname">learner95_window</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#utils.learner95_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the apodization function described in Learner et al.,
J. Opt. Soc. Am. A, 12, (1995).</p>
<p>This function is closely related to the minimum four-term
Blackman-Harris window.</p>
<p>Returned window is symmetrical.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> &#8211; Number of points.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.low_pass_image_filter">
<tt class="descclassname">utils.</tt><tt class="descname">low_pass_image_filter</tt><big>(</big><em>im</em>, <em>deg</em><big>)</big><a class="headerlink" href="#utils.low_pass_image_filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a low pass filtered image using a gaussian kernel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>im</strong> &#8211; Image to filter</li>
<li><strong>deg</strong> &#8211; Radius of the kernel. Must be &gt; 0.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.next_power_of_two">
<tt class="descclassname">utils.</tt><tt class="descname">next_power_of_two</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#utils.next_power_of_two" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the next power of two greater than n.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>n</strong> &#8211; The number from which the next power of two has to be
computed. Can be an array of numbers.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.nm2pix">
<tt class="descclassname">utils.</tt><tt class="descname">nm2pix</tt><big>(</big><em>nm_axis</em>, <em>nm</em><big>)</big><a class="headerlink" href="#utils.nm2pix" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a wavelength in nm to a pixel position given an axis
in nm</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nm_axis</strong> &#8211; Axis in nm</li>
<li><strong>nm</strong> &#8211; Wavelength in nm</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.norton_beer_window">
<tt class="descclassname">utils.</tt><tt class="descname">norton_beer_window</tt><big>(</big><em>fwhm='1.6'</em>, <em>n=1000</em><big>)</big><a class="headerlink" href="#utils.norton_beer_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Return an extended Norton-Beer window function (see <a class="reference internal" href="#nay2007" id="id1">[NAY2007]</a>).</p>
<p>Returned window is symmetrical.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fwhm</strong> &#8211; FWHM relative to the sinc function. Must be: 1.1,
1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9 or 2.0. (default &#8216;1.6&#8217;)</li>
<li><strong>n</strong> &#8211; Number of points (default 1000)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>Coefficients of the extended Norton-Beer functions
apodizing functions <a class="reference internal" href="#nay2007" id="id2">[NAY2007]</a> :</p>
<table border="1" class="last docutils">
<colgroup>
<col width="8%" />
<col width="15%" />
<col width="17%" />
<col width="15%" />
<col width="15%" />
<col width="15%" />
<col width="15%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>FWHM</td>
<td>C0</td>
<td>C1</td>
<td>C2</td>
<td>C4</td>
<td>C6</td>
<td>C8</td>
</tr>
<tr class="row-even"><td>1.1</td>
<td>0.701551</td>
<td>-0.639244</td>
<td>0.937693</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>1.2</td>
<td>0.396430</td>
<td>-0.150902</td>
<td>0.754472</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-even"><td>1.3</td>
<td>0.237413</td>
<td>-0.065285</td>
<td>0.827872</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>1.4</td>
<td>0.153945</td>
<td>-0.141765</td>
<td>0.987820</td>
<td>0.000000</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-even"><td>1.5</td>
<td>0.077112</td>
<td>0.000000</td>
<td>0.703371</td>
<td>0.219517</td>
<td>0.000000</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>1.6</td>
<td>0.039234</td>
<td>0.000000</td>
<td>0.630268</td>
<td>0.234934</td>
<td>0.095563</td>
<td>0.000000</td>
</tr>
<tr class="row-even"><td>1.7</td>
<td>0.020078</td>
<td>0.000000</td>
<td>0.480667</td>
<td>0.386409</td>
<td>0.112845</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>1.8</td>
<td>0.010172</td>
<td>0.000000</td>
<td>0.344429</td>
<td>0.451817</td>
<td>0.193580</td>
<td>0.000000</td>
</tr>
<tr class="row-even"><td>1.9</td>
<td>0.004773</td>
<td>0.000000</td>
<td>0.232473</td>
<td>0.464562</td>
<td>0.298191</td>
<td>0.000000</td>
</tr>
<tr class="row-odd"><td>2.0</td>
<td>0.002267</td>
<td>0.000000</td>
<td>0.140412</td>
<td>0.487172</td>
<td>0.256200</td>
<td>0.113948</td>
</tr>
</tbody>
</table>
</div>
<table class="docutils citation" frame="void" id="nay2007" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[NAY2007]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id2">2</a>)</em> Naylor, D. A., &amp; Tahic, M. K. (2007). Apodizing
functions for Fourier transform spectroscopy. Journal of the
Optical Society of America A.</td></tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.phase">
<tt class="descclassname">utils.</tt><tt class="descname">phase</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#utils.phase" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the phase of a complex number</p>
</dd></dl>

<dl class="function">
<dt id="utils.pix2nm">
<tt class="descclassname">utils.</tt><tt class="descname">pix2nm</tt><big>(</big><em>nm_axis</em>, <em>pix</em><big>)</big><a class="headerlink" href="#utils.pix2nm" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a pixel position to a wavelength in nm given an axis
in nm</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nm_axis</strong> &#8211; Axis in nm</li>
<li><strong>pix</strong> &#8211; Pixel position</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.polar_map2d">
<tt class="descclassname">utils.</tt><tt class="descname">polar_map2d</tt><big>(</big><em>f</em>, <em>n</em>, <em>corner=False</em>, <em>circle=True</em><big>)</big><a class="headerlink" href="#utils.polar_map2d" title="Permalink to this definition">¶</a></dt>
<dd><p>Map a function over a square matrix in polar coordinates. The
origin is placed at the center of the map by default.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>f</strong> &#8211; The function to map.</li>
<li><strong>n</strong> &#8211; Matrix size. Can be a couple of integers (nx, ny).</li>
<li><strong>corner</strong> &#8211; (Optional) If True, the origin of the coordinates
becomes the corner (0,0) of the map (default False)</li>
<li><strong>circle</strong> &#8211; (Optional) If False and if the matrix is not
squared, the coordinates are those of an ellipsis of the same
shape as the matrix (default True).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.polyfit1d">
<tt class="descclassname">utils.</tt><tt class="descname">polyfit1d</tt><big>(</big><em>a</em>, <em>deg</em>, <em>w=None</em>, <em>return_coeffs=False</em><big>)</big><a class="headerlink" href="#utils.polyfit1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a polynomial to a 1D vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; Vector to fit</li>
<li><strong>deg</strong> &#8211; Fit degree</li>
<li><strong>return_coeffs</strong> &#8211; (Optional) If True return fit coefficients
as returned by numpy.polynomial.polynomial.polyfit() (default
False).</li>
<li><strong>w</strong> &#8211; (Optional) If not None, weights to apply to the
fit. Must have the same shape as the vector to fit (default
None)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.pp_create_master_frame">
<tt class="descclassname">utils.</tt><tt class="descname">pp_create_master_frame</tt><big>(</big><em>frames</em>, <em>combine='average'</em>, <em>reject='avsigclip'</em>, <em>sigma=3.0</em><big>)</big><a class="headerlink" href="#utils.pp_create_master_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a parallelized version of <a class="reference internal" href="#utils.create_master_frame" title="utils.create_master_frame"><tt class="xref py py-meth docutils literal"><span class="pre">utils.create_master_frame()</span></tt></a>.</p>
<p>Use it only for big data set because it can be much slower for a
small data set (&lt; 500 x 500 x 10).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frames</strong> &#8211; Frames to combine.</li>
<li><strong>reject</strong> &#8211; (Optional) Rejection operation. Can be &#8216;sigclip&#8217;,
&#8216;minmax&#8217;, &#8216;avsigclip&#8217; (default &#8216;avsigclip&#8217;)</li>
<li><strong>combine</strong> &#8211; (Optional) Combining operation. Can be
&#8216;average&#8217; or &#8216;median&#8217; (default &#8216;average&#8217;)</li>
<li><strong>sigma</strong> &#8211; (Optional) Sigma factor for pixel rejection
(default 3.).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#utils.create_master_frame" title="utils.create_master_frame"><tt class="xref py py-meth docutils literal"><span class="pre">utils.create_master_frame()</span></tt></a></p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.raw_fft">
<tt class="descclassname">utils.</tt><tt class="descname">raw_fft</tt><big>(</big><em>x</em>, <em>apod=None</em>, <em>inverse=False</em><big>)</big><a class="headerlink" href="#utils.raw_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the raw FFT of a vector</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; Interferogram.</li>
<li><strong>apod</strong> &#8211; (Optional) Apodization function used. See
<a class="reference internal" href="#utils.norton_beer_window" title="utils.norton_beer_window"><tt class="xref py py-meth docutils literal"><span class="pre">utils.norton_beer_window()</span></tt></a> (default None)</li>
<li><strong>inverse</strong> &#8211; (Optional) If True compute the inverse FFT
(default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.read_filter_file">
<tt class="descclassname">utils.</tt><tt class="descname">read_filter_file</tt><big>(</big><em>filter_file_path</em><big>)</big><a class="headerlink" href="#utils.read_filter_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a file containing a the filter transmission function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filter_file_path</strong> &#8211; Path to the filter file.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">(list of filter wavelength, list of corresponding
transmission coefficients, minimum edge of the filter, maximum
edge of the filter) (Both min and max edges can be None if they
were not recorded in the file)</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The filter file used must have two colums separated by a
space character. The first column contains the wavelength axis
in nm. The second column contains the transmission
coefficients. Comments are preceded with a #.  Filter edges can
be specified using the keywords : FILTER_MIN and FILTER_MAX:</p>
<div class="last highlight-python"><pre>## ORBS filter file 
# Author: Thomas Martin &lt;thomas.martin.1@ulaval.ca&gt;
# Filter name : SpIOMM_R
# Wavelength in nm | Transmission percentage
# FILTER_MIN 648
# FILTER_MAX 678
1000 0.001201585284
999.7999878 0.009733387269
999.5999756 -0.0004460749624
999.4000244 0.01378122438
999.2000122 0.002538740868</pre>
</div>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.real">
<tt class="descclassname">utils.</tt><tt class="descname">real</tt><big>(</big><em>amp</em>, <em>pha</em><big>)</big><a class="headerlink" href="#utils.real" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the real part from amplitude and phase</p>
</dd></dl>

<dl class="function">
<dt id="utils.restore_error_settings">
<tt class="descclassname">utils.</tt><tt class="descname">restore_error_settings</tt><big>(</big><em>old_settings</em><big>)</big><a class="headerlink" href="#utils.restore_error_settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Restore old floating point error settings of numpy.</p>
</dd></dl>

<dl class="function">
<dt id="utils.robust_mean">
<tt class="descclassname">utils.</tt><tt class="descname">robust_mean</tt><big>(</big><em>a</em>, <em>weights=None</em>, <em>warn=True</em><big>)</big><a class="headerlink" href="#utils.robust_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean of a distribution even with NaN values</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; A distribution of values</li>
<li><strong>weights</strong> &#8211; Weights of each value of a (Must have the same
length as a). If None, weights are all considered equal to 1
(default None).</li>
<li><strong>warn</strong> &#8211; If True, warnings are raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.robust_median">
<tt class="descclassname">utils.</tt><tt class="descname">robust_median</tt><big>(</big><em>a</em>, <em>warn=True</em><big>)</big><a class="headerlink" href="#utils.robust_median" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the median of a distribution (skip NaN values).</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; A distribution of values</li>
<li><strong>warn</strong> &#8211; If True, warnings are raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.robust_std">
<tt class="descclassname">utils.</tt><tt class="descname">robust_std</tt><big>(</big><em>a</em>, <em>warn=True</em><big>)</big><a class="headerlink" href="#utils.robust_std" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the std of a distribution even with NaN values</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; A distribution of values</li>
<li><strong>warn</strong> &#8211; If True, warnings are raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.robust_sum">
<tt class="descclassname">utils.</tt><tt class="descname">robust_sum</tt><big>(</big><em>a</em>, <em>warn=True</em><big>)</big><a class="headerlink" href="#utils.robust_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the sum of a distribution (skip NaN values)</p>
<p>This is based on bottleneck module. See:
<a class="reference external" href="https://pypi.python.org/pypi/Bottleneck">https://pypi.python.org/pypi/Bottleneck</a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>a</strong> &#8211; A distribution of values</li>
<li><strong>warn</strong> &#8211; If True, warnings are raised.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.shift_frame">
<tt class="descclassname">utils.</tt><tt class="descname">shift_frame</tt><big>(</big><em>frame</em>, <em>dx</em>, <em>dy</em>, <em>x_min</em>, <em>x_max</em>, <em>y_min</em>, <em>y_max</em>, <em>order</em><big>)</big><a class="headerlink" href="#utils.shift_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a shifted frame.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frame</strong> &#8211; Two dimensions array to be shifted</li>
<li><strong>dx</strong> &#8211; Shift value along the axis 0</li>
<li><strong>dy</strong> &#8211; Shift value along the axis 1</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>x_min, x_max, y_min, y_max are the boundaries of the</dt>
<dd>region to be shifted. Return an array with the same dimensions</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">To avoid spline interpolation defects around
stars use order 1 (linear interpolation).</p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.sigmacut">
<tt class="descclassname">utils.</tt><tt class="descname">sigmacut</tt><big>(</big><em>x</em>, <em>sigma=3.0</em>, <em>min_values=3</em>, <em>central_value=None</em>, <em>warn=False</em><big>)</big><a class="headerlink" href="#utils.sigmacut" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a distribution after a sigma cut rejection
of the too deviant values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>x</strong> &#8211; The distribution to cut</li>
<li><strong>sigma</strong> &#8211; (Optional) Number of sigma above which values are
considered as deviant (default 3.)</li>
<li><strong>min_values</strong> &#8211; (Optional) Minimum number of values to return
(default 3)</li>
<li><strong>central_value</strong> &#8211; (Optional) If not none, this value is used as
the central value of the cut. Else the median of the
distribution is used as the central value (default None)</li>
<li><strong>warn</strong> &#8211; (Optional) If False no warning message is printed
(default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.sinc1d">
<tt class="descclassname">utils.</tt><tt class="descname">sinc1d</tt><big>(</big><em>x</em>, <em>h</em>, <em>a</em>, <em>dx</em>, <em>fwhm</em><big>)</big><a class="headerlink" href="#utils.sinc1d" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a 1D sinc 
:param x: Array giving the positions where the function is evaluated
:param h: Height
:param a: Amplitude
:param dx: Position of the center
:param w: FWHM</p>
</dd></dl>

<dl class="function">
<dt id="utils.smooth">
<tt class="descclassname">utils.</tt><tt class="descname">smooth</tt><big>(</big><em>a</em>, <em>deg=2</em>, <em>kind='gaussian'</em>, <em>keep_sides=True</em><big>)</big><a class="headerlink" href="#utils.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Smooth a given vector.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>a</strong> &#8211; Vector to smooth</li>
<li><strong>deg</strong> &#8211; (Optional) Smoothing degree (or kernel
radius) Must be an integer (default 2).</li>
<li><strong>kind</strong> &#8211; Kind of smoothing function. &#8216;median&#8217; or &#8216;mean&#8217; are
self-explanatory. &#8216;gaussian&#8217; uses a gaussian function for a
weighted average. &#8216;gaussian_conv&#8217; and &#8216;cos_conv&#8217; make use of
convolution with a gaussian kernel or a cosine
kernel. Convolution is much faster but less rigorous on the
edges of the vector (default &#8216;gaussian&#8217;).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">Params keep_sides:</th></tr>
<tr class="field-even field"><td>&nbsp;</td><td class="field-body"><p class="first last">If True, the vector is seen as keeping its
side values above its real boudaries (If False, the values
outside the vector are 0. and this creates an undesirable border
effect when convolving).</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.spectrum_mean_energy">
<tt class="descclassname">utils.</tt><tt class="descname">spectrum_mean_energy</tt><big>(</big><em>spectrum</em><big>)</big><a class="headerlink" href="#utils.spectrum_mean_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the mean energy of a spectrum by channel.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>spectrum</strong> &#8211; a 1D spectrum</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.transform_frame">
<tt class="descclassname">utils.</tt><tt class="descname">transform_frame</tt><big>(</big><em>frame</em>, <em>x_min</em>, <em>x_max</em>, <em>y_min</em>, <em>y_max</em>, <em>d</em>, <em>rc</em>, <em>zoom_factor</em>, <em>interp_order</em>, <em>mask=None</em><big>)</big><a class="headerlink" href="#utils.transform_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform one frame or a part of it using transformation
coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>frame</strong> &#8211; Frame to transform</li>
<li><strong>x_min</strong> &#8211; Lower x boundary of the frame to transform</li>
<li><strong>x_max</strong> &#8211; Upper x boundary of the frame to transform</li>
<li><strong>y_min</strong> &#8211; Lower y boundary of the frame to transform</li>
<li><strong>y_max</strong> &#8211; Upper y boundary of the frame to transform</li>
<li><strong>d</strong> &#8211; Transformation coefficients [dx, dy, dr, da, db]</li>
<li><strong>rc</strong> &#8211; Rotation center of the frame [rc_x, rc_y]</li>
<li><strong>zoom_factor</strong> &#8211; Zoom on the image</li>
<li><strong>interp_order</strong> &#8211; Interpolation order</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.transform_interferogram">
<tt class="descclassname">utils.</tt><tt class="descname">transform_interferogram</tt><big>(</big><em>interf</em>, <em>nm_laser</em>, <em>calibration_coeff</em>, <em>step</em>, <em>order</em>, <em>window_type</em>, <em>zpd_shift</em>, <em>n_phase=None</em>, <em>return_phase=False</em>, <em>ext_phase=None</em>, <em>nm_max=None</em>, <em>weights=None</em>, <em>polyfit_deg=1</em>, <em>balanced=True</em>, <em>bad_frames_vector=None</em>, <em>smoothing_deg=2</em>, <em>return_complex=False</em>, <em>final_step_nb=None</em>, <em>return_ireg_axis=False</em>, <em>conserve_energy=False</em><big>)</big><a class="headerlink" href="#utils.transform_interferogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform an interferogram into a spectrum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>interf</strong> &#8211; Interferogram to transform.</li>
<li><strong>nm_laser</strong> &#8211; Wavelength of the laser used for calibration.</li>
<li><strong>calibration_coeff</strong> &#8211; Wavelength of the laser emission line
corresponding to the computed interferogram.</li>
<li><strong>step</strong> &#8211; Step size of the moving mirror in nm.</li>
<li><strong>order</strong> &#8211; Folding order (can be 0 but nm_max must be specified).</li>
<li><strong>window_type</strong> &#8211; Name of the apodization function.</li>
<li><strong>zpd_shift</strong> &#8211; Shift of the interferogram to center the ZPD.</li>
<li><strong>bad_frames_vector</strong> &#8211; (Optional) Mask-like vector containing
ones for bad frames. Bad frames are replaced by zeros using a
special function that smoothes transition between good parts and
zeros (default None). This vector must be uncorrected for ZPD
shift</li>
<li><strong>n_phase</strong> &#8211; (Optional) Number of points to use for phase
correction. It can be no greater than interferogram length. If
0, no phase correction will be done and the resulting spectrum
will be the absolute value of the complex spectrum. If None, the
number of points is set to 20 percent of the interferogram
length (default None).</li>
<li><strong>ext_phase</strong> &#8211; (Optional) External phase vector. If given this
phase vector is used instead of a low-resolution one. It must be
as long as the interferogram.</li>
<li><strong>nm_max</strong> &#8211; (Optional) Maximum wavelength of the spectrum. Must be
specified if order is equal to 0 (default None).</li>
<li><strong>return_phase</strong> &#8211; (Optional) If True, compute only the phase of
the interferogram and return it. If polyfit_deg is &gt;= 0, return
the coefficients of the fitted phase (default False). Note that
this option is not compatible with ext_phase. You must set
ext_phase to None to set return_phase to True.</li>
<li><strong>weights</strong> &#8211; (Optional) A vector of the same length as the
number of points used to compute the phase (n_phase) giving the
weight of each point for interpolation (Must be a float between
0. and 1.). If none is given, the weights are defined by the
amplitude of the vector.</li>
<li><strong>polyfit_deg</strong> &#8211; (Optional) Degree of the polynomial fit to the
computed phase. If &lt; 0, no fit will be performed (Default 1).</li>
<li><strong>smoothing_deg</strong> &#8211; (Optional) Degree of zeros smoothing. A
higher degree means a smoother transition from zeros parts (bad
frames) to non-zero parts (good frames) of the
interferogram. Good parts on the other side of the ZPD in
symmetry with zeros parts are multiplied by 2. The same
transition is used to multiply interferogram points by zero and
2 (default 2). This operation is not done if smoothing_deg is
set to 0.</li>
<li><strong>balanced</strong> &#8211; (Optional) If False, the interferogram is
considered as unbalanced. It is flipped before its
transformation to get a positive spectrum. Note
that a merged interferogram is balanced (default True).</li>
<li><strong>return_complex</strong> &#8211; (Optional) If True and if phase is
corrected the returned spectrum will be complex. In False only
the real part is returned (default False)</li>
<li><strong>final_step_nb</strong> &#8211; (Optional) Number of samples of the
resulting spectrum. If None, the number of samples of the
spectrum will be the same as the interferogram (default None).</li>
<li><strong>return_ireg_axis</strong> &#8211; (Optional) If True, return spectrum along
an irregular wavelength axis corresponding to its regular cm-1
wavenumber axis (emission lines and especially unapodized sinc
emission lines are symetric) (default False).</li>
<li><strong>conserve_energy</strong> &#8211; (Optional) If True the energy is conserved
in the transformation (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Interferogram can be complex</p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.transform_spectrum">
<tt class="descclassname">utils.</tt><tt class="descname">transform_spectrum</tt><big>(</big><em>spectrum</em>, <em>nm_laser</em>, <em>calibration_coeff</em>, <em>step</em>, <em>order</em>, <em>window_type</em>, <em>zpd_shift</em>, <em>nm_max=None</em>, <em>ext_phase=None</em>, <em>return_complex=False</em><big>)</big><a class="headerlink" href="#utils.transform_spectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform a spectrum into an interferogram.</p>
<p>This function is the inverse of <a class="reference internal" href="#utils.transform_interferogram" title="utils.transform_interferogram"><tt class="xref py py-meth docutils literal"><span class="pre">utils.transform_interferogram()</span></tt></a>.</p>
<p>So that to get the initial interferogram, the same options used in
transform interferogram must be passed to this function. The
spectrum must also be the complex form (use return_complex option
in <a class="reference internal" href="#utils.transform_interferogram" title="utils.transform_interferogram"><tt class="xref py py-meth docutils literal"><span class="pre">utils.transform_interferogram()</span></tt></a>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>spectrum</strong> &#8211; Spectrum to transform</li>
<li><strong>nm_laser</strong> &#8211; Wavelength of the laser used for calibration.</li>
<li><strong>calibration_coeff</strong> &#8211; Wavelength of the laser emission line
corresponding to the computed interferogram.</li>
<li><strong>step</strong> &#8211; Step size of the moving mirror in nm.</li>
<li><strong>order</strong> &#8211; Folding order (can be 0 but nm_max must be specified).</li>
<li><strong>window_type</strong> &#8211; Name of the apodization function.</li>
<li><strong>zpd_shift</strong> &#8211; Shift of the interferogram to decenter the ZPD.</li>
<li><strong>nm_max</strong> &#8211; (Optional) Maximum wavelength of the spectrum. Must be
specified if order is equal to 0 (default None).</li>
<li><strong>ext_phase</strong> &#8211; (Optional) External phase vector. If given this
phase vector is used replacing the original phase of the
spectrum. Useful to add a phase to an interferogram. Note that
this phase is intended to be used to inverse transform an
already transformed interferogram. The computed phase correction
can thus be used directly. As the phase vector given by
<a class="reference internal" href="#utils.transform_interferogram" title="utils.transform_interferogram"><tt class="xref py py-meth docutils literal"><span class="pre">utils.transform_interferogram()</span></tt></a> is not reversed for
even orders, it is reversed here in this function.</li>
<li><strong>return_complex</strong> &#8211; If True return a complex
interferogram. Else return the real part of it (default False).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Interferogram can be complex</p>
</div>
</dd></dl>

<dl class="function">
<dt id="utils.transform_star_position_A_to_B">
<tt class="descclassname">utils.</tt><tt class="descname">transform_star_position_A_to_B</tt><big>(</big><em>star_list_A</em>, <em>params</em>, <em>rc</em>, <em>zoom_factor</em><big>)</big><a class="headerlink" href="#utils.transform_star_position_A_to_B" title="Permalink to this definition">¶</a></dt>
<dd><p>Transform star positions in camera A to the same star position
in camera B given the transformation parameters</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>star_list_A</strong> &#8211; List of star coordinates in the cube A.</li>
<li><strong>params</strong> &#8211; Transformation parameters [dx, dy, dr, da, db].</li>
<li><strong>rc</strong> &#8211; Rotation center coordinates.</li>
<li><strong>zoom_factor</strong> &#8211; Zooming factor between the two cameras.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="utils.variable_me">
<tt class="descclassname">utils.</tt><tt class="descname">variable_me</tt><big>(</big><em>n</em>, <em>params</em><big>)</big><a class="headerlink" href="#utils.variable_me" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sinusoidal function representing a variable
modulation efficiency.</p>
<p>This function is used to correct for fringes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params</strong> &#8211; A tuple of floats [frequency, amplitude,
phase]. The frequency gives the number of repetition of a sinus
over the vector. The amplitude must be between 0. (returns a
vector of 1) and 1. (returns a sinus going from 0 to 1). Phase
can be a single float or a vector of size n</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="cutils_module.html" title="CUtils module"
             >next</a> |</li>
        <li class="right" >
          <a href="core_module.html" title="Core module"
             >previous</a> |</li>
        <li><a href="index.html">Orb 1.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Thomas Martin (thomas.martin.1@ulaval.ca).
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>